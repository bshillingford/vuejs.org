<h1 id="installation"><a name=#guide/installation.md></a>Installation</h1>
<h3 id="compatibility-note">Compatibility Note</h3>
<p>Vue does <strong>not</strong> support IE8 and below, because it uses ECMAScript 5 features that are un-shimmable in IE8. However it supports all <a href="https://caniuse.com/#feat=es5">ECMAScript 5 compliant browsers</a>.</p>
<h3 id="semantic-versioning">Semantic Versioning</h3>
<p>Vue follows <a href="https://semver.org/">Semantic Versioning</a> in all its official projects for documented features and behavior. For undocumented behavior or exposed internals, changes are described in <a href="https://github.com/vuejs/vue/releases">release notes</a>.</p>
<h3 id="release-notes">Release Notes</h3>
<p>Latest stable version: {{vue_version}}</p>
<p>Detailed release notes for each version are available on <a href="https://github.com/vuejs/vue/releases">GitHub</a>.</p>
<h2 id="vue-devtools">Vue Devtools</h2>
<p>When using Vue, we recommend also installing the <a href="https://github.com/vuejs/vue-devtools#vue-devtools">Vue Devtools</a> in your browser, allowing you to inspect and debug your Vue applications in a more user-friendly interface.</p>
<h2 id="direct-script-include">Direct <code>&lt;script&gt;</code> Include</h2>
<p>Simply download and include with a script tag. <code>Vue</code> will be registered as a global variable.</p>
<p class="tip">
Don't use the minified version during development. You will miss out on all the nice warnings for common mistakes!
</p>
<div id="downloads">
<p><a class="button" href="/js/vue.js" download>Development Version</a><span class="light info">With full warnings and debug mode</span></p>
<p><a class="button" href="/js/vue.min.js" download>Production Version</a><span class="light info">Warnings stripped, {{gz_size}}KB min+gzip</span></p>
</div>
<h3 id="cdn">CDN</h3>
<p>For prototyping or learning purposes, you can use the latest version with:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span><span class="kw">&gt;&lt;/script&gt;</span></code></pre></div>
<p>For production, we recommend linking to a specific version number and build to avoid unexpected breakage from newer versions:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.0&quot;</span><span class="kw">&gt;&lt;/script&gt;</span></code></pre></div>
<p>If you are using native ES Modules, there is also an ES Modules compatible build:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;script</span><span class="ot"> type=</span><span class="st">&quot;module&quot;</span><span class="kw">&gt;</span>
  <span class="im">import</span> Vue <span class="im">from</span> <span class="st">&#39;https://cdn.jsdelivr.net/npm/vue@2.6.0/dist/vue.esm.browser.js&#39;</span>
<span class="kw">&lt;/script&gt;</span></code></pre></div>
<p>You can browse the source of the NPM package at <a href="https://cdn.jsdelivr.net/npm/vue/">cdn.jsdelivr.net/npm/vue</a>.</p>
<p>Vue is also available on <a href="https://unpkg.com/vue@%7B%7Bvue_version%7D%7D/dist/vue.js">unpkg</a> and <a href="https://cdnjs.cloudflare.com/ajax/libs/vue/%7B%7Bvue_version%7D%7D/vue.js">cdnjs</a> (cdnjs takes some time to sync so the latest release may not be available yet).</p>
<p>Make sure to read about <a href="#Explanation-of-Different-Builds">the different builds of Vue</a> and use the <strong>production version</strong> in your published site, replacing <code>vue.js</code> with <code>vue.min.js</code>. This is a smaller build optimized for speed instead of development experience.</p>
<h2 id="npm">NPM</h2>
<p>NPM is the recommended installation method when building large scale applications with Vue. It pairs nicely with module bundlers such as <a href="https://webpack.js.org/">Webpack</a> or <a href="http://browserify.org/">Browserify</a>. Vue also provides accompanying tools for authoring <a href="single-file-components.html">Single File Components</a>.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># latest stable</span>
$ <span class="ex">npm</span> install vue</code></pre></div>
<h2 id="cli">CLI</h2>
<p>Vue provides an <a href="https://github.com/vuejs/vue-cli">official CLI</a> for quickly scaffolding ambitious Single Page Applications. It provides batteries-included build setups for a modern frontend workflow. It takes only a few minutes to get up and running with hot-reload, lint-on-save, and production-ready builds. See <a href="https://cli.vuejs.org">the Vue CLI docs</a> for more details.</p>
<p class="tip">
The CLI assumes prior knowledge of Node.js and the associated build tools. If you are new to Vue or front-end build tools, we strongly suggest going through <a href="#index.md">the guide</a> without any build tools before using the CLI.
</p>
<div class="vue-mastery">
<a href="https://www.vuemastery.com/courses/real-world-vue-js/vue-cli" target="_blank" rel="sponsored noopener" title="Vue CLI">Watch a video explanation on Vue Mastery</a>
</div>
<h2 id="explanation-of-different-builds">Explanation of Different Builds</h2>
<p>In the <a href="https://cdn.jsdelivr.net/npm/vue/dist/"><code>dist/</code> directory of the NPM package</a> you will find many different builds of Vue.js. Here's an overview of the difference between them:</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>UMD</th>
<th>CommonJS</th>
<th>ES Module (for bundlers)</th>
<th>ES Module (for browsers)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Full</strong></td>
<td>vue.js</td>
<td>vue.common.js</td>
<td>vue.esm.js</td>
<td>vue.esm.browser.js</td>
</tr>
<tr class="even">
<td><strong>Runtime-only</strong></td>
<td>vue.runtime.js</td>
<td>vue.runtime.common.js</td>
<td>vue.runtime.esm.js</td>
<td>-</td>
</tr>
<tr class="odd">
<td><strong>Full (production)</strong></td>
<td>vue.min.js</td>
<td>-</td>
<td>-</td>
<td>vue.esm.browser.min.js</td>
</tr>
<tr class="even">
<td><strong>Runtime-only (production)</strong></td>
<td>vue.runtime.min.js</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="terms">Terms</h3>
<ul>
<li><p><strong>Full</strong>: builds that contain both the compiler and the runtime.</p></li>
<li><p><strong>Compiler</strong>: code that is responsible for compiling template strings into JavaScript render functions.</p></li>
<li><p><strong>Runtime</strong>: code that is responsible for creating Vue instances, rendering and patching virtual DOM, etc. Basically everything minus the compiler.</p></li>
<li><p><strong><a href="https://github.com/umdjs/umd">UMD</a></strong>: UMD builds can be used directly in the browser via a <code>&lt;script&gt;</code> tag. The default file from jsDelivr CDN at <a href="https://cdn.jsdelivr.net/npm/vue" class="uri">https://cdn.jsdelivr.net/npm/vue</a> is the Runtime + Compiler UMD build (<code>vue.js</code>).</p></li>
<li><p><strong><a href="http://wiki.commonjs.org/wiki/Modules/1.1">CommonJS</a></strong>: CommonJS builds are intended for use with older bundlers like <a href="http://browserify.org/">browserify</a> or <a href="https://webpack.github.io">webpack 1</a>. The default file for these bundlers (<code>pkg.main</code>) is the Runtime only CommonJS build (<code>vue.runtime.common.js</code>).</p></li>
<li><p><strong><a href="http://exploringjs.com/es6/ch_modules.html">ES Module</a></strong>: starting in 2.6 Vue provides two ES Modules (ESM) builds:</p></li>
<li><p>ESM for bundlers: intended for use with modern bundlers like <a href="https://webpack.js.org">webpack 2</a> or <a href="https://rollupjs.org/">Rollup</a>. ESM format is designed to be statically analyzable so the bundlers can take advantage of that to perform &quot;tree-shaking&quot; and eliminate unused code from your final bundle. The default file for these bundlers (<code>pkg.module</code>) is the Runtime only ES Module build (<code>vue.runtime.esm.js</code>).</p></li>
<li><p>ESM for browsers (2.6+ only): intended for direct imports in modern browsers via <code>&lt;script type=&quot;module&quot;&gt;</code>.</p></li>
</ul>
<h3 id="runtime-compiler-vs.-runtime-only">Runtime + Compiler vs. Runtime-only</h3>
<p>If you need to compile templates on the client (e.g. passing a string to the <code>template</code> option, or mounting to an element using its in-DOM HTML as the template), you will need the compiler and thus the full build:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// this requires the compiler</span>
<span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">template</span><span class="op">:</span> <span class="st">&#39;&lt;div&gt;{{ hi }}&lt;/div&gt;&#39;</span>
<span class="op">}</span>)

<span class="co">// this does not</span>
<span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="at">render</span> (h) <span class="op">{</span>
    <span class="cf">return</span> <span class="at">h</span>(<span class="st">&#39;div&#39;</span><span class="op">,</span> <span class="kw">this</span>.<span class="at">hi</span>)
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>When using <code>vue-loader</code> or <code>vueify</code>, templates inside <code>*.vue</code> files are pre-compiled into JavaScript at build time. You don't really need the compiler in the final bundle, and can therefore use the runtime-only build.</p>
<p>Since the runtime-only builds are roughly 30% lighter-weight than their full-build counterparts, you should use it whenever you can. If you still wish to use the full build instead, you need to configure an alias in your bundler:</p>
<h4 id="webpack">Webpack</h4>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">module</span>.<span class="at">exports</span> <span class="op">=</span> <span class="op">{</span>
  <span class="co">// ...</span>
  <span class="dt">resolve</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">alias</span><span class="op">:</span> <span class="op">{</span>
      <span class="st">&#39;vue$&#39;</span><span class="op">:</span> <span class="st">&#39;vue/dist/vue.esm.js&#39;</span> <span class="co">// &#39;vue/dist/vue.common.js&#39; for webpack 1</span>
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<h4 id="rollup">Rollup</h4>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">const</span> alias <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;rollup-plugin-alias&#39;</span>)

<span class="at">rollup</span>(<span class="op">{</span>
  <span class="co">// ...</span>
  <span class="dt">plugins</span><span class="op">:</span> [
    <span class="at">alias</span>(<span class="op">{</span>
      <span class="st">&#39;vue&#39;</span><span class="op">:</span> <span class="va">require</span>.<span class="at">resolve</span>(<span class="st">&#39;vue/dist/vue.esm.js&#39;</span>)
    <span class="op">}</span>)
  ]
<span class="op">}</span>)</code></pre></div>
<h4 id="browserify">Browserify</h4>
<p>Add to your project's <code>package.json</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="op">{</span>
  <span class="co">// ...</span>
  <span class="st">&quot;browser&quot;</span><span class="op">:</span> <span class="op">{</span>
    <span class="st">&quot;vue&quot;</span><span class="op">:</span> <span class="st">&quot;vue/dist/vue.common.js&quot;</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<h4 id="parcel">Parcel</h4>
<p>Add to your project's <code>package.json</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="op">{</span>
  <span class="co">// ...</span>
  <span class="st">&quot;alias&quot;</span><span class="op">:</span> <span class="op">{</span>
    <span class="st">&quot;vue&quot;</span> <span class="op">:</span> <span class="st">&quot;./node_modules/vue/dist/vue.common.js&quot;</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<h3 id="development-vs.-production-mode">Development vs. Production Mode</h3>
<p>Development/production modes are hard-coded for the UMD builds: the un-minified files are for development, and the minified files are for production.</p>
<p>CommonJS and ES Module builds are intended for bundlers, therefore we don't provide minified versions for them. You will be responsible for minifying the final bundle yourself.</p>
<p>CommonJS and ES Module builds also preserve raw checks for <code>process.env.NODE_ENV</code> to determine the mode they should run in. You should use appropriate bundler configurations to replace these environment variables in order to control which mode Vue will run in. Replacing <code>process.env.NODE_ENV</code> with string literals also allows minifiers like UglifyJS to completely drop the development-only code blocks, reducing final file size.</p>
<h4 id="webpack-1">Webpack</h4>
<p>In Webpack 4+, you can use the <code>mode</code> option:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">module</span>.<span class="at">exports</span> <span class="op">=</span> <span class="op">{</span>
  <span class="dt">mode</span><span class="op">:</span> <span class="st">&#39;production&#39;</span>
<span class="op">}</span></code></pre></div>
<p>But in Webpack 3 and earlier, you'll need to use <a href="https://webpack.js.org/plugins/define-plugin/">DefinePlugin</a>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> webpack <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;webpack&#39;</span>)

<span class="va">module</span>.<span class="at">exports</span> <span class="op">=</span> <span class="op">{</span>
  <span class="co">// ...</span>
  <span class="dt">plugins</span><span class="op">:</span> [
    <span class="co">// ...</span>
    <span class="kw">new</span> <span class="va">webpack</span>.<span class="at">DefinePlugin</span>(<span class="op">{</span>
      <span class="st">&#39;process.env&#39;</span><span class="op">:</span> <span class="op">{</span>
        <span class="dt">NODE_ENV</span><span class="op">:</span> <span class="va">JSON</span>.<span class="at">stringify</span>(<span class="st">&#39;production&#39;</span>)
      <span class="op">}</span>
    <span class="op">}</span>)
  ]
<span class="op">}</span></code></pre></div>
<h4 id="rollup-1">Rollup</h4>
<p>Use <a href="https://github.com/rollup/rollup-plugin-replace">rollup-plugin-replace</a>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">const</span> replace <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;rollup-plugin-replace&#39;</span>)

<span class="at">rollup</span>(<span class="op">{</span>
  <span class="co">// ...</span>
  <span class="dt">plugins</span><span class="op">:</span> [
    <span class="at">replace</span>(<span class="op">{</span>
      <span class="st">&#39;process.env.NODE_ENV&#39;</span><span class="op">:</span> <span class="va">JSON</span>.<span class="at">stringify</span>(<span class="st">&#39;production&#39;</span>)
    <span class="op">}</span>)
  ]
<span class="op">}</span>).<span class="at">then</span>(...)</code></pre></div>
<h4 id="browserify-1">Browserify</h4>
<p>Apply a global <a href="https://github.com/hughsk/envify">envify</a> transform to your bundle.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="va">NODE_ENV=</span>production <span class="ex">browserify</span> -g envify -e main.js <span class="kw">|</span> <span class="ex">uglifyjs</span> -c -m <span class="op">&gt;</span> build.js</code></pre></div>
<p>Also see <a href="deployment.html">Production Deployment Tips</a>.</p>
<h3 id="csp-environments">CSP environments</h3>
<p>Some environments, such as Google Chrome Apps, enforce Content Security Policy (CSP), which prohibits the use of <code>new Function()</code> for evaluating expressions. The full build depends on this feature to compile templates, so is unusable in these environments.</p>
<p>On the other hand, the runtime-only build is fully CSP-compliant. When using the runtime-only build with <a href="https://github.com/vuejs-templates/webpack-simple">Webpack + vue-loader</a> or <a href="https://github.com/vuejs-templates/browserify-simple">Browserify + vueify</a>, your templates will be precompiled into <code>render</code> functions which work perfectly in CSP environments.</p>
<h2 id="dev-build">Dev Build</h2>
<p><strong>Important</strong>: the built files in GitHub's <code>/dist</code> folder are only checked-in during releases. To use Vue from the latest source code on GitHub, you will have to build it yourself!</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> clone https://github.com/vuejs/vue.git node_modules/vue
<span class="bu">cd</span> node_modules/vue
<span class="ex">npm</span> install
<span class="ex">npm</span> run build</code></pre></div>
<h2 id="bower">Bower</h2>
<p>Only UMD builds are available from Bower.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># latest stable</span>
$ <span class="ex">bower</span> install vue</code></pre></div>
<h2 id="amd-module-loaders">AMD Module Loaders</h2>
<p>All UMD builds can be used directly as an AMD module.</p>
<h1 id="introduction"><a name=#guide/index.md></a>Introduction</h1>
<h2 id="what-is-vue.js">What is Vue.js?</h2>
<p>Vue (pronounced /vjuː/, like <strong>view</strong>) is a <strong>progressive framework</strong> for building user interfaces. Unlike other monolithic frameworks, Vue is designed from the ground up to be incrementally adoptable. The core library is focused on the view layer only, and is easy to pick up and integrate with other libraries or existing projects. On the other hand, Vue is also perfectly capable of powering sophisticated Single-Page Applications when used in combination with <a href="single-file-components.html">modern tooling</a> and <a href="https://github.com/vuejs/awesome-vue#components--libraries">supporting libraries</a>.</p>
<p>If you’d like to learn more about Vue before diving in, we <a id="modal-player"  href="#">created a video</a> walking through the core principles and a sample project.</p>
<p>If you are an experienced frontend developer and want to know how Vue compares to other libraries/frameworks, check out the <a href="comparison.html">Comparison with Other Frameworks</a>.</p>
<div class="vue-mastery">
<a href="https://www.vuemastery.com/courses/intro-to-vue-js/vue-instance/" target="_blank" rel="sponsored noopener" title="Free Vue.js Course">Watch a free video course on Vue Mastery</a>
</div>
<h2 id="getting-started">Getting Started</h2>
<p><a class="button" href="installation.html">Installation</a></p>
<p class="tip">
The official guide assumes intermediate level knowledge of HTML, CSS, and JavaScript. If you are totally new to frontend development, it might not be the best idea to jump right into a framework as your first step - grasp the basics then come back! Prior experience with other frameworks helps, but is not required.
</p>
<p>The easiest way to try out Vue.js is using the <a href="https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-hello-world">Hello World example</a>. Feel free to open it in another tab and follow along as we go through some basic examples. Or, you can <a href="https://github.com/vuejs/vuejs.org/blob/master/src/v2/examples/vue-20-hello-world/index.html" target="_blank" download="index.html" rel="noopener noreferrer">create an <code>index.html</code> file</a> and include Vue with:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- development version, includes helpful console warnings --&gt;</span>
<span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span><span class="kw">&gt;&lt;/script&gt;</span></code></pre></div>
<p>or:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- production version, optimized for size and speed --&gt;</span>
<span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;https://cdn.jsdelivr.net/npm/vue&quot;</span><span class="kw">&gt;&lt;/script&gt;</span></code></pre></div>
<p>The <a href="installation.html">Installation</a> page provides more options of installing Vue. Note: We <strong>do not</strong> recommend that beginners start with <code>vue-cli</code>, especially if you are not yet familiar with Node.js-based build tools.</p>
<p>If you prefer something more interactive, you can also check out <a href="https://scrimba.com/g/gvuedocs">this tutorial series on Scrimba</a>, which gives you a mix of screencast and code playground that you can pause and play around with anytime.</p>
<h2 id="declarative-rendering">Declarative Rendering</h2>
<div class="scrimba">
<a href="https://scrimba.com/p/pXKqta/cQ3QVcr" target="_blank" rel="noopener noreferrer">Try this lesson on Scrimba</a>
</div>
<p>At the core of Vue.js is a system that enables us to declaratively render data to the DOM using straightforward template syntax:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;app&quot;</span><span class="kw">&gt;</span>
  {{ message }}
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> app <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#app&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">message</span><span class="op">:</span> <span class="st">&#39;Hello Vue!&#39;</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>We have already created our very first Vue app! This looks pretty similar to rendering a string template, but Vue has done a lot of work under the hood. The data and the DOM are now linked, and everything is now <strong>reactive</strong>. How do we know? Open your browser's JavaScript console (right now, on this page) and set <code>app.message</code> to a different value. You should see the rendered example above update accordingly.</p>
<p>Note that we no longer have to interact with the HTML directly. A Vue app attaches itself to a single DOM element (<code>#app</code> in our case) then fully controls it. The HTML is our entry point, but everything else happens within the newly created Vue instance.</p>
<p>In addition to text interpolation, we can also bind element attributes like this:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;app-2&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;span</span><span class="ot"> v-bind:title=</span><span class="st">&quot;message&quot;</span><span class="kw">&gt;</span>
    Hover your mouse over me for a few seconds
    to see my dynamically bound title!
  <span class="kw">&lt;/span&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> app2 <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#app-2&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">message</span><span class="op">:</span> <span class="st">&#39;You loaded this page on &#39;</span> <span class="op">+</span> <span class="kw">new</span> <span class="at">Date</span>().<span class="at">toLocaleString</span>()
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>Here we are encountering something new. The <code>v-bind</code> attribute you are seeing is called a <strong>directive</strong>. Directives are prefixed with <code>v-</code> to indicate that they are special attributes provided by Vue, and as you may have guessed, they apply special reactive behavior to the rendered DOM. Here, it is basically saying &quot;keep this element's <code>title</code> attribute up-to-date with the <code>message</code> property on the Vue instance.&quot;</p>
<p>If you open up your JavaScript console again and enter <code>app2.message = 'some new message'</code>, you'll once again see that the bound HTML - in this case the <code>title</code> attribute - has been updated.</p>
<h2 id="conditionals-and-loops">Conditionals and Loops</h2>
<div class="scrimba">
<a href="https://scrimba.com/p/pXKqta/cEQe4SJ" target="_blank" rel="noopener noreferrer">Try this lesson on Scrimba</a>
</div>
<p>It's easy to toggle the presence of an element, too:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;app-3&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;span</span><span class="ot"> v-if=</span><span class="st">&quot;seen&quot;</span><span class="kw">&gt;</span>Now you see me<span class="kw">&lt;/span&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> app3 <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#app-3&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">seen</span><span class="op">:</span> <span class="kw">true</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>Go ahead and enter <code>app3.seen = false</code> in the console. You should see the message disappear.</p>
<p>This example demonstrates that we can bind data to not only text and attributes, but also the <strong>structure</strong> of the DOM. Moreover, Vue also provides a powerful transition effect system that can automatically apply <a href="transitions.html">transition effects</a> when elements are inserted/updated/removed by Vue.</p>
<p>There are quite a few other directives, each with its own special functionality. For example, the <code>v-for</code> directive can be used for displaying a list of items using the data from an Array:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;app-4&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;ol&gt;</span>
    <span class="kw">&lt;li</span><span class="ot"> v-for=</span><span class="st">&quot;todo in todos&quot;</span><span class="kw">&gt;</span>
      {{ todo.text }}
    <span class="kw">&lt;/li&gt;</span>
  <span class="kw">&lt;/ol&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> app4 <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#app-4&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">todos</span><span class="op">:</span> [
      <span class="op">{</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&#39;Learn JavaScript&#39;</span> <span class="op">},</span>
      <span class="op">{</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&#39;Learn Vue&#39;</span> <span class="op">},</span>
      <span class="op">{</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&#39;Build something awesome&#39;</span> <span class="op">}</span>
    ]
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>In the console, enter <code>app4.todos.push({ text: 'New item' })</code>. You should see a new item appended to the list.</p>
<h2 id="handling-user-input">Handling User Input</h2>
<div class="scrimba">
<a href="https://scrimba.com/p/pXKqta/czPNaUr" target="_blank" rel="noopener noreferrer">Try this lesson on Scrimba</a>
</div>
<p>To let users interact with your app, we can use the <code>v-on</code> directive to attach event listeners that invoke methods on our Vue instances:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;app-5&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;p&gt;</span>{{ message }}<span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;button</span><span class="ot"> v-on:click=</span><span class="st">&quot;reverseMessage&quot;</span><span class="kw">&gt;</span>Reverse Message<span class="kw">&lt;/button&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> app5 <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#app-5&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">message</span><span class="op">:</span> <span class="st">&#39;Hello Vue.js!&#39;</span>
  <span class="op">},</span>
  <span class="dt">methods</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">reverseMessage</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="kw">this</span>.<span class="at">message</span> <span class="op">=</span> <span class="kw">this</span>.<span class="va">message</span>.<span class="at">split</span>(<span class="st">&#39;&#39;</span>).<span class="at">reverse</span>().<span class="at">join</span>(<span class="st">&#39;&#39;</span>)
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>Note that in this method we update the state of our app without touching the DOM - all DOM manipulations are handled by Vue, and the code you write is focused on the underlying logic.</p>
<p>Vue also provides the <code>v-model</code> directive that makes two-way binding between form input and app state a breeze:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;app-6&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;p&gt;</span>{{ message }}<span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;input</span><span class="ot"> v-model=</span><span class="st">&quot;message&quot;</span><span class="kw">&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> app6 <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#app-6&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">message</span><span class="op">:</span> <span class="st">&#39;Hello Vue!&#39;</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<h2 id="composing-with-components">Composing with Components</h2>
<div class="scrimba">
<a href="https://scrimba.com/p/pXKqta/cEQVkA3" target="_blank" rel="noopener noreferrer">Try this lesson on Scrimba</a>
</div>
<p>The component system is another important concept in Vue, because it's an abstraction that allows us to build large-scale applications composed of small, self-contained, and often reusable components. If we think about it, almost any type of application interface can be abstracted into a tree of components:</p>
<div class="figure">
<img src="../images/components.png" alt="Component Tree" />
<p class="caption">Component Tree</p>
</div>
<p>In Vue, a component is essentially a Vue instance with pre-defined options. Registering a component in Vue is straightforward:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// Define a new component called todo-item</span>
<span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;todo-item&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">template</span><span class="op">:</span> <span class="st">&#39;&lt;li&gt;This is a todo&lt;/li&gt;&#39;</span>
<span class="op">}</span>)

<span class="kw">var</span> app <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(...)</code></pre></div>
<p>Now you can compose it in another component's template:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;ol&gt;</span>
  <span class="co">&lt;!-- Create an instance of the todo-item component --&gt;</span>
  <span class="kw">&lt;todo-item&gt;&lt;/todo-item&gt;</span>
<span class="kw">&lt;/ol&gt;</span></code></pre></div>
<p>But this would render the same text for every todo, which is not super interesting. We should be able to pass data from the parent scope into child components. Let's modify the component definition to make it accept a <a href="components.html#Props">prop</a>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;todo-item&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="co">// The todo-item component now accepts a</span>
  <span class="co">// &quot;prop&quot;, which is like a custom attribute.</span>
  <span class="co">// This prop is called todo.</span>
  <span class="dt">props</span><span class="op">:</span> [<span class="st">&#39;todo&#39;</span>]<span class="op">,</span>
  <span class="dt">template</span><span class="op">:</span> <span class="st">&#39;&lt;li&gt;{{ todo.text }}&lt;/li&gt;&#39;</span>
<span class="op">}</span>)</code></pre></div>
<p>Now we can pass the todo into each repeated component using <code>v-bind</code>:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;app-7&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;ol&gt;</span>
    <span class="co">&lt;!--</span>
<span class="co">      Now we provide each todo-item with the todo object</span>
<span class="co">      it&#39;s representing, so that its content can be dynamic.</span>
<span class="co">      We also need to provide each component with a &quot;key&quot;,</span>
<span class="co">      which will be explained later.</span>
<span class="co">    --&gt;</span>
    <span class="kw">&lt;todo-item</span>
<span class="ot">      v-for=</span><span class="st">&quot;item in groceryList&quot;</span>
<span class="ot">      v-bind:todo=</span><span class="st">&quot;item&quot;</span>
<span class="ot">      v-bind:key=</span><span class="st">&quot;item.id&quot;</span>
    <span class="kw">&gt;&lt;/todo-item&gt;</span>
  <span class="kw">&lt;/ol&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;todo-item&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">props</span><span class="op">:</span> [<span class="st">&#39;todo&#39;</span>]<span class="op">,</span>
  <span class="dt">template</span><span class="op">:</span> <span class="st">&#39;&lt;li&gt;{{ todo.text }}&lt;/li&gt;&#39;</span>
<span class="op">}</span>)

<span class="kw">var</span> app7 <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#app-7&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">groceryList</span><span class="op">:</span> [
      <span class="op">{</span> <span class="dt">id</span><span class="op">:</span> <span class="dv">0</span><span class="op">,</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&#39;Vegetables&#39;</span> <span class="op">},</span>
      <span class="op">{</span> <span class="dt">id</span><span class="op">:</span> <span class="dv">1</span><span class="op">,</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&#39;Cheese&#39;</span> <span class="op">},</span>
      <span class="op">{</span> <span class="dt">id</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&#39;Whatever else humans are supposed to eat&#39;</span> <span class="op">}</span>
    ]
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>This is a contrived example, but we have managed to separate our app into two smaller units, and the child is reasonably well-decoupled from the parent via the props interface. We can now further improve our <code>&lt;todo-item&gt;</code> component with more complex template and logic without affecting the parent app.</p>
<p>In a large application, it is necessary to divide the whole app into components to make development manageable. We will talk a lot more about components <a href="components.html">later in the guide</a>, but here's an (imaginary) example of what an app's template might look like with components:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;app&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;app-nav&gt;&lt;/app-nav&gt;</span>
  <span class="kw">&lt;app-view&gt;</span>
    <span class="kw">&lt;app-sidebar&gt;&lt;/app-sidebar&gt;</span>
    <span class="kw">&lt;app-content&gt;&lt;/app-content&gt;</span>
  <span class="kw">&lt;/app-view&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<h3 id="relation-to-custom-elements">Relation to Custom Elements</h3>
<p>You may have noticed that Vue components are very similar to <strong>Custom Elements</strong>, which are part of the <a href="https://www.w3.org/wiki/WebComponents/">Web Components Spec</a>. That's because Vue's component syntax is loosely modeled after the spec. For example, Vue components implement the <a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md">Slot API</a> and the <code>is</code> special attribute. However, there are a few key differences:</p>
<ol style="list-style-type: decimal">
<li><p>The Web Components Spec has been finalized, but is not natively implemented in every browser. Safari 10.1+, Chrome 54+ and Firefox 63+ natively support web components. In comparison, Vue components don't require any polyfills and work consistently in all supported browsers (IE9 and above). When needed, Vue components can also be wrapped inside a native custom element.</p></li>
<li><p>Vue components provide important features that are not available in plain custom elements, most notably cross-component data flow, custom event communication and build tool integrations.</p></li>
</ol>
<p>Although Vue doesn't use custom elements internally, it has <a href="https://custom-elements-everywhere.com/#vue">great interoperability</a> when it comes to consuming or distributing as custom elements. Vue CLI also supports building Vue components that register themselves as native custom elements.</p>
<h2 id="ready-for-more">Ready for More?</h2>
<p>We've briefly introduced the most basic features of Vue.js core - the rest of this guide will cover them and other advanced features with much finer details, so make sure to read through it all!</p>
<div id="video-modal" class="modal">
<div class="video-space" style="padding: 56.25% 0 0 0; position: relative;">
<iframe src="https://player.vimeo.com/video/247494684?dnt=1" style="height: 100%; left: 0; position: absolute; top: 0; width: 100%; margin: 0" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen>
</iframe>
</div>
<script src="https://player.vimeo.com/api/player.js"></script>
<p class="modal-text">
Video by <a href="https://www.vuemastery.com" target="_blank" rel="sponsored noopener" title="Vue.js Courses on Vue Mastery">Vue Mastery</a>. Watch Vue Mastery’s free <a href="https://www.vuemastery.com/courses/intro-to-vue-js/vue-instance/" target="_blank" rel="sponsored noopener" title="Vue.js Courses on Vue Mastery">Intro to Vue course</a>.
</div>
<h1 id="the-vue-instance"><a name=#guide/instance.md></a>The Vue Instance</h1>
<h2 id="creating-a-vue-instance">Creating a Vue Instance</h2>
<p>Every Vue application starts by creating a new <strong>Vue instance</strong> with the <code>Vue</code> function:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> vm <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="co">// options</span>
<span class="op">}</span>)</code></pre></div>
<p>Although not strictly associated with the <a href="https://en.wikipedia.org/wiki/Model_View_ViewModel">MVVM pattern</a>, Vue's design was partly inspired by it. As a convention, we often use the variable <code>vm</code> (short for ViewModel) to refer to our Vue instance.</p>
<p>When you create a Vue instance, you pass in an <strong>options object</strong>. The majority of this guide describes how you can use these options to create your desired behavior. For reference, you can also browse the full list of options in the <a href="../api/#Options-Data">API reference</a>.</p>
<p>A Vue application consists of a <strong>root Vue instance</strong> created with <code>new Vue</code>, optionally organized into a tree of nested, reusable components. For example, a todo app's component tree might look like this:</p>
<pre><code>Root Instance
└─ TodoList
   ├─ TodoItem
   │  ├─ DeleteTodoButton
   │  └─ EditTodoButton
   └─ TodoListFooter
      ├─ ClearTodosButton
      └─ TodoListStatistics</code></pre>
<p>We'll talk about <a href="components.html">the component system</a> in detail later. For now, just know that all Vue components are also Vue instances, and so accept the same options object (except for a few root-specific options).</p>
<h2 id="data-and-methods">Data and Methods</h2>
<p>When a Vue instance is created, it adds all the properties found in its <code>data</code> object to Vue's <strong>reactivity system</strong>. When the values of those properties change, the view will &quot;react&quot;, updating to match the new values.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// Our data object</span>
<span class="kw">var</span> data <span class="op">=</span> <span class="op">{</span> <span class="dt">a</span><span class="op">:</span> <span class="dv">1</span> <span class="op">}</span>

<span class="co">// The object is added to a Vue instance</span>
<span class="kw">var</span> vm <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">data</span><span class="op">:</span> data
<span class="op">}</span>)

<span class="co">// Getting the property on the instance</span>
<span class="co">// returns the one from the original data</span>
<span class="va">vm</span>.<span class="at">a</span> <span class="op">==</span> <span class="va">data</span>.<span class="at">a</span> <span class="co">// =&gt; true</span>

<span class="co">// Setting the property on the instance</span>
<span class="co">// also affects the original data</span>
<span class="va">vm</span>.<span class="at">a</span> <span class="op">=</span> <span class="dv">2</span>
<span class="va">data</span>.<span class="at">a</span> <span class="co">// =&gt; 2</span>

<span class="co">// ... and vice-versa</span>
<span class="va">data</span>.<span class="at">a</span> <span class="op">=</span> <span class="dv">3</span>
<span class="va">vm</span>.<span class="at">a</span> <span class="co">// =&gt; 3</span></code></pre></div>
<p>When this data changes, the view will re-render. It should be noted that properties in <code>data</code> are only <strong>reactive</strong> if they existed when the instance was created. That means if you add a new property, like:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">vm</span>.<span class="at">b</span> <span class="op">=</span> <span class="st">&#39;hi&#39;</span></code></pre></div>
<p>Then changes to <code>b</code> will not trigger any view updates. If you know you'll need a property later, but it starts out empty or non-existent, you'll need to set some initial value. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">data<span class="op">:</span> <span class="op">{</span>
  <span class="dt">newTodoText</span><span class="op">:</span> <span class="st">&#39;&#39;</span><span class="op">,</span>
  <span class="dt">visitCount</span><span class="op">:</span> <span class="dv">0</span><span class="op">,</span>
  <span class="dt">hideCompletedTodos</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span>
  <span class="dt">todos</span><span class="op">:</span> []<span class="op">,</span>
  <span class="dt">error</span><span class="op">:</span> <span class="kw">null</span>
<span class="op">}</span></code></pre></div>
<p>The only exception to this being the use of <code>Object.freeze()</code>, which prevents existing properties from being changed, which also means the reactivity system can't <em>track</em> changes.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> obj <span class="op">=</span> <span class="op">{</span>
  <span class="dt">foo</span><span class="op">:</span> <span class="st">&#39;bar&#39;</span>
<span class="op">}</span>

<span class="va">Object</span>.<span class="at">freeze</span>(obj)

<span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#app&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> obj
<span class="op">}</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;app&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;p&gt;</span>{{ foo }}<span class="kw">&lt;/p&gt;</span>
  <span class="co">&lt;!-- this will no longer update `foo`! --&gt;</span>
  <span class="kw">&lt;button</span><span class="ot"> v-on:click=</span><span class="st">&quot;foo = &#39;baz&#39;&quot;</span><span class="kw">&gt;</span>Change it<span class="kw">&lt;/button&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<p>In addition to data properties, Vue instances expose a number of useful instance properties and methods. These are prefixed with <code>$</code> to differentiate them from user-defined properties. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> data <span class="op">=</span> <span class="op">{</span> <span class="dt">a</span><span class="op">:</span> <span class="dv">1</span> <span class="op">}</span>
<span class="kw">var</span> vm <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#example&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> data
<span class="op">}</span>)

<span class="va">vm</span>.<span class="at">$data</span> <span class="op">===</span> data <span class="co">// =&gt; true</span>
<span class="va">vm</span>.<span class="at">$el</span> <span class="op">===</span> <span class="va">document</span>.<span class="at">getElementById</span>(<span class="st">&#39;example&#39;</span>) <span class="co">// =&gt; true</span>

<span class="co">// $watch is an instance method</span>
<span class="va">vm</span>.<span class="at">$watch</span>(<span class="st">&#39;a&#39;</span><span class="op">,</span> <span class="kw">function</span> (newValue<span class="op">,</span> oldValue) <span class="op">{</span>
  <span class="co">// This callback will be called when `vm.a` changes</span>
<span class="op">}</span>)</code></pre></div>
<p>In the future, you can consult the <a href="../api/#Instance-Properties">API reference</a> for a full list of instance properties and methods.</p>
<h2 id="instance-lifecycle-hooks">Instance Lifecycle Hooks</h2>
<div class="vueschool">
<a href="https://vueschool.io/lessons/understanding-the-vuejs-lifecycle-hooks?friend=vuejs" target="_blank" rel="sponsored noopener" title="Free Vue.js Lifecycle Hooks Lesson">Watch a free lesson on Vue School</a>
</div>
<p>Each Vue instance goes through a series of initialization steps when it's created - for example, it needs to set up data observation, compile the template, mount the instance to the DOM, and update the DOM when data changes. Along the way, it also runs functions called <strong>lifecycle hooks</strong>, giving users the opportunity to add their own code at specific stages.</p>
<p>For example, the <a href="../api/#created"><code>created</code></a> hook can be used to run code after an instance is created:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">1</span>
  <span class="op">},</span>
  <span class="dt">created</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="co">// `this` points to the vm instance</span>
    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;a is: &#39;</span> <span class="op">+</span> <span class="kw">this</span>.<span class="at">a</span>)
  <span class="op">}</span>
<span class="op">}</span>)
<span class="co">// =&gt; &quot;a is: 1&quot;</span></code></pre></div>
<p>There are also other hooks which will be called at different stages of the instance's lifecycle, such as <a href="../api/#mounted"><code>mounted</code></a>, <a href="../api/#updated"><code>updated</code></a>, and <a href="../api/#destroyed"><code>destroyed</code></a>. All lifecycle hooks are called with their <code>this</code> context pointing to the Vue instance invoking it.</p>
<p class="tip">
Don't use <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions">arrow functions</a> on an options property or callback, such as <code>created: () =&gt; console.log(this.a)</code> or <code>vm.$watch('a', newValue =&gt; this.myMethod())</code>. Since an arrow function doesn't have a <code>this</code>, <code>this</code> will be treated as any other variable and lexically looked up through parent scopes until found, often resulting in errors such as <code>Uncaught TypeError: Cannot read property of undefined</code> or <code>Uncaught TypeError: this.myMethod is not a function</code>.
</p>
<h2 id="lifecycle-diagram">Lifecycle Diagram</h2>
<p>Below is a diagram for the instance lifecycle. You don't need to fully understand everything going on right now, but as you learn and build more, it will be a useful reference.</p>
<div class="figure">
<img src="../images/lifecycle.png" alt="The Vue Instance Lifecycle" />
<p class="caption">The Vue Instance Lifecycle</p>
</div>
<h1 id="template-syntax"><a name=#guide/syntax.md></a>Template Syntax</h1>
<p>Vue.js uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying Vue instance's data. All Vue.js templates are valid HTML that can be parsed by spec-compliant browsers and HTML parsers.</p>
<p>Under the hood, Vue compiles the templates into Virtual DOM render functions. Combined with the reactivity system, Vue is able to intelligently figure out the minimal number of components to re-render and apply the minimal amount of DOM manipulations when the app state changes.</p>
<p>If you are familiar with Virtual DOM concepts and prefer the raw power of JavaScript, you can also <a href="render-function.html">directly write render functions</a> instead of templates, with optional JSX support.</p>
<h2 id="interpolations">Interpolations</h2>
<h3 id="text">Text</h3>
<p>The most basic form of data binding is text interpolation using the &quot;Mustache&quot; syntax (double curly braces):</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;span&gt;</span>Message: {{ msg }}<span class="kw">&lt;/span&gt;</span></code></pre></div>
<p>The mustache tag will be replaced with the value of the <code>msg</code> property on the corresponding data object. It will also be updated whenever the data object's <code>msg</code> property changes.</p>
<p>You can also perform one-time interpolations that do not update on data change by using the <a href="../api/#v-once">v-once directive</a>, but keep in mind this will also affect any other bindings on the same node:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;span</span><span class="ot"> v-once</span><span class="kw">&gt;</span>This will never change: {{ msg }}<span class="kw">&lt;/span&gt;</span></code></pre></div>
<h3 id="raw-html">Raw HTML</h3>
<p>The double mustaches interprets the data as plain text, not HTML. In order to output real HTML, you will need to use the <a href="../api/#v-html"><code>v-html</code> directive</a>:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;p&gt;</span>Using mustaches: {{ rawHtml }}<span class="kw">&lt;/p&gt;</span>
<span class="kw">&lt;p&gt;</span>Using v-html directive: <span class="kw">&lt;span</span><span class="ot"> v-html=</span><span class="st">&quot;rawHtml&quot;</span><span class="kw">&gt;&lt;/span&gt;&lt;/p&gt;</span></code></pre></div>
<p>The contents of the <code>span</code> will be replaced with the value of the <code>rawHtml</code> property, interpreted as plain HTML - data bindings are ignored. Note that you cannot use <code>v-html</code> to compose template partials, because Vue is not a string-based templating engine. Instead, components are preferred as the fundamental unit for UI reuse and composition.</p>
<p class="tip">
Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS vulnerabilities</a>. Only use HTML interpolation on trusted content and <strong>never</strong> on user-provided content.
</p>
<h3 id="attributes">Attributes</h3>
<p>Mustaches cannot be used inside HTML attributes. Instead, use a <a href="../api/#v-bind"><code>v-bind</code> directive</a>:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> v-bind:id=</span><span class="st">&quot;dynamicId&quot;</span><span class="kw">&gt;&lt;/div&gt;</span></code></pre></div>
<p>In the case of boolean attributes, where their mere existence implies <code>true</code>, <code>v-bind</code> works a little differently. In this example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;button</span><span class="ot"> v-bind:disabled=</span><span class="st">&quot;isButtonDisabled&quot;</span><span class="kw">&gt;</span>Button<span class="kw">&lt;/button&gt;</span></code></pre></div>
<p>If <code>isButtonDisabled</code> has the value of <code>null</code>, <code>undefined</code>, or <code>false</code>, the <code>disabled</code> attribute will not even be included in the rendered <code>&lt;button&gt;</code> element.</p>
<h3 id="using-javascript-expressions">Using JavaScript Expressions</h3>
<p>So far we've only been binding to simple property keys in our templates. But Vue.js actually supports the full power of JavaScript expressions inside all data bindings:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">{{ number + 1 }}

{{ ok ? &#39;YES&#39; : &#39;NO&#39; }}

{{ message.split(&#39;&#39;).reverse().join(&#39;&#39;) }}

<span class="kw">&lt;div</span><span class="ot"> v-bind:id=</span><span class="st">&quot;&#39;list-&#39; + id&quot;</span><span class="kw">&gt;&lt;/div&gt;</span></code></pre></div>
<p>These expressions will be evaluated as JavaScript in the data scope of the owner Vue instance. One restriction is that each binding can only contain <strong>one single expression</strong>, so the following will <strong>NOT</strong> work:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- this is a statement, not an expression: --&gt;</span>
{{ var a = 1 }}

<span class="co">&lt;!-- flow control won&#39;t work either, use ternary expressions --&gt;</span>
{{ if (ok) { return message } }}</code></pre></div>
<p class="tip">
Template expressions are sandboxed and only have access to a <a href="https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9">whitelist of globals</a> such as <code>Math</code> and <code>Date</code>. You should not attempt to access user defined globals in template expressions.
</p>
<h2 id="directives">Directives</h2>
<p>Directives are special attributes with the <code>v-</code> prefix. Directive attribute values are expected to be <strong>a single JavaScript expression</strong> (with the exception of <code>v-for</code>, which will be discussed later). A directive's job is to reactively apply side effects to the DOM when the value of its expression changes. Let's review the example we saw in the introduction:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;p</span><span class="ot"> v-if=</span><span class="st">&quot;seen&quot;</span><span class="kw">&gt;</span>Now you see me<span class="kw">&lt;/p&gt;</span></code></pre></div>
<p>Here, the <code>v-if</code> directive would remove/insert the <code>&lt;p&gt;</code> element based on the truthiness of the value of the expression <code>seen</code>.</p>
<h3 id="arguments">Arguments</h3>
<p>Some directives can take an &quot;argument&quot;, denoted by a colon after the directive name. For example, the <code>v-bind</code> directive is used to reactively update an HTML attribute:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;a</span><span class="ot"> v-bind:href=</span><span class="st">&quot;url&quot;</span><span class="kw">&gt;</span> ... <span class="kw">&lt;/a&gt;</span></code></pre></div>
<p>Here <code>href</code> is the argument, which tells the <code>v-bind</code> directive to bind the element's <code>href</code> attribute to the value of the expression <code>url</code>.</p>
<p>Another example is the <code>v-on</code> directive, which listens to DOM events:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;a</span><span class="ot"> v-on:click=</span><span class="st">&quot;doSomething&quot;</span><span class="kw">&gt;</span> ... <span class="kw">&lt;/a&gt;</span></code></pre></div>
<p>Here the argument is the event name to listen to. We will talk about event handling in more detail too.</p>
<h3 id="dynamic-arguments">Dynamic Arguments</h3>
<blockquote>
<p>New in 2.6.0+</p>
</blockquote>
<p>Starting in version 2.6.0, it is also possible to use a JavaScript expression in a directive argument by wrapping it with square brackets:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!--</span>
<span class="co">Note that there are some constraints to the argument expression, as explained</span>
<span class="co">in the &quot;Dynamic Argument Expression Constraints&quot; section below.</span>
<span class="co">--&gt;</span>
<span class="kw">&lt;a</span><span class="ot"> v-bind:</span><span class="er">[attributeName]</span><span class="ot">=</span><span class="st">&quot;url&quot;</span><span class="kw">&gt;</span> ... <span class="kw">&lt;/a&gt;</span></code></pre></div>
<p>Here <code>attributeName</code> will be dynamically evaluated as a JavaScript expression, and its evaluated value will be used as the final value for the argument. For example, if your Vue instance has a data property, <code>attributeName</code>, whose value is <code>&quot;href&quot;</code>, then this binding will be equivalent to <code>v-bind:href</code>.</p>
<p>Similarly, you can use dynamic arguments to bind a handler to a dynamic event name:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;a</span><span class="ot"> v-on:</span><span class="er">[eventName]</span><span class="ot">=</span><span class="st">&quot;doSomething&quot;</span><span class="kw">&gt;</span> ... <span class="kw">&lt;/a&gt;</span></code></pre></div>
<p>In this example, when <code>eventName</code>'s value is <code>&quot;focus&quot;</code>, <code>v-on:[eventName]</code> will be equivalent to <code>v-on:focus</code>.</p>
<h4 id="dynamic-argument-value-constraints">Dynamic Argument Value Constraints</h4>
<p>Dynamic arguments are expected to evaluate to a string, with the exception of <code>null</code>. The special value <code>null</code> can be used to explicitly remove the binding. Any other non-string value will trigger a warning.</p>
<h4 id="dynamic-argument-expression-constraints">Dynamic Argument Expression Constraints</h4>
<p>Dynamic argument expressions have some syntax constraints because certain characters, such as spaces and quotes, are invalid inside HTML attribute names. For example, the following is invalid:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- This will trigger a compiler warning. --&gt;</span>
<span class="kw">&lt;a</span><span class="ot"> v-bind:</span><span class="er">[&#39;foo&#39;</span> <span class="er">+</span><span class="ot"> bar]=</span><span class="st">&quot;value&quot;</span><span class="kw">&gt;</span> ... <span class="kw">&lt;/a&gt;</span></code></pre></div>
<p>The workaround is to either use expressions without spaces or quotes, or replace the complex expression with a computed property.</p>
<p>When using in-DOM templates (templates directly written in an HTML file), you should also avoid naming keys with uppercase characters, as browsers will coerce attribute names into lowercase:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!--</span>
<span class="co">This will be converted to v-bind:[someattr] in in-DOM templates.</span>
<span class="co">Unless you have a &quot;someattr&quot; property in your instance, your code won&#39;t work.</span>
<span class="co">--&gt;</span>
<span class="kw">&lt;a</span><span class="ot"> v-bind:</span><span class="er">[someAttr]</span><span class="ot">=</span><span class="st">&quot;value&quot;</span><span class="kw">&gt;</span> ... <span class="kw">&lt;/a&gt;</span></code></pre></div>
<h3 id="modifiers">Modifiers</h3>
<p>Modifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the <code>.prevent</code> modifier tells the <code>v-on</code> directive to call <code>event.preventDefault()</code> on the triggered event:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;form</span><span class="ot"> v-on:submit.prevent=</span><span class="st">&quot;onSubmit&quot;</span><span class="kw">&gt;</span> ... <span class="kw">&lt;/form&gt;</span></code></pre></div>
<p>You'll see other examples of modifiers later, <a href="events.html#Event-Modifiers">for <code>v-on</code></a> and <a href="forms.html#Modifiers">for <code>v-model</code></a>, when we explore those features.</p>
<h2 id="shorthands">Shorthands</h2>
<p>The <code>v-</code> prefix serves as a visual cue for identifying Vue-specific attributes in your templates. This is useful when you are using Vue.js to apply dynamic behavior to some existing markup, but can feel verbose for some frequently used directives. At the same time, the need for the <code>v-</code> prefix becomes less important when you are building a <a href="https://en.wikipedia.org/wiki/Single-page_application">SPA</a>, where Vue manages every template. Therefore, Vue provides special shorthands for two of the most often used directives, <code>v-bind</code> and <code>v-on</code>:</p>
<h3 id="v-bind-shorthand"><code>v-bind</code> Shorthand</h3>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- full syntax --&gt;</span>
<span class="kw">&lt;a</span><span class="ot"> v-bind:href=</span><span class="st">&quot;url&quot;</span><span class="kw">&gt;</span> ... <span class="kw">&lt;/a&gt;</span>

<span class="co">&lt;!-- shorthand --&gt;</span>
<span class="kw">&lt;a</span><span class="ot"> :href=</span><span class="st">&quot;url&quot;</span><span class="kw">&gt;</span> ... <span class="kw">&lt;/a&gt;</span>

<span class="co">&lt;!-- shorthand with dynamic argument (2.6.0+) --&gt;</span>
<span class="kw">&lt;a</span><span class="ot"> :</span><span class="er">[key]</span><span class="ot">=</span><span class="st">&quot;url&quot;</span><span class="kw">&gt;</span> ... <span class="kw">&lt;/a&gt;</span></code></pre></div>
<h3 id="v-on-shorthand"><code>v-on</code> Shorthand</h3>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- full syntax --&gt;</span>
<span class="kw">&lt;a</span><span class="ot"> v-on:click=</span><span class="st">&quot;doSomething&quot;</span><span class="kw">&gt;</span> ... <span class="kw">&lt;/a&gt;</span>

<span class="co">&lt;!-- shorthand --&gt;</span>
<span class="kw">&lt;a</span> <span class="er">@click</span><span class="ot">=</span><span class="st">&quot;doSomething&quot;</span><span class="kw">&gt;</span> ... <span class="kw">&lt;/a&gt;</span>

<span class="co">&lt;!-- shorthand with dynamic argument (2.6.0+) --&gt;</span>
<span class="kw">&lt;a</span> <span class="er">@[event]</span><span class="ot">=</span><span class="st">&quot;doSomething&quot;</span><span class="kw">&gt;</span> ... <span class="kw">&lt;/a&gt;</span></code></pre></div>
<p>They may look a bit different from normal HTML, but <code>:</code> and <code>@</code> are valid characters for attribute names and all Vue-supported browsers can parse it correctly. In addition, they do not appear in the final rendered markup. The shorthand syntax is totally optional, but you will likely appreciate it when you learn more about its usage later.</p>
<h1 id="computed-properties-and-watchers"><a name=#guide/computed.md></a>Computed Properties and Watchers</h1>
<h2 id="computed-properties">Computed Properties</h2>
<div class="vueschool">
<a href="https://vueschool.io/lessons/vuejs-computed-properties?friend=vuejs" target="_blank" rel="sponsored noopener" title="Learn how computed properties work with Vue School">Learn how computed properties work with a free lesson on Vue School</a>
</div>
<p>In-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;example&quot;</span><span class="kw">&gt;</span>
  {{ message.split(&#39;&#39;).reverse().join(&#39;&#39;) }}
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<p>At this point, the template is no longer simple and declarative. You have to look at it for a second before realizing that it displays <code>message</code> in reverse. The problem is made worse when you want to include the reversed message in your template more than once.</p>
<p>That's why for any complex logic, you should use a <strong>computed property</strong>.</p>
<h3 id="basic-example">Basic Example</h3>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;example&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;p&gt;</span>Original message: &quot;{{ message }}&quot;<span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;p&gt;</span>Computed reversed message: &quot;{{ reversedMessage }}&quot;<span class="kw">&lt;/p&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> vm <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#example&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">message</span><span class="op">:</span> <span class="st">&#39;Hello&#39;</span>
  <span class="op">},</span>
  <span class="dt">computed</span><span class="op">:</span> <span class="op">{</span>
    <span class="co">// a computed getter</span>
    <span class="dt">reversedMessage</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="co">// `this` points to the vm instance</span>
      <span class="cf">return</span> <span class="kw">this</span>.<span class="va">message</span>.<span class="at">split</span>(<span class="st">&#39;&#39;</span>).<span class="at">reverse</span>().<span class="at">join</span>(<span class="st">&#39;&#39;</span>)
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>Result:</p>
<p>Here we have declared a computed property <code>reversedMessage</code>. The function we provided will be used as the getter function for the property <code>vm.reversedMessage</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">console</span>.<span class="at">log</span>(<span class="va">vm</span>.<span class="at">reversedMessage</span>) <span class="co">// =&gt; &#39;olleH&#39;</span>
<span class="va">vm</span>.<span class="at">message</span> <span class="op">=</span> <span class="st">&#39;Goodbye&#39;</span>
<span class="va">console</span>.<span class="at">log</span>(<span class="va">vm</span>.<span class="at">reversedMessage</span>) <span class="co">// =&gt; &#39;eybdooG&#39;</span></code></pre></div>
<p>You can open the console and play with the example vm yourself. The value of <code>vm.reversedMessage</code> is always dependent on the value of <code>vm.message</code>.</p>
<p>You can data-bind to computed properties in templates just like a normal property. Vue is aware that <code>vm.reversedMessage</code> depends on <code>vm.message</code>, so it will update any bindings that depend on <code>vm.reversedMessage</code> when <code>vm.message</code> changes. And the best part is that we've created this dependency relationship declaratively: the computed getter function has no side effects, which makes it easier to test and understand.</p>
<h3 id="computed-caching-vs-methods">Computed Caching vs Methods</h3>
<p>You may have noticed we can achieve the same result by invoking a method in the expression:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;p&gt;</span>Reversed message: &quot;{{ reverseMessage() }}&quot;<span class="kw">&lt;/p&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// in component</span>
methods<span class="op">:</span> <span class="op">{</span>
  <span class="dt">reverseMessage</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="cf">return</span> <span class="kw">this</span>.<span class="va">message</span>.<span class="at">split</span>(<span class="st">&#39;&#39;</span>).<span class="at">reverse</span>().<span class="at">join</span>(<span class="st">&#39;&#39;</span>)
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>Instead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that <strong>computed properties are cached based on their reactive dependencies.</strong> A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as <code>message</code> has not changed, multiple access to the <code>reversedMessage</code> computed property will immediately return the previously computed result without having to run the function again.</p>
<p>This also means the following computed property will never update, because <code>Date.now()</code> is not a reactive dependency:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">computed<span class="op">:</span> <span class="op">{</span>
  <span class="dt">now</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="cf">return</span> <span class="va">Date</span>.<span class="at">now</span>()
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>In comparison, a method invocation will <strong>always</strong> run the function whenever a re-render happens.</p>
<p>Why do we need caching? Imagine we have an expensive computed property <strong>A</strong>, which requires looping through a huge Array and doing a lot of computations. Then we may have other computed properties that in turn depend on <strong>A</strong>. Without caching, we would be executing <strong>A</strong>’s getter many more times than necessary! In cases where you do not want caching, use a method instead.</p>
<h3 id="computed-vs-watched-property">Computed vs Watched Property</h3>
<p>Vue does provide a more generic way to observe and react to data changes on a Vue instance: <strong>watch properties</strong>. When you have some data that needs to change based on some other data, it is tempting to overuse <code>watch</code> - especially if you are coming from an AngularJS background. However, it is often a better idea to use a computed property rather than an imperative <code>watch</code> callback. Consider this example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;demo&quot;</span><span class="kw">&gt;</span>{{ fullName }}<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> vm <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#demo&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">firstName</span><span class="op">:</span> <span class="st">&#39;Foo&#39;</span><span class="op">,</span>
    <span class="dt">lastName</span><span class="op">:</span> <span class="st">&#39;Bar&#39;</span><span class="op">,</span>
    <span class="dt">fullName</span><span class="op">:</span> <span class="st">&#39;Foo Bar&#39;</span>
  <span class="op">},</span>
  <span class="dt">watch</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">firstName</span><span class="op">:</span> <span class="kw">function</span> (val) <span class="op">{</span>
      <span class="kw">this</span>.<span class="at">fullName</span> <span class="op">=</span> val <span class="op">+</span> <span class="st">&#39; &#39;</span> <span class="op">+</span> <span class="kw">this</span>.<span class="at">lastName</span>
    <span class="op">},</span>
    <span class="dt">lastName</span><span class="op">:</span> <span class="kw">function</span> (val) <span class="op">{</span>
      <span class="kw">this</span>.<span class="at">fullName</span> <span class="op">=</span> <span class="kw">this</span>.<span class="at">firstName</span> <span class="op">+</span> <span class="st">&#39; &#39;</span> <span class="op">+</span> val
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>The above code is imperative and repetitive. Compare it with a computed property version:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> vm <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#demo&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">firstName</span><span class="op">:</span> <span class="st">&#39;Foo&#39;</span><span class="op">,</span>
    <span class="dt">lastName</span><span class="op">:</span> <span class="st">&#39;Bar&#39;</span>
  <span class="op">},</span>
  <span class="dt">computed</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">fullName</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="cf">return</span> <span class="kw">this</span>.<span class="at">firstName</span> <span class="op">+</span> <span class="st">&#39; &#39;</span> <span class="op">+</span> <span class="kw">this</span>.<span class="at">lastName</span>
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>Much better, isn't it?</p>
<h3 id="computed-setter">Computed Setter</h3>
<p>Computed properties are by default getter-only, but you can also provide a setter when you need it:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// ...</span>
computed<span class="op">:</span> <span class="op">{</span>
  <span class="dt">fullName</span><span class="op">:</span> <span class="op">{</span>
    <span class="co">// getter</span>
    <span class="dt">get</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="cf">return</span> <span class="kw">this</span>.<span class="at">firstName</span> <span class="op">+</span> <span class="st">&#39; &#39;</span> <span class="op">+</span> <span class="kw">this</span>.<span class="at">lastName</span>
    <span class="op">},</span>
    <span class="co">// setter</span>
    <span class="dt">set</span><span class="op">:</span> <span class="kw">function</span> (newValue) <span class="op">{</span>
      <span class="kw">var</span> names <span class="op">=</span> <span class="va">newValue</span>.<span class="at">split</span>(<span class="st">&#39; &#39;</span>)
      <span class="kw">this</span>.<span class="at">firstName</span> <span class="op">=</span> names[<span class="dv">0</span>]
      <span class="kw">this</span>.<span class="at">lastName</span> <span class="op">=</span> names[<span class="va">names</span>.<span class="at">length</span> <span class="op">-</span> <span class="dv">1</span>]
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>
<span class="co">// ...</span></code></pre></div>
<p>Now when you run <code>vm.fullName = 'John Doe'</code>, the setter will be invoked and <code>vm.firstName</code> and <code>vm.lastName</code> will be updated accordingly.</p>
<h2 id="watchers">Watchers</h2>
<p>While computed properties are more appropriate in most cases, there are times when a custom watcher is necessary. That's why Vue provides a more generic way to react to data changes through the <code>watch</code> option. This is most useful when you want to perform asynchronous or expensive operations in response to changing data.</p>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;watch-example&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;p&gt;</span>
    Ask a yes/no question:
    <span class="kw">&lt;input</span><span class="ot"> v-model=</span><span class="st">&quot;question&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;p&gt;</span>{{ answer }}<span class="kw">&lt;/p&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- Since there is already a rich ecosystem of ajax libraries    --&gt;</span>
<span class="co">&lt;!-- and collections of general-purpose utility methods, Vue core --&gt;</span>
<span class="co">&lt;!-- is able to remain small by not reinventing them. This also   --&gt;</span>
<span class="co">&lt;!-- gives you the freedom to use what you&#39;re familiar with.      --&gt;</span>
<span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js&quot;</span><span class="kw">&gt;&lt;/script&gt;</span>
<span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js&quot;</span><span class="kw">&gt;&lt;/script&gt;</span>
<span class="kw">&lt;script&gt;</span>
<span class="kw">var</span> watchExampleVM <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#watch-example&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">question</span><span class="op">:</span> <span class="st">&#39;&#39;</span><span class="op">,</span>
    <span class="dt">answer</span><span class="op">:</span> <span class="st">&#39;I cannot give you an answer until you ask a question!&#39;</span>
  <span class="op">},</span>
  <span class="dt">watch</span><span class="op">:</span> <span class="op">{</span>
    <span class="co">// whenever question changes, this function will run</span>
    <span class="dt">question</span><span class="op">:</span> <span class="kw">function</span> (newQuestion<span class="op">,</span> oldQuestion) <span class="op">{</span>
      <span class="kw">this</span>.<span class="at">answer</span> <span class="op">=</span> <span class="st">&#39;Waiting for you to stop typing...&#39;</span>
      <span class="kw">this</span>.<span class="at">debouncedGetAnswer</span>()
    <span class="op">}</span>
  <span class="op">},</span>
  <span class="dt">created</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="co">// _.debounce is a function provided by lodash to limit how</span>
    <span class="co">// often a particularly expensive operation can be run.</span>
    <span class="co">// In this case, we want to limit how often we access</span>
    <span class="co">// yesno.wtf/api, waiting until the user has completely</span>
    <span class="co">// finished typing before making the ajax request. To learn</span>
    <span class="co">// more about the _.debounce function (and its cousin</span>
    <span class="co">// _.throttle), visit: https://lodash.com/docs#debounce</span>
    <span class="kw">this</span>.<span class="at">debouncedGetAnswer</span> <span class="op">=</span> <span class="va">_</span>.<span class="at">debounce</span>(<span class="kw">this</span>.<span class="at">getAnswer</span><span class="op">,</span> <span class="dv">500</span>)
  <span class="op">},</span>
  <span class="dt">methods</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">getAnswer</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="cf">if</span> (<span class="kw">this</span>.<span class="va">question</span>.<span class="at">indexOf</span>(<span class="st">&#39;?&#39;</span>) <span class="op">===</span> <span class="dv">-1</span>) <span class="op">{</span>
        <span class="kw">this</span>.<span class="at">answer</span> <span class="op">=</span> <span class="st">&#39;Questions usually contain a question mark. ;-)&#39;</span>
        <span class="cf">return</span>
      <span class="op">}</span>
      <span class="kw">this</span>.<span class="at">answer</span> <span class="op">=</span> <span class="st">&#39;Thinking...&#39;</span>
      <span class="kw">var</span> vm <span class="op">=</span> <span class="kw">this</span>
      <span class="va">axios</span>.<span class="at">get</span>(<span class="st">&#39;https://yesno.wtf/api&#39;</span>)
        .<span class="at">then</span>(<span class="kw">function</span> (response) <span class="op">{</span>
          <span class="va">vm</span>.<span class="at">answer</span> <span class="op">=</span> <span class="va">_</span>.<span class="at">capitalize</span>(<span class="va">response</span>.<span class="va">data</span>.<span class="at">answer</span>)
        <span class="op">}</span>)
        .<span class="at">catch</span>(<span class="kw">function</span> (error) <span class="op">{</span>
          <span class="va">vm</span>.<span class="at">answer</span> <span class="op">=</span> <span class="st">&#39;Error! Could not reach the API. &#39;</span> <span class="op">+</span> error
        <span class="op">}</span>)
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)
<span class="kw">&lt;/script&gt;</span></code></pre></div>
<p>Result:</p>
<p>In this case, using the <code>watch</code> option allows us to perform an asynchronous operation (accessing an API), limit how often we perform that operation, and set intermediary states until we get a final answer. None of that would be possible with a computed property.</p>
<p>In addition to the <code>watch</code> option, you can also use the imperative <a href="../api/#vm-watch">vm.$watch API</a>.</p>
<h1 id="class-and-style-bindings"><a name=#guide/class-and-style.md></a>Class and Style Bindings</h1>
<p>A common need for data binding is manipulating an element's class list and its inline styles. Since they are both attributes, we can use <code>v-bind</code> to handle them: we only need to calculate a final string with our expressions. However, meddling with string concatenation is annoying and error-prone. For this reason, Vue provides special enhancements when <code>v-bind</code> is used with <code>class</code> and <code>style</code>. In addition to strings, the expressions can also evaluate to objects or arrays.</p>
<h2 id="binding-html-classes">Binding HTML Classes</h2>
<div class="vueschool">
<a href="https://vueschool.io/lessons/vuejs-dynamic-classes?friend=vuejs" target="_blank" rel="sponsored noopener" title="Free Vue.js Dynamic Classes Lesson">Watch a free video lesson on Vue School</a>
</div>
<h3 id="object-syntax">Object Syntax</h3>
<p>We can pass an object to <code>v-bind:class</code> to dynamically toggle classes:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> v-bind:class=</span><span class="st">&quot;{ active: isActive }&quot;</span><span class="kw">&gt;&lt;/div&gt;</span></code></pre></div>
<p>The above syntax means the presence of the <code>active</code> class will be determined by the <a href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy">truthiness</a> of the data property <code>isActive</code>.</p>
<p>You can have multiple classes toggled by having more fields in the object. In addition, the <code>v-bind:class</code> directive can also co-exist with the plain <code>class</code> attribute. So given the following template:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span>
<span class="ot">  class=</span><span class="st">&quot;static&quot;</span>
<span class="ot">  v-bind:class=</span><span class="st">&quot;{ active: isActive, &#39;text-danger&#39;: hasError }&quot;</span>
<span class="kw">&gt;&lt;/div&gt;</span></code></pre></div>
<p>And the following data:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">data<span class="op">:</span> <span class="op">{</span>
  <span class="dt">isActive</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
  <span class="dt">hasError</span><span class="op">:</span> <span class="kw">false</span>
<span class="op">}</span></code></pre></div>
<p>It will render:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;static active&quot;</span><span class="kw">&gt;&lt;/div&gt;</span></code></pre></div>
<p>When <code>isActive</code> or <code>hasError</code> changes, the class list will be updated accordingly. For example, if <code>hasError</code> becomes <code>true</code>, the class list will become <code>&quot;static active text-danger&quot;</code>.</p>
<p>The bound object doesn't have to be inline:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> v-bind:class=</span><span class="st">&quot;classObject&quot;</span><span class="kw">&gt;&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">data<span class="op">:</span> <span class="op">{</span>
  <span class="dt">classObject</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">active</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
    <span class="st">&#39;text-danger&#39;</span><span class="op">:</span> <span class="kw">false</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>This will render the same result. We can also bind to a <a href="computed.html">computed property</a> that returns an object. This is a common and powerful pattern:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> v-bind:class=</span><span class="st">&quot;classObject&quot;</span><span class="kw">&gt;&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">data<span class="op">:</span> <span class="op">{</span>
  <span class="dt">isActive</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
  <span class="dt">error</span><span class="op">:</span> <span class="kw">null</span>
<span class="op">},</span>
computed<span class="op">:</span> <span class="op">{</span>
  <span class="dt">classObject</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="cf">return</span> <span class="op">{</span>
      <span class="dt">active</span><span class="op">:</span> <span class="kw">this</span>.<span class="at">isActive</span> <span class="op">&amp;&amp;</span> <span class="op">!</span><span class="kw">this</span>.<span class="at">error</span><span class="op">,</span>
      <span class="st">&#39;text-danger&#39;</span><span class="op">:</span> <span class="kw">this</span>.<span class="at">error</span> <span class="op">&amp;&amp;</span> <span class="kw">this</span>.<span class="va">error</span>.<span class="at">type</span> <span class="op">===</span> <span class="st">&#39;fatal&#39;</span>
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<h3 id="array-syntax">Array Syntax</h3>
<p>We can pass an array to <code>v-bind:class</code> to apply a list of classes:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> v-bind:class=</span><span class="st">&quot;[activeClass, errorClass]&quot;</span><span class="kw">&gt;&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">data<span class="op">:</span> <span class="op">{</span>
  <span class="dt">activeClass</span><span class="op">:</span> <span class="st">&#39;active&#39;</span><span class="op">,</span>
  <span class="dt">errorClass</span><span class="op">:</span> <span class="st">&#39;text-danger&#39;</span>
<span class="op">}</span></code></pre></div>
<p>Which will render:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;active text-danger&quot;</span><span class="kw">&gt;&lt;/div&gt;</span></code></pre></div>
<p>If you would like to also toggle a class in the list conditionally, you can do it with a ternary expression:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> v-bind:class=</span><span class="st">&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;</span><span class="kw">&gt;&lt;/div&gt;</span></code></pre></div>
<p>This will always apply <code>errorClass</code>, but will only apply <code>activeClass</code> when <code>isActive</code> is truthy.</p>
<p>However, this can be a bit verbose if you have multiple conditional classes. That's why it's also possible to use the object syntax inside array syntax:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> v-bind:class=</span><span class="st">&quot;[{ active: isActive }, errorClass]&quot;</span><span class="kw">&gt;&lt;/div&gt;</span></code></pre></div>
<h3 id="with-components">With Components</h3>
<blockquote>
<p>This section assumes knowledge of <a href="components.html">Vue Components</a>. Feel free to skip it and come back later.</p>
</blockquote>
<p>When you use the <code>class</code> attribute on a custom component, those classes will be added to the component's root element. Existing classes on this element will not be overwritten.</p>
<p>For example, if you declare this component:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;my-component&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">template</span><span class="op">:</span> <span class="st">&#39;&lt;p class=&quot;foo bar&quot;&gt;Hi&lt;/p&gt;&#39;</span>
<span class="op">}</span>)</code></pre></div>
<p>Then add some classes when using it:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;my-component</span><span class="ot"> class=</span><span class="st">&quot;baz boo&quot;</span><span class="kw">&gt;&lt;/my-component&gt;</span></code></pre></div>
<p>The rendered HTML will be:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;p</span><span class="ot"> class=</span><span class="st">&quot;foo bar baz boo&quot;</span><span class="kw">&gt;</span>Hi<span class="kw">&lt;/p&gt;</span></code></pre></div>
<p>The same is true for class bindings:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;my-component</span><span class="ot"> v-bind:class=</span><span class="st">&quot;{ active: isActive }&quot;</span><span class="kw">&gt;&lt;/my-component&gt;</span></code></pre></div>
<p>When <code>isActive</code> is truthy, the rendered HTML will be:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;p</span><span class="ot"> class=</span><span class="st">&quot;foo bar active&quot;</span><span class="kw">&gt;</span>Hi<span class="kw">&lt;/p&gt;</span></code></pre></div>
<h2 id="binding-inline-styles">Binding Inline Styles</h2>
<h3 id="object-syntax-1">Object Syntax</h3>
<p>The object syntax for <code>v-bind:style</code> is pretty straightforward - it looks almost like CSS, except it's a JavaScript object. You can use either camelCase or kebab-case (use quotes with kebab-case) for the CSS property names:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> v-bind:style=</span><span class="st">&quot;{ color: activeColor, fontSize: fontSize + &#39;px&#39; }&quot;</span><span class="kw">&gt;&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">data<span class="op">:</span> <span class="op">{</span>
  <span class="dt">activeColor</span><span class="op">:</span> <span class="st">&#39;red&#39;</span><span class="op">,</span>
  <span class="dt">fontSize</span><span class="op">:</span> <span class="dv">30</span>
<span class="op">}</span></code></pre></div>
<p>It is often a good idea to bind to a style object directly so that the template is cleaner:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> v-bind:style=</span><span class="st">&quot;styleObject&quot;</span><span class="kw">&gt;&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">data<span class="op">:</span> <span class="op">{</span>
  <span class="dt">styleObject</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">color</span><span class="op">:</span> <span class="st">&#39;red&#39;</span><span class="op">,</span>
    <span class="dt">fontSize</span><span class="op">:</span> <span class="st">&#39;13px&#39;</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>Again, the object syntax is often used in conjunction with computed properties that return objects.</p>
<h3 id="array-syntax-1">Array Syntax</h3>
<p>The array syntax for <code>v-bind:style</code> allows you to apply multiple style objects to the same element:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> v-bind:style=</span><span class="st">&quot;[baseStyles, overridingStyles]&quot;</span><span class="kw">&gt;&lt;/div&gt;</span></code></pre></div>
<h3 id="auto-prefixing">Auto-prefixing</h3>
<p>When you use a CSS property that requires <a href="https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix">vendor prefixes</a> in <code>v-bind:style</code>, for example <code>transform</code>, Vue will automatically detect and add appropriate prefixes to the applied styles.</p>
<h3 id="multiple-values">Multiple Values</h3>
<blockquote>
<p>2.3.0+</p>
</blockquote>
<p>Starting in 2.3.0+ you can provide an array of multiple (prefixed) values to a style property, for example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> v-bind:style=</span><span class="st">&quot;{ display: [&#39;-webkit-box&#39;, &#39;-ms-flexbox&#39;, &#39;flex&#39;] }&quot;</span><span class="kw">&gt;&lt;/div&gt;</span></code></pre></div>
<p>This will only render the last value in the array which the browser supports. In this example, it will render <code>display: flex</code> for browsers that support the unprefixed version of flexbox.</p>
<h1 id="conditional-rendering"><a name=#guide/conditional.md></a>Conditional Rendering</h1>
<div class="vueschool">
<a href="https://vueschool.io/lessons/vuejs-conditionals?friend=vuejs" target="_blank" rel="sponsored noopener" title="Learn how conditional rendering works with Vue School">Learn how conditional rendering works with a free lesson on Vue School</a>
</div>
<h2 id="v-if"><code>v-if</code></h2>
<p>The directive <code>v-if</code> is used to conditionally render a block. The block will only be rendered if the directive's expression returns a truthy value.</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;h1</span><span class="ot"> v-if=</span><span class="st">&quot;awesome&quot;</span><span class="kw">&gt;</span>Vue is awesome!<span class="kw">&lt;/h1&gt;</span></code></pre></div>
<p>It is also possible to add an &quot;else block&quot; with <code>v-else</code>:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;h1</span><span class="ot"> v-if=</span><span class="st">&quot;awesome&quot;</span><span class="kw">&gt;</span>Vue is awesome!<span class="kw">&lt;/h1&gt;</span>
<span class="kw">&lt;h1</span><span class="ot"> v-else</span><span class="kw">&gt;</span>Oh no 😢<span class="kw">&lt;/h1&gt;</span></code></pre></div>
<h3 id="conditional-groups-with-v-if-on-template">Conditional Groups with <code>v-if</code> on <code>&lt;template&gt;</code></h3>
<p>Because <code>v-if</code> is a directive, it has to be attached to a single element. But what if we want to toggle more than one element? In this case we can use <code>v-if</code> on a <code>&lt;template&gt;</code> element, which serves as an invisible wrapper. The final rendered result will not include the <code>&lt;template&gt;</code> element.</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;template</span><span class="ot"> v-if=</span><span class="st">&quot;ok&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;h1&gt;</span>Title<span class="kw">&lt;/h1&gt;</span>
  <span class="kw">&lt;p&gt;</span>Paragraph 1<span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;p&gt;</span>Paragraph 2<span class="kw">&lt;/p&gt;</span>
<span class="kw">&lt;/template&gt;</span></code></pre></div>
<h3 id="v-else"><code>v-else</code></h3>
<p>You can use the <code>v-else</code> directive to indicate an &quot;else block&quot; for <code>v-if</code>:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> v-if=</span><span class="st">&quot;Math.random() &gt; 0.5&quot;</span><span class="kw">&gt;</span>
  Now you see me
<span class="kw">&lt;/div&gt;</span>
<span class="kw">&lt;div</span><span class="ot"> v-else</span><span class="kw">&gt;</span>
  Now you don&#39;t
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<p>A <code>v-else</code> element must immediately follow a <code>v-if</code> or a <code>v-else-if</code> element - otherwise it will not be recognized.</p>
<h3 id="v-else-if"><code>v-else-if</code></h3>
<blockquote>
<p>New in 2.1.0+</p>
</blockquote>
<p>The <code>v-else-if</code>, as the name suggests, serves as an &quot;else if block&quot; for <code>v-if</code>. It can also be chained multiple times:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> v-if=</span><span class="st">&quot;type === &#39;A&#39;&quot;</span><span class="kw">&gt;</span>
  A
<span class="kw">&lt;/div&gt;</span>
<span class="kw">&lt;div</span><span class="ot"> v-else-if=</span><span class="st">&quot;type === &#39;B&#39;&quot;</span><span class="kw">&gt;</span>
  B
<span class="kw">&lt;/div&gt;</span>
<span class="kw">&lt;div</span><span class="ot"> v-else-if=</span><span class="st">&quot;type === &#39;C&#39;&quot;</span><span class="kw">&gt;</span>
  C
<span class="kw">&lt;/div&gt;</span>
<span class="kw">&lt;div</span><span class="ot"> v-else</span><span class="kw">&gt;</span>
  Not A/B/C
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<p>Similar to <code>v-else</code>, a <code>v-else-if</code> element must immediately follow a <code>v-if</code> or a <code>v-else-if</code> element.</p>
<h3 id="controlling-reusable-elements-with-key">Controlling Reusable Elements with <code>key</code></h3>
<p>Vue tries to render elements as efficiently as possible, often re-using them instead of rendering from scratch. Beyond helping make Vue very fast, this can have some useful advantages. For example, if you allow users to toggle between multiple login types:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;template</span><span class="ot"> v-if=</span><span class="st">&quot;loginType === &#39;username&#39;&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;label&gt;</span>Username<span class="kw">&lt;/label&gt;</span>
  <span class="kw">&lt;input</span><span class="ot"> placeholder=</span><span class="st">&quot;Enter your username&quot;</span><span class="kw">&gt;</span>
<span class="kw">&lt;/template&gt;</span>
<span class="kw">&lt;template</span><span class="ot"> v-else</span><span class="kw">&gt;</span>
  <span class="kw">&lt;label&gt;</span>Email<span class="kw">&lt;/label&gt;</span>
  <span class="kw">&lt;input</span><span class="ot"> placeholder=</span><span class="st">&quot;Enter your email address&quot;</span><span class="kw">&gt;</span>
<span class="kw">&lt;/template&gt;</span></code></pre></div>
<p>Then switching the <code>loginType</code> in the code above will not erase what the user has already entered. Since both templates use the same elements, the <code>&lt;input&gt;</code> is not replaced - just its <code>placeholder</code>.</p>
<p>Check it out for yourself by entering some text in the input, then pressing the toggle button:</p>
<p>This isn't always desirable though, so Vue offers a way for you to say, &quot;These two elements are completely separate - don't re-use them.&quot; Add a <code>key</code> attribute with unique values:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;template</span><span class="ot"> v-if=</span><span class="st">&quot;loginType === &#39;username&#39;&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;label&gt;</span>Username<span class="kw">&lt;/label&gt;</span>
  <span class="kw">&lt;input</span><span class="ot"> placeholder=</span><span class="st">&quot;Enter your username&quot;</span><span class="ot"> key=</span><span class="st">&quot;username-input&quot;</span><span class="kw">&gt;</span>
<span class="kw">&lt;/template&gt;</span>
<span class="kw">&lt;template</span><span class="ot"> v-else</span><span class="kw">&gt;</span>
  <span class="kw">&lt;label&gt;</span>Email<span class="kw">&lt;/label&gt;</span>
  <span class="kw">&lt;input</span><span class="ot"> placeholder=</span><span class="st">&quot;Enter your email address&quot;</span><span class="ot"> key=</span><span class="st">&quot;email-input&quot;</span><span class="kw">&gt;</span>
<span class="kw">&lt;/template&gt;</span></code></pre></div>
<p>Now those inputs will be rendered from scratch each time you toggle. See for yourself:</p>
<p>Note that the <code>&lt;label&gt;</code> elements are still efficiently re-used, because they don't have <code>key</code> attributes.</p>
<h2 id="v-show"><code>v-show</code></h2>
<p>Another option for conditionally displaying an element is the <code>v-show</code> directive. The usage is largely the same:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;h1</span><span class="ot"> v-show=</span><span class="st">&quot;ok&quot;</span><span class="kw">&gt;</span>Hello!<span class="kw">&lt;/h1&gt;</span></code></pre></div>
<p>The difference is that an element with <code>v-show</code> will always be rendered and remain in the DOM; <code>v-show</code> only toggles the <code>display</code> CSS property of the element.</p>
<p class="tip">
Note that <code>v-show</code> doesn't support the <code>&lt;template&gt;</code> element, nor does it work with <code>v-else</code>.
</p>
<h2 id="v-if-vs-v-show"><code>v-if</code> vs <code>v-show</code></h2>
<p><code>v-if</code> is &quot;real&quot; conditional rendering because it ensures that event listeners and child components inside the conditional block are properly destroyed and re-created during toggles.</p>
<p><code>v-if</code> is also <strong>lazy</strong>: if the condition is false on initial render, it will not do anything - the conditional block won't be rendered until the condition becomes true for the first time.</p>
<p>In comparison, <code>v-show</code> is much simpler - the element is always rendered regardless of initial condition, with CSS-based toggling.</p>
<p>Generally speaking, <code>v-if</code> has higher toggle costs while <code>v-show</code> has higher initial render costs. So prefer <code>v-show</code> if you need to toggle something very often, and prefer <code>v-if</code> if the condition is unlikely to change at runtime.</p>
<h2 id="v-if-with-v-for"><code>v-if</code> with <code>v-for</code></h2>
<p class="tip">
Using <code>v-if</code> and <code>v-for</code> together is <strong>not recommended</strong>. See the <a href="/v2/style-guide/#Avoid-v-if-with-v-for-essential">style guide</a> for further information.
</p>
<p>When used together with <code>v-if</code>, <code>v-for</code> has a higher priority than <code>v-if</code>. See the <a href="../guide/list.html#v-for-with-v-if">list rendering guide</a> for details.</p>
<h1 id="list-rendering"><a name=#guide/list.md></a>List Rendering</h1>
<div class="vueschool">
<a href="https://vueschool.io/lessons/vuejs-loops?friend=vuejs" target="_blank" rel="sponsored noopener" title="Learn how to render lists on Vue School">Learn how to render list with a free Vue School lesson</a>
</div>
<h2 id="mapping-an-array-to-elements-with-v-for">Mapping an Array to Elements with <code>v-for</code></h2>
<p>We can use the <code>v-for</code> directive to render a list of items based on an array. The <code>v-for</code> directive requires a special syntax in the form of <code>item in items</code>, where <code>items</code> is the source data array and <code>item</code> is an <strong>alias</strong> for the array element being iterated on:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;ul</span><span class="ot"> id=</span><span class="st">&quot;example-1&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;li</span><span class="ot"> v-for=</span><span class="st">&quot;item in items&quot;</span><span class="ot"> :key=</span><span class="st">&quot;item.message&quot;</span><span class="kw">&gt;</span>
    {{ item.message }}
  <span class="kw">&lt;/li&gt;</span>
<span class="kw">&lt;/ul&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> example1 <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#example-1&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">items</span><span class="op">:</span> [
      <span class="op">{</span> <span class="dt">message</span><span class="op">:</span> <span class="st">&#39;Foo&#39;</span> <span class="op">},</span>
      <span class="op">{</span> <span class="dt">message</span><span class="op">:</span> <span class="st">&#39;Bar&#39;</span> <span class="op">}</span>
    ]
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>Result:</p>
<p>Inside <code>v-for</code> blocks we have full access to parent scope properties. <code>v-for</code> also supports an optional second argument for the index of the current item.</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;ul</span><span class="ot"> id=</span><span class="st">&quot;example-2&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;li</span><span class="ot"> v-for=</span><span class="st">&quot;(item, index) in items&quot;</span><span class="kw">&gt;</span>
    {{ parentMessage }} - {{ index }} - {{ item.message }}
  <span class="kw">&lt;/li&gt;</span>
<span class="kw">&lt;/ul&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> example2 <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#example-2&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">parentMessage</span><span class="op">:</span> <span class="st">&#39;Parent&#39;</span><span class="op">,</span>
    <span class="dt">items</span><span class="op">:</span> [
      <span class="op">{</span> <span class="dt">message</span><span class="op">:</span> <span class="st">&#39;Foo&#39;</span> <span class="op">},</span>
      <span class="op">{</span> <span class="dt">message</span><span class="op">:</span> <span class="st">&#39;Bar&#39;</span> <span class="op">}</span>
    ]
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>Result:</p>
{% raw%}
<ul id="example-2" class="demo">
<li v-for="(item, index) in items">
<pre><code>{{ parentMessage }} - {{ index }} - {{ item.message }}</code></pre>
</li>
</ul>
<script>
var example2 = new Vue({
  el: '#example-2',
  data: {
    parentMessage: 'Parent',
    items: [
      { message: 'Foo' },
      { message: 'Bar' }
    ]
  }
})
</script>
<p>You can also use <code>of</code> as the delimiter instead of <code>in</code>, so that it is closer to JavaScript's syntax for iterators:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> v-for=</span><span class="st">&quot;item of items&quot;</span><span class="kw">&gt;&lt;/div&gt;</span></code></pre></div>
<h2 id="v-for-with-an-object"><code>v-for</code> with an Object</h2>
<p>You can also use <code>v-for</code> to iterate through the properties of an object.</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;ul</span><span class="ot"> id=</span><span class="st">&quot;v-for-object&quot;</span><span class="ot"> class=</span><span class="st">&quot;demo&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;li</span><span class="ot"> v-for=</span><span class="st">&quot;value in object&quot;</span><span class="kw">&gt;</span>
    {{ value }}
  <span class="kw">&lt;/li&gt;</span>
<span class="kw">&lt;/ul&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#v-for-object&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">object</span><span class="op">:</span> <span class="op">{</span>
      <span class="dt">title</span><span class="op">:</span> <span class="st">&#39;How to do lists in Vue&#39;</span><span class="op">,</span>
      <span class="dt">author</span><span class="op">:</span> <span class="st">&#39;Jane Doe&#39;</span><span class="op">,</span>
      <span class="dt">publishedAt</span><span class="op">:</span> <span class="st">&#39;2016-04-10&#39;</span>
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>Result:</p>
<p>You can also provide a second argument for the property's name (a.k.a. key):</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> v-for=</span><span class="st">&quot;(value, name) in object&quot;</span><span class="kw">&gt;</span>
  {{ name }}: {{ value }}
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<p>And another for the index:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> v-for=</span><span class="st">&quot;(value, name, index) in object&quot;</span><span class="kw">&gt;</span>
  {{ index }}. {{ name }}: {{ value }}
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<p class="tip">
When iterating over an object, the order is based on the enumeration order of <code>Object.keys()</code>, which is <strong>not</strong> guaranteed to be consistent across JavaScript engine implementations.
</p>
<h2 id="maintaining-state">Maintaining State</h2>
<p>When Vue is updating a list of elements rendered with <code>v-for</code>, by default it uses an &quot;in-place patch&quot; strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular index. This is similar to the behavior of <code>track-by=&quot;$index&quot;</code> in Vue 1.x.</p>
<p>This default mode is efficient, but <strong>only suitable when your list render output does not rely on child component state or temporary DOM state (e.g. form input values)</strong>.</p>
<p>To give Vue a hint so that it can track each node's identity, and thus reuse and reorder existing elements, you need to provide a unique <code>key</code> attribute for each item:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> v-for=</span><span class="st">&quot;item in items&quot;</span><span class="ot"> v-bind:key=</span><span class="st">&quot;item.id&quot;</span><span class="kw">&gt;</span>
  <span class="co">&lt;!-- content --&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<p>It is recommended to provide a <code>key</code> attribute with <code>v-for</code> whenever possible, unless the iterated DOM content is simple, or you are intentionally relying on the default behavior for performance gains.</p>
<p>Since it's a generic mechanism for Vue to identify nodes, the <code>key</code> also has other uses that are not specifically tied to <code>v-for</code>, as we will see later in the guide.</p>
<p class="tip">
Don't use non-primitive values like objects and arrays as <code>v-for</code> keys. Use string or numeric values instead.
</p>
<p>For detailed usage of the <code>key</code> attribute, please see the <a href="https://vuejs.org/v2/api/#key"><code>key</code> API documentation</a>.</p>
<h2 id="array-change-detection">Array Change Detection</h2>
<h3 id="mutation-methods">Mutation Methods</h3>
<p>Vue wraps an observed array's mutation methods so they will also trigger view updates. The wrapped methods are:</p>
<ul>
<li><code>push()</code></li>
<li><code>pop()</code></li>
<li><code>shift()</code></li>
<li><code>unshift()</code></li>
<li><code>splice()</code></li>
<li><code>sort()</code></li>
<li><code>reverse()</code></li>
</ul>
<p>You can open the console and play with the previous examples' <code>items</code> array by calling their mutation methods. For example: <code>example1.items.push({ message: 'Baz' })</code>.</p>
<h3 id="replacing-an-array">Replacing an Array</h3>
<p>Mutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also non-mutating methods, e.g. <code>filter()</code>, <code>concat()</code> and <code>slice()</code>, which do not mutate the original array but <strong>always return a new array</strong>. When working with non-mutating methods, you can replace the old array with the new one:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">example1</span>.<span class="at">items</span> <span class="op">=</span> <span class="va">example1</span>.<span class="va">items</span>.<span class="at">filter</span>(<span class="kw">function</span> (item) <span class="op">{</span>
  <span class="cf">return</span> <span class="va">item</span>.<span class="va">message</span>.<span class="at">match</span>(<span class="ss">/Foo/</span>)
<span class="op">}</span>)</code></pre></div>
<p>You might think this will cause Vue to throw away the existing DOM and re-render the entire list - luckily, that is not the case. Vue implements some smart heuristics to maximize DOM element reuse, so replacing an array with another array containing overlapping objects is a very efficient operation.</p>
<h3 id="caveats">Caveats</h3>
<p>Due to limitations in JavaScript, there are types of changes that Vue <strong>cannot detect</strong> with arrays and objects. These are discussed in the <a href="reactivity.html#Change-Detection-Caveats">reactivity</a> section.</p>
<h2 id="displaying-filteredsorted-results">Displaying Filtered/Sorted Results</h2>
<p>Sometimes we want to display a filtered or sorted version of an array without actually mutating or resetting the original data. In this case, you can create a computed property that returns the filtered or sorted array.</p>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;li</span><span class="ot"> v-for=</span><span class="st">&quot;n in evenNumbers&quot;</span><span class="kw">&gt;</span>{{ n }}<span class="kw">&lt;/li&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">data<span class="op">:</span> <span class="op">{</span>
  <span class="dt">numbers</span><span class="op">:</span> [ <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span> ]
<span class="op">},</span>
computed<span class="op">:</span> <span class="op">{</span>
  <span class="dt">evenNumbers</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="cf">return</span> <span class="kw">this</span>.<span class="va">numbers</span>.<span class="at">filter</span>(<span class="kw">function</span> (number) <span class="op">{</span>
      <span class="cf">return</span> number <span class="op">%</span> <span class="dv">2</span> <span class="op">===</span> <span class="dv">0</span>
    <span class="op">}</span>)
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>In situations where computed properties are not feasible (e.g. inside nested <code>v-for</code> loops), you can use a method:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;ul</span><span class="ot"> v-for=</span><span class="st">&quot;set in sets&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;li</span><span class="ot"> v-for=</span><span class="st">&quot;n in even(set)&quot;</span><span class="kw">&gt;</span>{{ n }}<span class="kw">&lt;/li&gt;</span>
<span class="kw">&lt;/ul&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">data<span class="op">:</span> <span class="op">{</span>
  <span class="dt">sets</span><span class="op">:</span> [[ <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span> ]<span class="op">,</span> [<span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">10</span>]]
<span class="op">},</span>
methods<span class="op">:</span> <span class="op">{</span>
  <span class="dt">even</span><span class="op">:</span> <span class="kw">function</span> (numbers) <span class="op">{</span>
    <span class="cf">return</span> <span class="va">numbers</span>.<span class="at">filter</span>(<span class="kw">function</span> (number) <span class="op">{</span>
      <span class="cf">return</span> number <span class="op">%</span> <span class="dv">2</span> <span class="op">===</span> <span class="dv">0</span>
    <span class="op">}</span>)
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<h2 id="v-for-with-a-range"><code>v-for</code> with a Range</h2>
<p><code>v-for</code> can also take an integer. In this case it will repeat the template that many times.</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div&gt;</span>
  <span class="kw">&lt;span</span><span class="ot"> v-for=</span><span class="st">&quot;n in 10&quot;</span><span class="kw">&gt;</span>{{ n }} <span class="kw">&lt;/span&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<p>Result:</p>
<h2 id="v-for-on-a-template"><code>v-for</code> on a <code>&lt;template&gt;</code></h2>
<p>Similar to template <code>v-if</code>, you can also use a <code>&lt;template&gt;</code> tag with <code>v-for</code> to render a block of multiple elements. For example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;ul&gt;</span>
  <span class="kw">&lt;template</span><span class="ot"> v-for=</span><span class="st">&quot;item in items&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;li&gt;</span>{{ item.msg }}<span class="kw">&lt;/li&gt;</span>
    <span class="kw">&lt;li</span><span class="ot"> class=</span><span class="st">&quot;divider&quot;</span><span class="ot"> role=</span><span class="st">&quot;presentation&quot;</span><span class="kw">&gt;&lt;/li&gt;</span>
  <span class="kw">&lt;/template&gt;</span>
<span class="kw">&lt;/ul&gt;</span></code></pre></div>
<h2 id="v-for-with-v-if"><code>v-for</code> with <code>v-if</code></h2>
<p class="tip">
Note that it's <strong>not</strong> recommended to use <code>v-if</code> and <code>v-for</code> together. Refer to <a href="/v2/style-guide/#Avoid-v-if-with-v-for-essential">style guide</a> for details.
</p>
<p>When they exist on the same node, <code>v-for</code> has a higher priority than <code>v-if</code>. That means the <code>v-if</code> will be run on each iteration of the loop separately. This can be useful when you want to render nodes for only <em>some</em> items, like below:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;li</span><span class="ot"> v-for=</span><span class="st">&quot;todo in todos&quot;</span><span class="ot"> v-if=</span><span class="st">&quot;!todo.isComplete&quot;</span><span class="kw">&gt;</span>
  {{ todo }}
<span class="kw">&lt;/li&gt;</span></code></pre></div>
<p>The above only renders the todos that are not complete.</p>
<p>If instead, your intent is to conditionally skip execution of the loop, you can place the <code>v-if</code> on a wrapper element (or <a href="conditional.html#Conditional-Groups-with-v-if-on-lt-template-gt"><code>&lt;template&gt;</code></a>). For example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;ul</span><span class="ot"> v-if=</span><span class="st">&quot;todos.length&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;li</span><span class="ot"> v-for=</span><span class="st">&quot;todo in todos&quot;</span><span class="kw">&gt;</span>
    {{ todo }}
  <span class="kw">&lt;/li&gt;</span>
<span class="kw">&lt;/ul&gt;</span>
<span class="kw">&lt;p</span><span class="ot"> v-else</span><span class="kw">&gt;</span>No todos left!<span class="kw">&lt;/p&gt;</span></code></pre></div>
<h2 id="v-for-with-a-component"><code>v-for</code> with a Component</h2>
<blockquote>
<p>This section assumes knowledge of <a href="components.html">Components</a>. Feel free to skip it and come back later.</p>
</blockquote>
<p>You can directly use <code>v-for</code> on a custom component, like any normal element:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;my-component</span><span class="ot"> v-for=</span><span class="st">&quot;item in items&quot;</span><span class="ot"> :key=</span><span class="st">&quot;item.id&quot;</span><span class="kw">&gt;&lt;/my-component&gt;</span></code></pre></div>
<blockquote>
<p>In 2.2.0+, when using <code>v-for</code> with a component, a <a href="list.html#key"><code>key</code></a> is now required.</p>
</blockquote>
<p>However, this won't automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;my-component</span>
<span class="ot">  v-for=</span><span class="st">&quot;(item, index) in items&quot;</span>
<span class="ot">  v-bind:item=</span><span class="st">&quot;item&quot;</span>
<span class="ot">  v-bind:index=</span><span class="st">&quot;index&quot;</span>
<span class="ot">  v-bind:key=</span><span class="st">&quot;item.id&quot;</span>
<span class="kw">&gt;&lt;/my-component&gt;</span></code></pre></div>
<p>The reason for not automatically injecting <code>item</code> into the component is because that makes the component tightly coupled to how <code>v-for</code> works. Being explicit about where its data comes from makes the component reusable in other situations.</p>
<p>Here's a complete example of a simple todo list:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;todo-list-example&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;form</span><span class="ot"> v-on:submit.prevent=</span><span class="st">&quot;addNewTodo&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;label</span><span class="ot"> for=</span><span class="st">&quot;new-todo&quot;</span><span class="kw">&gt;</span>Add a todo<span class="kw">&lt;/label&gt;</span>
    <span class="kw">&lt;input</span>
<span class="ot">      v-model=</span><span class="st">&quot;newTodoText&quot;</span>
<span class="ot">      id=</span><span class="st">&quot;new-todo&quot;</span>
<span class="ot">      placeholder=</span><span class="st">&quot;E.g. Feed the cat&quot;</span>
    <span class="kw">&gt;</span>
    <span class="kw">&lt;button&gt;</span>Add<span class="kw">&lt;/button&gt;</span>
  <span class="kw">&lt;/form&gt;</span>
  <span class="kw">&lt;ul&gt;</span>
    <span class="kw">&lt;li</span>
<span class="ot">      is=</span><span class="st">&quot;todo-item&quot;</span>
<span class="ot">      v-for=</span><span class="st">&quot;(todo, index) in todos&quot;</span>
<span class="ot">      v-bind:key=</span><span class="st">&quot;todo.id&quot;</span>
<span class="ot">      v-bind:title=</span><span class="st">&quot;todo.title&quot;</span>
<span class="ot">      v-on:remove=</span><span class="st">&quot;todos.splice(index, 1)&quot;</span>
    <span class="kw">&gt;&lt;/li&gt;</span>
  <span class="kw">&lt;/ul&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<p class="tip">
Note the <code>is=&quot;todo-item&quot;</code> attribute. This is necessary in DOM templates, because only an <code>&lt;li&gt;</code> element is valid inside a <code>&lt;ul&gt;</code>. It does the same thing as <code>&lt;todo-item&gt;</code>, but works around a potential browser parsing error. See <a href="components.html#DOM-Template-Parsing-Caveats">DOM Template Parsing Caveats</a> to learn more.
</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;todo-item&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">template</span><span class="op">:</span> <span class="st">&#39;\</span>
<span class="st">    &lt;li&gt;\</span>
<span class="st">      {{ title }}\</span>
<span class="st">      &lt;button v-on:click=&quot;$emit(</span><span class="sc">\&#39;</span><span class="st">remove</span><span class="sc">\&#39;</span><span class="st">)&quot;&gt;Remove&lt;/button&gt;\</span>
<span class="st">    &lt;/li&gt;\</span>
<span class="st">  &#39;</span><span class="op">,</span>
  <span class="dt">props</span><span class="op">:</span> [<span class="st">&#39;title&#39;</span>]
<span class="op">}</span>)

<span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#todo-list-example&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">newTodoText</span><span class="op">:</span> <span class="st">&#39;&#39;</span><span class="op">,</span>
    <span class="dt">todos</span><span class="op">:</span> [
      <span class="op">{</span>
        <span class="dt">id</span><span class="op">:</span> <span class="dv">1</span><span class="op">,</span>
        <span class="dt">title</span><span class="op">:</span> <span class="st">&#39;Do the dishes&#39;</span><span class="op">,</span>
      <span class="op">},</span>
      <span class="op">{</span>
        <span class="dt">id</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span>
        <span class="dt">title</span><span class="op">:</span> <span class="st">&#39;Take out the trash&#39;</span><span class="op">,</span>
      <span class="op">},</span>
      <span class="op">{</span>
        <span class="dt">id</span><span class="op">:</span> <span class="dv">3</span><span class="op">,</span>
        <span class="dt">title</span><span class="op">:</span> <span class="st">&#39;Mow the lawn&#39;</span>
      <span class="op">}</span>
    ]<span class="op">,</span>
    <span class="dt">nextTodoId</span><span class="op">:</span> <span class="dv">4</span>
  <span class="op">},</span>
  <span class="dt">methods</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">addNewTodo</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="kw">this</span>.<span class="va">todos</span>.<span class="at">push</span>(<span class="op">{</span>
        <span class="dt">id</span><span class="op">:</span> <span class="kw">this</span>.<span class="at">nextTodoId</span><span class="op">++,</span>
        <span class="dt">title</span><span class="op">:</span> <span class="kw">this</span>.<span class="at">newTodoText</span>
      <span class="op">}</span>)
      <span class="kw">this</span>.<span class="at">newTodoText</span> <span class="op">=</span> <span class="st">&#39;&#39;</span>
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<h1 id="event-handling"><a name=#guide/events.md></a>Event Handling</h1>
<div class="vueschool">
<a href="https://vueschool.io/lessons/vuejs-user-events?friend=vuejs" target="_blank" rel="sponsored noopener" title="Learn how to handle events on Vue School">Learn how to handle events in a free Vue School lesson</a>
</div>
<h2 id="listening-to-events">Listening to Events</h2>
<p>We can use the <code>v-on</code> directive to listen to DOM events and run some JavaScript when they're triggered.</p>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;example-1&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;button</span><span class="ot"> v-on:click=</span><span class="st">&quot;counter += 1&quot;</span><span class="kw">&gt;</span>Add 1<span class="kw">&lt;/button&gt;</span>
  <span class="kw">&lt;p&gt;</span>The button above has been clicked {{ counter }} times.<span class="kw">&lt;/p&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> example1 <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#example-1&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">counter</span><span class="op">:</span> <span class="dv">0</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>Result:</p>
<h2 id="method-event-handlers">Method Event Handlers</h2>
<p>The logic for many event handlers will be more complex though, so keeping your JavaScript in the value of the <code>v-on</code> attribute isn't feasible. That's why <code>v-on</code> can also accept the name of a method you'd like to call.</p>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;example-2&quot;</span><span class="kw">&gt;</span>
  <span class="co">&lt;!-- `greet` is the name of a method defined below --&gt;</span>
  <span class="kw">&lt;button</span><span class="ot"> v-on:click=</span><span class="st">&quot;greet&quot;</span><span class="kw">&gt;</span>Greet<span class="kw">&lt;/button&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> example2 <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#example-2&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">name</span><span class="op">:</span> <span class="st">&#39;Vue.js&#39;</span>
  <span class="op">},</span>
  <span class="co">// define methods under the `methods` object</span>
  <span class="dt">methods</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">greet</span><span class="op">:</span> <span class="kw">function</span> (event) <span class="op">{</span>
      <span class="co">// `this` inside methods points to the Vue instance</span>
      <span class="at">alert</span>(<span class="st">&#39;Hello &#39;</span> <span class="op">+</span> <span class="kw">this</span>.<span class="at">name</span> <span class="op">+</span> <span class="st">&#39;!&#39;</span>)
      <span class="co">// `event` is the native DOM event</span>
      <span class="cf">if</span> (event) <span class="op">{</span>
        <span class="at">alert</span>(<span class="va">event</span>.<span class="va">target</span>.<span class="at">tagName</span>)
      <span class="op">}</span>
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)

<span class="co">// you can invoke methods in JavaScript too</span>
<span class="va">example2</span>.<span class="at">greet</span>() <span class="co">// =&gt; &#39;Hello Vue.js!&#39;</span></code></pre></div>
<p>Result:</p>
<h2 id="methods-in-inline-handlers">Methods in Inline Handlers</h2>
<p>Instead of binding directly to a method name, we can also use methods in an inline JavaScript statement:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;example-3&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;button</span><span class="ot"> v-on:click=</span><span class="st">&quot;say(&#39;hi&#39;)&quot;</span><span class="kw">&gt;</span>Say hi<span class="kw">&lt;/button&gt;</span>
  <span class="kw">&lt;button</span><span class="ot"> v-on:click=</span><span class="st">&quot;say(&#39;what&#39;)&quot;</span><span class="kw">&gt;</span>Say what<span class="kw">&lt;/button&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#example-3&#39;</span><span class="op">,</span>
  <span class="dt">methods</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">say</span><span class="op">:</span> <span class="kw">function</span> (message) <span class="op">{</span>
      <span class="at">alert</span>(message)
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>Result:</p>
<p>Sometimes we also need to access the original DOM event in an inline statement handler. You can pass it into a method using the special <code>$event</code> variable:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;button</span><span class="ot"> v-on:click=</span><span class="st">&quot;warn(&#39;Form cannot be submitted yet.&#39;, $event)&quot;</span><span class="kw">&gt;</span>
  Submit
<span class="kw">&lt;/button&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// ...</span>
methods<span class="op">:</span> <span class="op">{</span>
  <span class="dt">warn</span><span class="op">:</span> <span class="kw">function</span> (message<span class="op">,</span> event) <span class="op">{</span>
    <span class="co">// now we have access to the native event</span>
    <span class="cf">if</span> (event) <span class="op">{</span>
      <span class="va">event</span>.<span class="at">preventDefault</span>()
    <span class="op">}</span>
    <span class="at">alert</span>(message)
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<h2 id="event-modifiers">Event Modifiers</h2>
<p>It is a very common need to call <code>event.preventDefault()</code> or <code>event.stopPropagation()</code> inside event handlers. Although we can do this easily inside methods, it would be better if the methods can be purely about data logic rather than having to deal with DOM event details.</p>
<p>To address this problem, Vue provides <strong>event modifiers</strong> for <code>v-on</code>. Recall that modifiers are directive postfixes denoted by a dot.</p>
<ul>
<li><code>.stop</code></li>
<li><code>.prevent</code></li>
<li><code>.capture</code></li>
<li><code>.self</code></li>
<li><code>.once</code></li>
<li><code>.passive</code></li>
</ul>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- the click event&#39;s propagation will be stopped --&gt;</span>
<span class="kw">&lt;a</span><span class="ot"> v-on:click.stop=</span><span class="st">&quot;doThis&quot;</span><span class="kw">&gt;&lt;/a&gt;</span>

<span class="co">&lt;!-- the submit event will no longer reload the page --&gt;</span>
<span class="kw">&lt;form</span><span class="ot"> v-on:submit.prevent=</span><span class="st">&quot;onSubmit&quot;</span><span class="kw">&gt;&lt;/form&gt;</span>

<span class="co">&lt;!-- modifiers can be chained --&gt;</span>
<span class="kw">&lt;a</span><span class="ot"> v-on:click.stop.prevent=</span><span class="st">&quot;doThat&quot;</span><span class="kw">&gt;&lt;/a&gt;</span>

<span class="co">&lt;!-- just the modifier --&gt;</span>
<span class="kw">&lt;form</span><span class="ot"> v-on:submit.prevent</span><span class="kw">&gt;&lt;/form&gt;</span>

<span class="co">&lt;!-- use capture mode when adding the event listener --&gt;</span>
<span class="co">&lt;!-- i.e. an event targeting an inner element is handled here before being handled by that element --&gt;</span>
<span class="kw">&lt;div</span><span class="ot"> v-on:click.capture=</span><span class="st">&quot;doThis&quot;</span><span class="kw">&gt;</span>...<span class="kw">&lt;/div&gt;</span>

<span class="co">&lt;!-- only trigger handler if event.target is the element itself --&gt;</span>
<span class="co">&lt;!-- i.e. not from a child element --&gt;</span>
<span class="kw">&lt;div</span><span class="ot"> v-on:click.self=</span><span class="st">&quot;doThat&quot;</span><span class="kw">&gt;</span>...<span class="kw">&lt;/div&gt;</span></code></pre></div>
<p class="tip">
Order matters when using modifiers because the relevant code is generated in the same order. Therefore using <code>v-on:click.prevent.self</code> will prevent <strong>all clicks</strong> while <code>v-on:click.self.prevent</code> will only prevent clicks on the element itself.
</p>
<blockquote>
<p>New in 2.1.4+</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- the click event will be triggered at most once --&gt;</span>
<span class="kw">&lt;a</span><span class="ot"> v-on:click.once=</span><span class="st">&quot;doThis&quot;</span><span class="kw">&gt;&lt;/a&gt;</span></code></pre></div>
<p>Unlike the other modifiers, which are exclusive to native DOM events, the <code>.once</code> modifier can also be used on <a href="components-custom-events.html">component events</a>. If you haven't read about components yet, don't worry about this for now.</p>
<blockquote>
<p>New in 2.3.0+</p>
</blockquote>
<p>Vue also offers the <code>.passive</code> modifier, corresponding to <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters"><code>addEventListener</code>'s <code>passive</code> option</a>.</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- the scroll event&#39;s default behavior (scrolling) will happen --&gt;</span>
<span class="co">&lt;!-- immediately, instead of waiting for `onScroll` to complete  --&gt;</span>
<span class="co">&lt;!-- in case it contains `event.preventDefault()`                --&gt;</span>
<span class="kw">&lt;div</span><span class="ot"> v-on:scroll.passive=</span><span class="st">&quot;onScroll&quot;</span><span class="kw">&gt;</span>...<span class="kw">&lt;/div&gt;</span></code></pre></div>
<p>The <code>.passive</code> modifier is especially useful for improving performance on mobile devices.</p>
<p class="tip">
Don't use <code>.passive</code> and <code>.prevent</code> together, because <code>.prevent</code> will be ignored and your browser will probably show you a warning. Remember, <code>.passive</code> communicates to the browser that you <em>don't</em> want to prevent the event's default behavior.
</p>
<h2 id="key-modifiers">Key Modifiers</h2>
<p>When listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for <code>v-on</code> when listening for key events:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- only call `vm.submit()` when the `key` is `Enter` --&gt;</span>
<span class="kw">&lt;input</span><span class="ot"> v-on:keyup.enter=</span><span class="st">&quot;submit&quot;</span><span class="kw">&gt;</span></code></pre></div>
<p>You can directly use any valid key names exposed via <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values"><code>KeyboardEvent.key</code></a> as modifiers by converting them to kebab-case.</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;input</span><span class="ot"> v-on:keyup.page-down=</span><span class="st">&quot;onPageDown&quot;</span><span class="kw">&gt;</span></code></pre></div>
<p>In the above example, the handler will only be called if <code>$event.key</code> is equal to <code>'PageDown'</code>.</p>
<h3 id="key-codes">Key Codes</h3>
<p class="tip">
The use of <code>keyCode</code> events <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode">is deprecated</a> and may not be supported in new browsers.
</p>
<p>Using <code>keyCode</code> attributes is also permitted:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;input</span><span class="ot"> v-on:keyup.13=</span><span class="st">&quot;submit&quot;</span><span class="kw">&gt;</span></code></pre></div>
<p>Vue provides aliases for the most commonly used key codes when necessary for legacy browser support:</p>
<ul>
<li><code>.enter</code></li>
<li><code>.tab</code></li>
<li><code>.delete</code> (captures both &quot;Delete&quot; and &quot;Backspace&quot; keys)</li>
<li><code>.esc</code></li>
<li><code>.space</code></li>
<li><code>.up</code></li>
<li><code>.down</code></li>
<li><code>.left</code></li>
<li><code>.right</code></li>
</ul>
<p class="tip">
A few keys (<code>.esc</code> and all arrow keys) have inconsistent <code>key</code> values in IE9, so these built-in aliases should be preferred if you need to support IE9.
</p>
<p>You can also <a href="../api/#keyCodes">define custom key modifier aliases</a> via the global <code>config.keyCodes</code> object:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// enable `v-on:keyup.f1`</span>
<span class="va">Vue</span>.<span class="va">config</span>.<span class="va">keyCodes</span>.<span class="at">f1</span> <span class="op">=</span> <span class="dv">112</span></code></pre></div>
<h2 id="system-modifier-keys">System Modifier Keys</h2>
<blockquote>
<p>New in 2.1.0+</p>
</blockquote>
<p>You can use the following modifiers to trigger mouse or keyboard event listeners only when the corresponding modifier key is pressed:</p>
<ul>
<li><code>.ctrl</code></li>
<li><code>.alt</code></li>
<li><code>.shift</code></li>
<li><code>.meta</code></li>
</ul>
<blockquote>
<p>Note: On Macintosh keyboards, meta is the command key (⌘). On Windows keyboards, meta is the Windows key (⊞). On Sun Microsystems keyboards, meta is marked as a solid diamond (◆). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled “META”. On Symbolics keyboards, meta is labeled “META” or “Meta”.</p>
</blockquote>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- Alt + C --&gt;</span>
<span class="kw">&lt;input</span><span class="ot"> v-on:keyup.alt.67=</span><span class="st">&quot;clear&quot;</span><span class="kw">&gt;</span>

<span class="co">&lt;!-- Ctrl + Click --&gt;</span>
<span class="kw">&lt;div</span><span class="ot"> v-on:click.ctrl=</span><span class="st">&quot;doSomething&quot;</span><span class="kw">&gt;</span>Do something<span class="kw">&lt;/div&gt;</span></code></pre></div>
<p class="tip">
Note that modifier keys are different from regular keys and when used with <code>keyup</code> events, they have to be pressed when the event is emitted. In other words, <code>keyup.ctrl</code> will only trigger if you release a key while holding down <code>ctrl</code>. It won't trigger if you release the <code>ctrl</code> key alone. If you do want such behaviour, use the <code>keyCode</code> for <code>ctrl</code> instead: <code>keyup.17</code>.
</p>
<h3 id="exact-modifier"><code>.exact</code> Modifier</h3>
<blockquote>
<p>New in 2.5.0+</p>
</blockquote>
<p>The <code>.exact</code> modifier allows control of the exact combination of system modifiers needed to trigger an event.</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- this will fire even if Alt or Shift is also pressed --&gt;</span>
<span class="kw">&lt;button</span><span class="ot"> v-on:click.ctrl=</span><span class="st">&quot;onClick&quot;</span><span class="kw">&gt;</span>A<span class="kw">&lt;/button&gt;</span>

<span class="co">&lt;!-- this will only fire when Ctrl and no other keys are pressed --&gt;</span>
<span class="kw">&lt;button</span><span class="ot"> v-on:click.ctrl.exact=</span><span class="st">&quot;onCtrlClick&quot;</span><span class="kw">&gt;</span>A<span class="kw">&lt;/button&gt;</span>

<span class="co">&lt;!-- this will only fire when no system modifiers are pressed --&gt;</span>
<span class="kw">&lt;button</span><span class="ot"> v-on:click.exact=</span><span class="st">&quot;onClick&quot;</span><span class="kw">&gt;</span>A<span class="kw">&lt;/button&gt;</span></code></pre></div>
<h3 id="mouse-button-modifiers">Mouse Button Modifiers</h3>
<blockquote>
<p>New in 2.2.0+</p>
</blockquote>
<ul>
<li><code>.left</code></li>
<li><code>.right</code></li>
<li><code>.middle</code></li>
</ul>
<p>These modifiers restrict the handler to events triggered by a specific mouse button.</p>
<h2 id="why-listeners-in-html">Why Listeners in HTML?</h2>
<p>You might be concerned that this whole event listening approach violates the good old rules about &quot;separation of concerns&quot;. Rest assured - since all Vue handler functions and expressions are strictly bound to the ViewModel that's handling the current view, it won't cause any maintenance difficulty. In fact, there are several benefits in using <code>v-on</code>:</p>
<ol style="list-style-type: decimal">
<li><p>It's easier to locate the handler function implementations within your JS code by skimming the HTML template.</p></li>
<li><p>Since you don't have to manually attach event listeners in JS, your ViewModel code can be pure logic and DOM-free. This makes it easier to test.</p></li>
<li><p>When a ViewModel is destroyed, all event listeners are automatically removed. You don't need to worry about cleaning it up yourself.</p></li>
</ol>
<h1 id="form-input-bindings"><a name=#guide/forms.md></a>Form Input Bindings</h1>
<h2 id="basic-usage">Basic Usage</h2>
<p>You can use the <code>v-model</code> directive to create two-way data bindings on form input, textarea, and select elements. It automatically picks the correct way to update the element based on the input type. Although a bit magical, <code>v-model</code> is essentially syntax sugar for updating data on user input events, plus special care for some edge cases.</p>
<p class="tip">
<code>v-model</code> will ignore the initial <code>value</code>, <code>checked</code>, or <code>selected</code> attributes found on any form elements. It will always treat the Vue instance data as the source of truth. You should declare the initial value on the JavaScript side, inside the <code>data</code> option of your component.
</p>
<p><code>v-model</code> internally uses different properties and emits different events for different input elements: - text and textarea elements use <code>value</code> property and <code>input</code> event; - checkboxes and radiobuttons use <code>checked</code> property and <code>change</code> event; - select fields use <code>value</code> as a prop and <code>change</code> as an event.</p>
<p class="tip" id="vmodel-ime-tip">
For languages that require an <a href="https://en.wikipedia.org/wiki/Input_method">IME</a> (Chinese, Japanese, Korean, etc.), you'll notice that <code>v-model</code> doesn't get updated during IME composition. If you want to cater to these updates as well, use the <code>input</code> event instead.
</p>
<h3 id="text-1">Text</h3>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;input</span><span class="ot"> v-model=</span><span class="st">&quot;message&quot;</span><span class="ot"> placeholder=</span><span class="st">&quot;edit me&quot;</span><span class="kw">&gt;</span>
<span class="kw">&lt;p&gt;</span>Message is: {{ message }}<span class="kw">&lt;/p&gt;</span></code></pre></div>
<h3 id="multiline-text">Multiline text</h3>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;span&gt;</span>Multiline message is:<span class="kw">&lt;/span&gt;</span>
<span class="kw">&lt;p</span><span class="ot"> style=</span><span class="st">&quot;white-space: pre-line;&quot;</span><span class="kw">&gt;</span>{{ message }}<span class="kw">&lt;/p&gt;</span>
<span class="kw">&lt;br&gt;</span>
<span class="kw">&lt;textarea</span><span class="ot"> v-model=</span><span class="st">&quot;message&quot;</span><span class="ot"> placeholder=</span><span class="st">&quot;add multiple lines&quot;</span><span class="kw">&gt;&lt;/textarea&gt;</span></code></pre></div>
<h3 id="checkbox">Checkbox</h3>
<p>Single checkbox, boolean value:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&quot;checkbox&quot;</span><span class="ot"> id=</span><span class="st">&quot;checkbox&quot;</span><span class="ot"> v-model=</span><span class="st">&quot;checked&quot;</span><span class="kw">&gt;</span>
<span class="kw">&lt;label</span><span class="ot"> for=</span><span class="st">&quot;checkbox&quot;</span><span class="kw">&gt;</span>{{ checked }}<span class="kw">&lt;/label&gt;</span></code></pre></div>
<p>Multiple checkboxes, bound to the same Array:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&quot;checkbox&quot;</span><span class="ot"> id=</span><span class="st">&quot;jack&quot;</span><span class="ot"> value=</span><span class="st">&quot;Jack&quot;</span><span class="ot"> v-model=</span><span class="st">&quot;checkedNames&quot;</span><span class="kw">&gt;</span>
<span class="kw">&lt;label</span><span class="ot"> for=</span><span class="st">&quot;jack&quot;</span><span class="kw">&gt;</span>Jack<span class="kw">&lt;/label&gt;</span>
<span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&quot;checkbox&quot;</span><span class="ot"> id=</span><span class="st">&quot;john&quot;</span><span class="ot"> value=</span><span class="st">&quot;John&quot;</span><span class="ot"> v-model=</span><span class="st">&quot;checkedNames&quot;</span><span class="kw">&gt;</span>
<span class="kw">&lt;label</span><span class="ot"> for=</span><span class="st">&quot;john&quot;</span><span class="kw">&gt;</span>John<span class="kw">&lt;/label&gt;</span>
<span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&quot;checkbox&quot;</span><span class="ot"> id=</span><span class="st">&quot;mike&quot;</span><span class="ot"> value=</span><span class="st">&quot;Mike&quot;</span><span class="ot"> v-model=</span><span class="st">&quot;checkedNames&quot;</span><span class="kw">&gt;</span>
<span class="kw">&lt;label</span><span class="ot"> for=</span><span class="st">&quot;mike&quot;</span><span class="kw">&gt;</span>Mike<span class="kw">&lt;/label&gt;</span>
<span class="kw">&lt;br&gt;</span>
<span class="kw">&lt;span&gt;</span>Checked names: {{ checkedNames }}<span class="kw">&lt;/span&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;...&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">checkedNames</span><span class="op">:</span> []
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<h3 id="radio">Radio</h3>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&quot;radio&quot;</span><span class="ot"> id=</span><span class="st">&quot;one&quot;</span><span class="ot"> value=</span><span class="st">&quot;One&quot;</span><span class="ot"> v-model=</span><span class="st">&quot;picked&quot;</span><span class="kw">&gt;</span>
<span class="kw">&lt;label</span><span class="ot"> for=</span><span class="st">&quot;one&quot;</span><span class="kw">&gt;</span>One<span class="kw">&lt;/label&gt;</span>
<span class="kw">&lt;br&gt;</span>
<span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&quot;radio&quot;</span><span class="ot"> id=</span><span class="st">&quot;two&quot;</span><span class="ot"> value=</span><span class="st">&quot;Two&quot;</span><span class="ot"> v-model=</span><span class="st">&quot;picked&quot;</span><span class="kw">&gt;</span>
<span class="kw">&lt;label</span><span class="ot"> for=</span><span class="st">&quot;two&quot;</span><span class="kw">&gt;</span>Two<span class="kw">&lt;/label&gt;</span>
<span class="kw">&lt;br&gt;</span>
<span class="kw">&lt;span&gt;</span>Picked: {{ picked }}<span class="kw">&lt;/span&gt;</span></code></pre></div>
<h3 id="select">Select</h3>
<p>Single select:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;select</span><span class="ot"> v-model=</span><span class="st">&quot;selected&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;option</span><span class="ot"> disabled value=</span><span class="st">&quot;&quot;</span><span class="kw">&gt;</span>Please select one<span class="kw">&lt;/option&gt;</span>
  <span class="kw">&lt;option&gt;</span>A<span class="kw">&lt;/option&gt;</span>
  <span class="kw">&lt;option&gt;</span>B<span class="kw">&lt;/option&gt;</span>
  <span class="kw">&lt;option&gt;</span>C<span class="kw">&lt;/option&gt;</span>
<span class="kw">&lt;/select&gt;</span>
<span class="kw">&lt;span&gt;</span>Selected: {{ selected }}<span class="kw">&lt;/span&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;...&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">selected</span><span class="op">:</span> <span class="st">&#39;&#39;</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p class="tip">
If the initial value of your <code>v-model</code> expression does not match any of the options, the <code>&lt;select&gt;</code> element will render in an &quot;unselected&quot; state. On iOS, this will prevent the user from being able to select the first item, because iOS does not fire a <code>change</code> event in this case. It is therefore recommended to provide a <code>disabled</code> option with an empty value, as demonstrated in the example above.
</p>
<p>Multiple select (bound to Array):</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;select</span><span class="ot"> v-model=</span><span class="st">&quot;selected&quot;</span><span class="ot"> multiple</span><span class="kw">&gt;</span>
  <span class="kw">&lt;option&gt;</span>A<span class="kw">&lt;/option&gt;</span>
  <span class="kw">&lt;option&gt;</span>B<span class="kw">&lt;/option&gt;</span>
  <span class="kw">&lt;option&gt;</span>C<span class="kw">&lt;/option&gt;</span>
<span class="kw">&lt;/select&gt;</span>
<span class="kw">&lt;br&gt;</span>
<span class="kw">&lt;span&gt;</span>Selected: {{ selected }}<span class="kw">&lt;/span&gt;</span></code></pre></div>
<p>Dynamic options rendered with <code>v-for</code>:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;select</span><span class="ot"> v-model=</span><span class="st">&quot;selected&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;option</span><span class="ot"> v-for=</span><span class="st">&quot;option in options&quot;</span><span class="ot"> v-bind:value=</span><span class="st">&quot;option.value&quot;</span><span class="kw">&gt;</span>
    {{ option.text }}
  <span class="kw">&lt;/option&gt;</span>
<span class="kw">&lt;/select&gt;</span>
<span class="kw">&lt;span&gt;</span>Selected: {{ selected }}<span class="kw">&lt;/span&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;...&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">selected</span><span class="op">:</span> <span class="st">&#39;A&#39;</span><span class="op">,</span>
    <span class="dt">options</span><span class="op">:</span> [
      <span class="op">{</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&#39;One&#39;</span><span class="op">,</span> <span class="dt">value</span><span class="op">:</span> <span class="st">&#39;A&#39;</span> <span class="op">},</span>
      <span class="op">{</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&#39;Two&#39;</span><span class="op">,</span> <span class="dt">value</span><span class="op">:</span> <span class="st">&#39;B&#39;</span> <span class="op">},</span>
      <span class="op">{</span> <span class="dt">text</span><span class="op">:</span> <span class="st">&#39;Three&#39;</span><span class="op">,</span> <span class="dt">value</span><span class="op">:</span> <span class="st">&#39;C&#39;</span> <span class="op">}</span>
    ]
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<h2 id="value-bindings">Value Bindings</h2>
<p>For radio, checkbox and select options, the <code>v-model</code> binding values are usually static strings (or booleans for checkboxes):</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- `picked` is a string &quot;a&quot; when checked --&gt;</span>
<span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&quot;radio&quot;</span><span class="ot"> v-model=</span><span class="st">&quot;picked&quot;</span><span class="ot"> value=</span><span class="st">&quot;a&quot;</span><span class="kw">&gt;</span>

<span class="co">&lt;!-- `toggle` is either true or false --&gt;</span>
<span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&quot;checkbox&quot;</span><span class="ot"> v-model=</span><span class="st">&quot;toggle&quot;</span><span class="kw">&gt;</span>

<span class="co">&lt;!-- `selected` is a string &quot;abc&quot; when the first option is selected --&gt;</span>
<span class="kw">&lt;select</span><span class="ot"> v-model=</span><span class="st">&quot;selected&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;option</span><span class="ot"> value=</span><span class="st">&quot;abc&quot;</span><span class="kw">&gt;</span>ABC<span class="kw">&lt;/option&gt;</span>
<span class="kw">&lt;/select&gt;</span></code></pre></div>
<p>But sometimes, we may want to bind the value to a dynamic property on the Vue instance. We can use <code>v-bind</code> to achieve that. In addition, using <code>v-bind</code> allows us to bind the input value to non-string values.</p>
<h3 id="checkbox-1">Checkbox</h3>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;input</span>
<span class="ot">  type=</span><span class="st">&quot;checkbox&quot;</span>
<span class="ot">  v-model=</span><span class="st">&quot;toggle&quot;</span>
<span class="ot">  true-value=</span><span class="st">&quot;yes&quot;</span>
<span class="ot">  false-value=</span><span class="st">&quot;no&quot;</span>
<span class="kw">&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// when checked:</span>
<span class="va">vm</span>.<span class="at">toggle</span> <span class="op">===</span> <span class="st">&#39;yes&#39;</span>
<span class="co">// when unchecked:</span>
<span class="va">vm</span>.<span class="at">toggle</span> <span class="op">===</span> <span class="st">&#39;no&#39;</span></code></pre></div>
<p class="tip">
The <code>true-value</code> and <code>false-value</code> attributes don't affect the input's <code>value</code> attribute, because browsers don't include unchecked boxes in form submissions. To guarantee that one of two values is submitted in a form (i.e. &quot;yes&quot; or &quot;no&quot;), use radio inputs instead.
</p>
<h3 id="radio-1">Radio</h3>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&quot;radio&quot;</span><span class="ot"> v-model=</span><span class="st">&quot;pick&quot;</span><span class="ot"> v-bind:value=</span><span class="st">&quot;a&quot;</span><span class="kw">&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// when checked:</span>
<span class="va">vm</span>.<span class="at">pick</span> <span class="op">===</span> <span class="va">vm</span>.<span class="at">a</span></code></pre></div>
<h3 id="select-options">Select Options</h3>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;select</span><span class="ot"> v-model=</span><span class="st">&quot;selected&quot;</span><span class="kw">&gt;</span>
  <span class="co">&lt;!-- inline object literal --&gt;</span>
  <span class="kw">&lt;option</span><span class="ot"> v-bind:value=</span><span class="st">&quot;{ number: 123 }&quot;</span><span class="kw">&gt;</span>123<span class="kw">&lt;/option&gt;</span>
<span class="kw">&lt;/select&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// when selected:</span>
<span class="kw">typeof</span> <span class="va">vm</span>.<span class="at">selected</span> <span class="co">// =&gt; &#39;object&#39;</span>
<span class="va">vm</span>.<span class="va">selected</span>.<span class="at">number</span> <span class="co">// =&gt; 123</span></code></pre></div>
<h2 id="modifiers-1">Modifiers</h2>
<h3 id="lazy"><code>.lazy</code></h3>
<p>By default, <code>v-model</code> syncs the input with the data after each <code>input</code> event (with the exception of IME composition, as <a href="#vmodel-ime-tip">stated above</a>). You can add the <code>lazy</code> modifier to instead sync <em>after</em> <code>change</code> events:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- synced after &quot;change&quot; instead of &quot;input&quot; --&gt;</span>
<span class="kw">&lt;input</span><span class="ot"> v-model.lazy=</span><span class="st">&quot;msg&quot;</span><span class="kw">&gt;</span></code></pre></div>
<h3 id="number"><code>.number</code></h3>
<p>If you want user input to be automatically typecast as a Number, you can add the <code>number</code> modifier to your <code>v-model</code> managed inputs:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;input</span><span class="ot"> v-model.number=</span><span class="st">&quot;age&quot;</span><span class="ot"> type=</span><span class="st">&quot;number&quot;</span><span class="kw">&gt;</span></code></pre></div>
<p>This is often useful, because even with <code>type=&quot;number&quot;</code>, the value of HTML input elements always returns a string. If the value cannot be parsed with <code>parseFloat()</code>, then the original value is returned.</p>
<h3 id="trim"><code>.trim</code></h3>
<p>If you want whitespace from user input to be trimmed automatically, you can add the <code>trim</code> modifier to your <code>v-model</code>-managed inputs:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;input</span><span class="ot"> v-model.trim=</span><span class="st">&quot;msg&quot;</span><span class="kw">&gt;</span></code></pre></div>
<h2 id="v-model-with-components"><code>v-model</code> with Components</h2>
<blockquote>
<p>If you're not yet familiar with Vue's components, you can skip this for now.</p>
</blockquote>
<p>HTML's built-in input types won't always meet your needs. Fortunately, Vue components allow you to build reusable inputs with completely customized behavior. These inputs even work with <code>v-model</code>!</p>
<p>To learn more, read about <a href="components.html#Using-v-model-on-Components">custom inputs</a> in the Components guide.</p>
<h1 id="components-basics"><a name=#guide/components.md></a>Components Basics</h1>
<div class="vueschool">
<a href="https://vueschool.io/courses/vuejs-components-fundamentals?friend=vuejs" target="_blank" rel="sponsored noopener" title="Free Vue.js Components Fundamentals Course">Watch a free video course on Vue School</a>
</div>
<h2 id="base-example">Base Example</h2>
<p>Here's an example of a Vue component:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// Define a new component called button-counter</span>
<span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;button-counter&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">data</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="cf">return</span> <span class="op">{</span>
      <span class="dt">count</span><span class="op">:</span> <span class="dv">0</span>
    <span class="op">}</span>
  <span class="op">},</span>
  <span class="dt">template</span><span class="op">:</span> <span class="st">&#39;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me {{ count }} times.&lt;/button&gt;&#39;</span>
<span class="op">}</span>)</code></pre></div>
<p>Components are reusable Vue instances with a name: in this case, <code>&lt;button-counter&gt;</code>. We can use this component as a custom element inside a root Vue instance created with <code>new Vue</code>:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;components-demo&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;button-counter&gt;&lt;/button-counter&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span> <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#components-demo&#39;</span> <span class="op">}</span>)</code></pre></div>
<p>Since components are reusable Vue instances, they accept the same options as <code>new Vue</code>, such as <code>data</code>, <code>computed</code>, <code>watch</code>, <code>methods</code>, and lifecycle hooks. The only exceptions are a few root-specific options like <code>el</code>.</p>
<h2 id="reusing-components">Reusing Components</h2>
<p>Components can be reused as many times as you want:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;components-demo&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;button-counter&gt;&lt;/button-counter&gt;</span>
  <span class="kw">&lt;button-counter&gt;&lt;/button-counter&gt;</span>
  <span class="kw">&lt;button-counter&gt;&lt;/button-counter&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<p>Notice that when clicking on the buttons, each one maintains its own, separate <code>count</code>. That's because each time you use a component, a new <strong>instance</strong> of it is created.</p>
<h3 id="data-must-be-a-function"><code>data</code> Must Be a Function</h3>
<p>When we defined the <code>&lt;button-counter&gt;</code> component, you may have noticed that <code>data</code> wasn't directly provided an object, like this:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">data<span class="op">:</span> <span class="op">{</span>
  <span class="dt">count</span><span class="op">:</span> <span class="dv">0</span>
<span class="op">}</span></code></pre></div>
<p>Instead, <strong>a component's <code>data</code> option must be a function</strong>, so that each instance can maintain an independent copy of the returned data object:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">data<span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
  <span class="cf">return</span> <span class="op">{</span>
    <span class="dt">count</span><span class="op">:</span> <span class="dv">0</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>If Vue didn't have this rule, clicking on one button would affect the data of <em>all other instances</em>, like below:</p>
<h2 id="organizing-components">Organizing Components</h2>
<p>It's common for an app to be organized into a tree of nested components:</p>
<div class="figure">
<img src="../images/components.png" alt="Component Tree" />
<p class="caption">Component Tree</p>
</div>
<p>For example, you might have components for a header, sidebar, and content area, each typically containing other components for navigation links, blog posts, etc.</p>
<p>To use these components in templates, they must be registered so that Vue knows about them. There are two types of component registration: <strong>global</strong> and <strong>local</strong>. So far, we've only registered components globally, using <code>Vue.component</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;my-component-name&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="co">// ... options ...</span>
<span class="op">}</span>)</code></pre></div>
<p>Globally registered components can be used in the template of any root Vue instance (<code>new Vue</code>) created afterwards -- and even inside all subcomponents of that Vue instance's component tree.</p>
<p>That's all you need to know about registration for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on <a href="components-registration.html">Component Registration</a>.</p>
<h2 id="passing-data-to-child-components-with-props">Passing Data to Child Components with Props</h2>
<p>Earlier, we mentioned creating a component for blog posts. The problem is, that component won't be useful unless you can pass data to it, such as the title and content of the specific post we want to display. That's where props come in.</p>
<p>Props are custom attributes you can register on a component. When a value is passed to a prop attribute, it becomes a property on that component instance. To pass a title to our blog post component, we can include it in the list of props this component accepts, using a <code>props</code> option:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;blog-post&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">props</span><span class="op">:</span> [<span class="st">&#39;title&#39;</span>]<span class="op">,</span>
  <span class="dt">template</span><span class="op">:</span> <span class="st">&#39;&lt;h3&gt;{{ title }}&lt;/h3&gt;&#39;</span>
<span class="op">}</span>)</code></pre></div>
<p>A component can have as many props as you'd like and by default, any value can be passed to any prop. In the template above, you'll see that we can access this value on the component instance, just like with <code>data</code>.</p>
<p>Once a prop is registered, you can pass data to it as a custom attribute, like this:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;blog-post</span><span class="ot"> title=</span><span class="st">&quot;My journey with Vue&quot;</span><span class="kw">&gt;&lt;/blog-post&gt;</span>
<span class="kw">&lt;blog-post</span><span class="ot"> title=</span><span class="st">&quot;Blogging with Vue&quot;</span><span class="kw">&gt;&lt;/blog-post&gt;</span>
<span class="kw">&lt;blog-post</span><span class="ot"> title=</span><span class="st">&quot;Why Vue is so fun&quot;</span><span class="kw">&gt;&lt;/blog-post&gt;</span></code></pre></div>
<p>In a typical app, however, you'll likely have an array of posts in <code>data</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#blog-post-demo&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">posts</span><span class="op">:</span> [
      <span class="op">{</span> <span class="dt">id</span><span class="op">:</span> <span class="dv">1</span><span class="op">,</span> <span class="dt">title</span><span class="op">:</span> <span class="st">&#39;My journey with Vue&#39;</span> <span class="op">},</span>
      <span class="op">{</span> <span class="dt">id</span><span class="op">:</span> <span class="dv">2</span><span class="op">,</span> <span class="dt">title</span><span class="op">:</span> <span class="st">&#39;Blogging with Vue&#39;</span> <span class="op">},</span>
      <span class="op">{</span> <span class="dt">id</span><span class="op">:</span> <span class="dv">3</span><span class="op">,</span> <span class="dt">title</span><span class="op">:</span> <span class="st">&#39;Why Vue is so fun&#39;</span> <span class="op">}</span>
    ]
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>Then want to render a component for each one:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;blog-post</span>
<span class="ot">  v-for=</span><span class="st">&quot;post in posts&quot;</span>
<span class="ot">  v-bind:key=</span><span class="st">&quot;post.id&quot;</span>
<span class="ot">  v-bind:title=</span><span class="st">&quot;post.title&quot;</span>
<span class="kw">&gt;&lt;/blog-post&gt;</span></code></pre></div>
<p>Above, you'll see that we can use <code>v-bind</code> to dynamically pass props. This is especially useful when you don't know the exact content you're going to render ahead of time, like when <a href="https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-component-blog-post-example">fetching posts from an API</a>.</p>
<p>That's all you need to know about props for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on <a href="components-props.html">Props</a>.</p>
<h2 id="a-single-root-element">A Single Root Element</h2>
<p>When building out a <code>&lt;blog-post&gt;</code> component, your template will eventually contain more than just the title:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;h3&gt;</span>{{ title }}<span class="kw">&lt;/h3&gt;</span></code></pre></div>
<p>At the very least, you'll want to include the post's content:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;h3&gt;</span>{{ title }}<span class="kw">&lt;/h3&gt;</span>
<span class="kw">&lt;div</span><span class="ot"> v-html=</span><span class="st">&quot;content&quot;</span><span class="kw">&gt;&lt;/div&gt;</span></code></pre></div>
<p>If you try this in your template however, Vue will show an error, explaining that <strong>every component must have a single root element</strong>. You can fix this error by wrapping the template in a parent element, such as:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;blog-post&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;h3&gt;</span>{{ title }}<span class="kw">&lt;/h3&gt;</span>
  <span class="kw">&lt;div</span><span class="ot"> v-html=</span><span class="st">&quot;content&quot;</span><span class="kw">&gt;&lt;/div&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<p>As our component grows, it's likely we'll not only need the title and content of a post, but also the published date, comments, and more. Defining a prop for each related piece of information could become very annoying:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;blog-post</span>
<span class="ot">  v-for=</span><span class="st">&quot;post in posts&quot;</span>
<span class="ot">  v-bind:key=</span><span class="st">&quot;post.id&quot;</span>
<span class="ot">  v-bind:title=</span><span class="st">&quot;post.title&quot;</span>
<span class="ot">  v-bind:content=</span><span class="st">&quot;post.content&quot;</span>
<span class="ot">  v-bind:publishedAt=</span><span class="st">&quot;post.publishedAt&quot;</span>
<span class="ot">  v-bind:comments=</span><span class="st">&quot;post.comments&quot;</span>
<span class="kw">&gt;&lt;/blog-post&gt;</span></code></pre></div>
<p>So this might be a good time to refactor the <code>&lt;blog-post&gt;</code> component to accept a single <code>post</code> prop instead:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;blog-post</span>
<span class="ot">  v-for=</span><span class="st">&quot;post in posts&quot;</span>
<span class="ot">  v-bind:key=</span><span class="st">&quot;post.id&quot;</span>
<span class="ot">  v-bind:post=</span><span class="st">&quot;post&quot;</span>
<span class="kw">&gt;&lt;/blog-post&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;blog-post&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">props</span><span class="op">:</span> [<span class="st">&#39;post&#39;</span>]<span class="op">,</span>
  <span class="dt">template</span><span class="op">:</span> <span class="vs">`</span>
<span class="vs">    &lt;div class=&quot;blog-post&quot;&gt;</span>
<span class="vs">      &lt;h3&gt;{{ post.title }}&lt;/h3&gt;</span>
<span class="vs">      &lt;div v-html=&quot;post.content&quot;&gt;&lt;/div&gt;</span>
<span class="vs">    &lt;/div&gt;</span>
<span class="vs">  `</span>
<span class="op">}</span>)</code></pre></div>
<p class="tip">
The above example and some future ones use JavaScript's <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">template literal</a> to make multi-line templates more readable. These are not supported by Internet Explorer (IE), so if you must support IE and are not transpiling (e.g. with Babel or TypeScript), use <a href="https://css-tricks.com/snippets/javascript/multiline-string-variables-in-javascript/">newline escapes</a> instead.
</p>
<p>Now, whenever a new property is added to <code>post</code> objects, it will automatically be available inside <code>&lt;blog-post&gt;</code>.</p>
<h2 id="listening-to-child-components-events">Listening to Child Components Events</h2>
<p>As we develop our <code>&lt;blog-post&gt;</code> component, some features may require communicating back up to the parent. For example, we may decide to include an accessibility feature to enlarge the text of blog posts, while leaving the rest of the page its default size:</p>
<p>In the parent, we can support this feature by adding a <code>postFontSize</code> data property:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#blog-posts-events-demo&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">posts</span><span class="op">:</span> [<span class="co">/* ... */</span>]<span class="op">,</span>
    <span class="dt">postFontSize</span><span class="op">:</span> <span class="dv">1</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>Which can be used in the template to control the font size of all blog posts:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;blog-posts-events-demo&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;div</span><span class="ot"> :style=</span><span class="st">&quot;{ fontSize: postFontSize + &#39;em&#39; }&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;blog-post</span>
<span class="ot">      v-for=</span><span class="st">&quot;post in posts&quot;</span>
<span class="ot">      v-bind:key=</span><span class="st">&quot;post.id&quot;</span>
<span class="ot">      v-bind:post=</span><span class="st">&quot;post&quot;</span>
    <span class="kw">&gt;&lt;/blog-post&gt;</span>
  <span class="kw">&lt;/div&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<p>Now let's add a button to enlarge the text right before the content of every post:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;blog-post&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">props</span><span class="op">:</span> [<span class="st">&#39;post&#39;</span>]<span class="op">,</span>
  <span class="dt">template</span><span class="op">:</span> <span class="vs">`</span>
<span class="vs">    &lt;div class=&quot;blog-post&quot;&gt;</span>
<span class="vs">      &lt;h3&gt;{{ post.title }}&lt;/h3&gt;</span>
<span class="vs">      &lt;button&gt;</span>
<span class="vs">        Enlarge text</span>
<span class="vs">      &lt;/button&gt;</span>
<span class="vs">      &lt;div v-html=&quot;post.content&quot;&gt;&lt;/div&gt;</span>
<span class="vs">    &lt;/div&gt;</span>
<span class="vs">  `</span>
<span class="op">}</span>)</code></pre></div>
<p>The problem is, this button doesn't do anything:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;button&gt;</span>
  Enlarge text
<span class="kw">&lt;/button&gt;</span></code></pre></div>
<p>When we click on the button, we need to communicate to the parent that it should enlarge the text of all posts. Fortunately, Vue instances provide a custom events system to solve this problem. The parent can choose to listen to any event on the child component instance with <code>v-on</code>, just as we would with a native DOM event:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;blog-post</span>
  <span class="er">...</span>
<span class="ot">  v-on:enlarge-text=</span><span class="st">&quot;postFontSize += 0.1&quot;</span>
<span class="kw">&gt;&lt;/blog-post&gt;</span></code></pre></div>
<p>Then the child component can emit an event on itself by calling the built-in <a href="../api/#vm-emit"><strong><code>$emit</code></strong> method</a>, passing the name of the event:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;button</span><span class="ot"> v-on:click=</span><span class="st">&quot;$emit(&#39;enlarge-text&#39;)&quot;</span><span class="kw">&gt;</span>
  Enlarge text
<span class="kw">&lt;/button&gt;</span></code></pre></div>
<p>Thanks to the <code>v-on:enlarge-text=&quot;postFontSize += 0.1&quot;</code> listener, the parent will receive the event and update <code>postFontSize</code> value.</p>
<h3 id="emitting-a-value-with-an-event">Emitting a Value With an Event</h3>
<p>It's sometimes useful to emit a specific value with an event. For example, we may want the <code>&lt;blog-post&gt;</code> component to be in charge of how much to enlarge the text by. In those cases, we can use <code>$emit</code>'s 2nd parameter to provide this value:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;button</span><span class="ot"> v-on:click=</span><span class="st">&quot;$emit(&#39;enlarge-text&#39;, 0.1)&quot;</span><span class="kw">&gt;</span>
  Enlarge text
<span class="kw">&lt;/button&gt;</span></code></pre></div>
<p>Then when we listen to the event in the parent, we can access the emitted event's value with <code>$event</code>:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;blog-post</span>
  <span class="er">...</span>
<span class="ot">  v-on:enlarge-text=</span><span class="st">&quot;postFontSize += $event&quot;</span>
<span class="kw">&gt;&lt;/blog-post&gt;</span></code></pre></div>
<p>Or, if the event handler is a method:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;blog-post</span>
  <span class="er">...</span>
<span class="ot">  v-on:enlarge-text=</span><span class="st">&quot;onEnlargeText&quot;</span>
<span class="kw">&gt;&lt;/blog-post&gt;</span></code></pre></div>
<p>Then the value will be passed as the first parameter of that method:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">methods<span class="op">:</span> <span class="op">{</span>
  <span class="dt">onEnlargeText</span><span class="op">:</span> <span class="kw">function</span> (enlargeAmount) <span class="op">{</span>
    <span class="kw">this</span>.<span class="at">postFontSize</span> <span class="op">+=</span> enlargeAmount
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<h3 id="using-v-model-on-components">Using <code>v-model</code> on Components</h3>
<p>Custom events can also be used to create custom inputs that work with <code>v-model</code>. Remember that:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;input</span><span class="ot"> v-model=</span><span class="st">&quot;searchText&quot;</span><span class="kw">&gt;</span></code></pre></div>
<p>does the same thing as:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;input</span>
<span class="ot">  v-bind:value=</span><span class="st">&quot;searchText&quot;</span>
<span class="ot">  v-on:input=</span><span class="st">&quot;searchText = $event.target.value&quot;</span>
<span class="kw">&gt;</span></code></pre></div>
<p>When used on a component, <code>v-model</code> instead does this:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;custom-input</span>
<span class="ot">  v-bind:value=</span><span class="st">&quot;searchText&quot;</span>
<span class="ot">  v-on:input=</span><span class="st">&quot;searchText = $event&quot;</span>
<span class="kw">&gt;&lt;/custom-input&gt;</span></code></pre></div>
<p>For this to actually work though, the <code>&lt;input&gt;</code> inside the component must:</p>
<ul>
<li>Bind the <code>value</code> attribute to a <code>value</code> prop</li>
<li>On <code>input</code>, emit its own custom <code>input</code> event with the new value</li>
</ul>
<p>Here's that in action:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;custom-input&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">props</span><span class="op">:</span> [<span class="st">&#39;value&#39;</span>]<span class="op">,</span>
  <span class="dt">template</span><span class="op">:</span> <span class="vs">`</span>
<span class="vs">    &lt;input</span>
<span class="vs">      v-bind:value=&quot;value&quot;</span>
<span class="vs">      v-on:input=&quot;$emit(&#39;input&#39;, $event.target.value)&quot;</span>
<span class="vs">    &gt;</span>
<span class="vs">  `</span>
<span class="op">}</span>)</code></pre></div>
<p>Now <code>v-model</code> should work perfectly with this component:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;custom-input</span><span class="ot"> v-model=</span><span class="st">&quot;searchText&quot;</span><span class="kw">&gt;&lt;/custom-input&gt;</span></code></pre></div>
<p>That's all you need to know about custom component events for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on <a href="components-custom-events.html">Custom Events</a>.</p>
<h2 id="content-distribution-with-slots">Content Distribution with Slots</h2>
<p>Just like with HTML elements, it's often useful to be able to pass content to a component, like this:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;alert-box&gt;</span>
  Something bad happened.
<span class="kw">&lt;/alert-box&gt;</span></code></pre></div>
<p>Which might render something like:</p>
<p>Fortunately, this task is made very simple by Vue's custom <code>&lt;slot&gt;</code> element:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;alert-box&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">template</span><span class="op">:</span> <span class="vs">`</span>
<span class="vs">    &lt;div class=&quot;demo-alert-box&quot;&gt;</span>
<span class="vs">      &lt;strong&gt;Error!&lt;/strong&gt;</span>
<span class="vs">      &lt;slot&gt;&lt;/slot&gt;</span>
<span class="vs">    &lt;/div&gt;</span>
<span class="vs">  `</span>
<span class="op">}</span>)</code></pre></div>
<p>As you'll see above, we just add the slot where we want it to go -- and that's it. We're done!</p>
<p>That's all you need to know about slots for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on <a href="components-slots.html">Slots</a>.</p>
<h2 id="dynamic-components">Dynamic Components</h2>
<p>Sometimes, it's useful to dynamically switch between components, like in a tabbed interface:</p>
<p>The above is made possible by Vue's <code>&lt;component&gt;</code> element with the <code>is</code> special attribute:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- Component changes when currentTabComponent changes --&gt;</span>
<span class="kw">&lt;component</span><span class="ot"> v-bind:is=</span><span class="st">&quot;currentTabComponent&quot;</span><span class="kw">&gt;&lt;/component&gt;</span></code></pre></div>
<p>In the example above, <code>currentTabComponent</code> can contain either:</p>
<ul>
<li>the name of a registered component, or</li>
<li>a component's options object</li>
</ul>
<p>See <a href="https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-dynamic-components">this example</a> to experiment with the full code, or <a href="https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-dynamic-components-with-binding">this version</a> for an example binding to a component's options object, instead of its registered name.</p>
<p>Keep in mind that this attribute can be used with regular HTML elements, however they will be treated as components, which means all attributes <strong>will be bound as DOM attributes</strong>. For some properties such as <code>value</code> to work as you would expect, you will need to bind them using the <a href="../api/#v-bind"><code>.prop</code> modifier</a>.</p>
<p>That's all you need to know about dynamic components for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on <a href="components-dynamic-async.html">Dynamic &amp; Async Components</a>.</p>
<h2 id="dom-template-parsing-caveats">DOM Template Parsing Caveats</h2>
<p>Some HTML elements, such as <code>&lt;ul&gt;</code>, <code>&lt;ol&gt;</code>, <code>&lt;table&gt;</code> and <code>&lt;select&gt;</code> have restrictions on what elements can appear inside them, and some elements such as <code>&lt;li&gt;</code>, <code>&lt;tr&gt;</code>, and <code>&lt;option&gt;</code> can only appear inside certain other elements.</p>
<p>This will lead to issues when using components with elements that have such restrictions. For example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;table&gt;</span>
  <span class="kw">&lt;blog-post-row&gt;&lt;/blog-post-row&gt;</span>
<span class="kw">&lt;/table&gt;</span></code></pre></div>
<p>The custom component <code>&lt;blog-post-row&gt;</code> will be hoisted out as invalid content, causing errors in the eventual rendered output. Fortunately, the <code>is</code> special attribute offers a workaround:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;table&gt;</span>
  <span class="kw">&lt;tr</span><span class="ot"> is=</span><span class="st">&quot;blog-post-row&quot;</span><span class="kw">&gt;&lt;/tr&gt;</span>
<span class="kw">&lt;/table&gt;</span></code></pre></div>
<p>It should be noted that <strong>this limitation does <em>not</em> apply if you are using string templates from one of the following sources</strong>:</p>
<ul>
<li>String templates (e.g. <code>template: '...'</code>)</li>
<li><a href="single-file-components.html">Single-file (<code>.vue</code>) components</a></li>
<li><a href="components-edge-cases.html#X-Templates"><code>&lt;script type=&quot;text/x-template&quot;&gt;</code></a></li>
</ul>
<p>That's all you need to know about DOM template parsing caveats for now -- and actually, the end of Vue's <em>Essentials</em>. Congratulations! There's still more to learn, but first, we recommend taking a break to play with Vue yourself and build something fun.</p>
<p>Once you feel comfortable with the knowledge you've just digested, we recommend coming back to read the full guide on <a href="components-dynamic-async.html">Dynamic &amp; Async Components</a>, as well as the other pages in the Components In-Depth section of the sidebar.</p>
<h1 id="component-registration"><a name=#guide/components-registration.md></a>Component Registration</h1>
<blockquote>
<p>This page assumes you've already read the <a href="components.html">Components Basics</a>. Read that first if you are new to components.</p>
</blockquote>
<div class="vueschool">
<a href="https://vueschool.io/lessons/global-vs-local-components?friend=vuejs" target="_blank" rel="sponsored noopener" title="Free Vue.js Component Registration lesson">Watch a free video lesson on Vue School</a>
</div>
<h2 id="component-names">Component Names</h2>
<p>When registering a component, it will always be given a name. For example, in the global registration we've seen so far:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;my-component-name&#39;</span><span class="op">,</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span>)</code></pre></div>
<p>The component's name is the first argument of <code>Vue.component</code>.</p>
<p>The name you give a component may depend on where you intend to use it. When using a component directly in the DOM (as opposed to in a string template or <a href="single-file-components.html">single-file component</a>), we strongly recommend following the <a href="https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name">W3C rules</a> for custom tag names (all-lowercase, must contain a hyphen). This helps you avoid conflicts with current and future HTML elements.</p>
<p>You can see other recommendations for component names in the <a href="../style-guide/#Base-component-names-strongly-recommended">Style Guide</a>.</p>
<h3 id="name-casing">Name Casing</h3>
<p>You have two options when defining component names:</p>
<h4 id="with-kebab-case">With kebab-case</h4>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;my-component-name&#39;</span><span class="op">,</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span>)</code></pre></div>
<p>When defining a component with kebab-case, you must also use kebab-case when referencing its custom element, such as in <code>&lt;my-component-name&gt;</code>.</p>
<h4 id="with-pascalcase">With PascalCase</h4>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;MyComponentName&#39;</span><span class="op">,</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span>)</code></pre></div>
<p>When defining a component with PascalCase, you can use either case when referencing its custom element. That means both <code>&lt;my-component-name&gt;</code> and <code>&lt;MyComponentName&gt;</code> are acceptable. Note, however, that only kebab-case names are valid directly in the DOM (i.e. non-string templates).</p>
<h2 id="global-registration">Global Registration</h2>
<p>So far, we've only created components using <code>Vue.component</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;my-component-name&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="co">// ... options ...</span>
<span class="op">}</span>)</code></pre></div>
<p>These components are <strong>globally registered</strong>. That means they can be used in the template of any root Vue instance (<code>new Vue</code>) created after registration. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;component-a&#39;</span><span class="op">,</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span>)
<span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;component-b&#39;</span><span class="op">,</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span>)
<span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;component-c&#39;</span><span class="op">,</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span>)

<span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span> <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#app&#39;</span> <span class="op">}</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;app&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;component-a&gt;&lt;/component-a&gt;</span>
  <span class="kw">&lt;component-b&gt;&lt;/component-b&gt;</span>
  <span class="kw">&lt;component-c&gt;&lt;/component-c&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<p>This even applies to all subcomponents, meaning all three of these components will also be available <em>inside each other</em>.</p>
<h2 id="local-registration">Local Registration</h2>
<p>Global registration often isn't ideal. For example, if you're using a build system like Webpack, globally registering all components means that even if you stop using a component, it could still be included in your final build. This unnecessarily increases the amount of JavaScript your users have to download.</p>
<p>In these cases, you can define your components as plain JavaScript objects:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> ComponentA <span class="op">=</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span>
<span class="kw">var</span> ComponentB <span class="op">=</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span>
<span class="kw">var</span> ComponentC <span class="op">=</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span></code></pre></div>
<p>Then define the components you'd like to use in a <code>components</code> option:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#app&#39;</span><span class="op">,</span>
  <span class="dt">components</span><span class="op">:</span> <span class="op">{</span>
    <span class="st">&#39;component-a&#39;</span><span class="op">:</span> ComponentA<span class="op">,</span>
    <span class="st">&#39;component-b&#39;</span><span class="op">:</span> ComponentB
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>For each property in the <code>components</code> object, the key will be the name of the custom element, while the value will contain the options object for the component.</p>
<p>Note that <strong>locally registered components are <em>not</em> also available in subcomponents</strong>. For example, if you wanted <code>ComponentA</code> to be available in <code>ComponentB</code>, you'd have to use:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> ComponentA <span class="op">=</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span>

<span class="kw">var</span> ComponentB <span class="op">=</span> <span class="op">{</span>
  <span class="dt">components</span><span class="op">:</span> <span class="op">{</span>
    <span class="st">&#39;component-a&#39;</span><span class="op">:</span> ComponentA
  <span class="op">},</span>
  <span class="co">// ...</span>
<span class="op">}</span></code></pre></div>
<p>Or if you're using ES2015 modules, such as through Babel and Webpack, that might look more like:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="im">import</span> ComponentA <span class="im">from</span> <span class="st">&#39;./ComponentA.vue&#39;</span>

<span class="im">export</span> <span class="im">default</span> <span class="op">{</span>
  <span class="dt">components</span><span class="op">:</span> <span class="op">{</span>
    ComponentA
  <span class="op">},</span>
  <span class="co">// ...</span>
<span class="op">}</span></code></pre></div>
<p>Note that in ES2015+, placing a variable name like <code>ComponentA</code> inside an object is shorthand for <code>ComponentA: ComponentA</code>, meaning the name of the variable is both:</p>
<ul>
<li>the custom element name to use in the template, and</li>
<li>the name of the variable containing the component options</li>
</ul>
<h2 id="module-systems">Module Systems</h2>
<p>If you're not using a module system with <code>import</code>/<code>require</code>, you can probably skip this section for now. If you are, we have some special instructions and tips just for you.</p>
<h3 id="local-registration-in-a-module-system">Local Registration in a Module System</h3>
<p>If you're still here, then it's likely you're using a module system, such as with Babel and Webpack. In these cases, we recommend creating a <code>components</code> directory, with each component in its own file.</p>
<p>Then you'll need to import each component you'd like to use, before you locally register it. For example, in a hypothetical <code>ComponentB.js</code> or <code>ComponentB.vue</code> file:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="im">import</span> ComponentA <span class="im">from</span> <span class="st">&#39;./ComponentA&#39;</span>
<span class="im">import</span> ComponentC <span class="im">from</span> <span class="st">&#39;./ComponentC&#39;</span>

<span class="im">export</span> <span class="im">default</span> <span class="op">{</span>
  <span class="dt">components</span><span class="op">:</span> <span class="op">{</span>
    ComponentA<span class="op">,</span>
    ComponentC
  <span class="op">},</span>
  <span class="co">// ...</span>
<span class="op">}</span></code></pre></div>
<p>Now both <code>ComponentA</code> and <code>ComponentC</code> can be used inside <code>ComponentB</code>'s template.</p>
<h3 id="automatic-global-registration-of-base-components">Automatic Global Registration of Base Components</h3>
<p>Many of your components will be relatively generic, possibly only wrapping an element like an input or a button. We sometimes refer to these as <a href="../style-guide/#Base-component-names-strongly-recommended">base components</a> and they tend to be used very frequently across your components.</p>
<p>The result is that many components may include long lists of base components:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="im">import</span> BaseButton <span class="im">from</span> <span class="st">&#39;./BaseButton.vue&#39;</span>
<span class="im">import</span> BaseIcon <span class="im">from</span> <span class="st">&#39;./BaseIcon.vue&#39;</span>
<span class="im">import</span> BaseInput <span class="im">from</span> <span class="st">&#39;./BaseInput.vue&#39;</span>

<span class="im">export</span> <span class="im">default</span> <span class="op">{</span>
  <span class="dt">components</span><span class="op">:</span> <span class="op">{</span>
    BaseButton<span class="op">,</span>
    BaseIcon<span class="op">,</span>
    BaseInput
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>Just to support relatively little markup in a template:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;BaseInput</span>
<span class="ot">  v-model=</span><span class="st">&quot;searchText&quot;</span>
  <span class="er">@keydown.enter</span><span class="ot">=</span><span class="st">&quot;search&quot;</span>
<span class="kw">/&gt;</span>
<span class="kw">&lt;BaseButton</span> <span class="er">@click</span><span class="ot">=</span><span class="st">&quot;search&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;BaseIcon</span><span class="ot"> name=</span><span class="st">&quot;search&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/BaseButton&gt;</span></code></pre></div>
<p>Fortunately, if you're using Webpack (or <a href="https://github.com/vuejs/vue-cli">Vue CLI 3+</a>, which uses Webpack internally), you can use <code>require.context</code> to globally register only these very common base components. Here's an example of the code you might use to globally import base components in your app's entry file (e.g. <code>src/main.js</code>):</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="im">import</span> Vue <span class="im">from</span> <span class="st">&#39;vue&#39;</span>
<span class="im">import</span> upperFirst <span class="im">from</span> <span class="st">&#39;lodash/upperFirst&#39;</span>
<span class="im">import</span> camelCase <span class="im">from</span> <span class="st">&#39;lodash/camelCase&#39;</span>

<span class="kw">const</span> requireComponent <span class="op">=</span> <span class="va">require</span>.<span class="at">context</span>(
  <span class="co">// The relative path of the components folder</span>
  <span class="st">&#39;./components&#39;</span><span class="op">,</span>
  <span class="co">// Whether or not to look in subfolders</span>
  <span class="kw">false</span><span class="op">,</span>
  <span class="co">// The regular expression used to match base component filenames</span>
  <span class="ss">/Base</span><span class="sc">[A-Z]\w+\.(</span><span class="ss">vue</span><span class="sc">|</span><span class="ss">js</span><span class="sc">)$</span><span class="ss">/</span>
)

<span class="va">requireComponent</span>.<span class="at">keys</span>().<span class="at">forEach</span>(fileName <span class="op">=&gt;</span> <span class="op">{</span>
  <span class="co">// Get component config</span>
  <span class="kw">const</span> componentConfig <span class="op">=</span> <span class="at">requireComponent</span>(fileName)

  <span class="co">// Get PascalCase name of component</span>
  <span class="kw">const</span> componentName <span class="op">=</span> <span class="at">upperFirst</span>(
    <span class="at">camelCase</span>(
      <span class="co">// Gets the file name regardless of folder depth</span>
      fileName
        .<span class="at">split</span>(<span class="st">&#39;/&#39;</span>)
        .<span class="at">pop</span>()
        .<span class="at">replace</span>(<span class="ss">/</span><span class="sc">\.\w+$</span><span class="ss">/</span><span class="op">,</span> <span class="st">&#39;&#39;</span>)
    )
  )


  <span class="co">// Register component globally</span>
  <span class="va">Vue</span>.<span class="at">component</span>(
    componentName<span class="op">,</span>
    <span class="co">// Look for the component options on `.default`, which will</span>
    <span class="co">// exist if the component was exported with `export default`,</span>
    <span class="co">// otherwise fall back to module&#39;s root.</span>
    <span class="va">componentConfig</span>.<span class="at">default</span> <span class="op">||</span> componentConfig
  )
<span class="op">}</span>)</code></pre></div>
<p>Remember that <strong>global registration must take place before the root Vue instance is created (with <code>new Vue</code>)</strong>. <a href="https://github.com/chrisvfritz/vue-enterprise-boilerplate/blob/master/src/components/_globals.js">Here's an example</a> of this pattern in a real project context.</p>
<h1 id="props"><a name=#guide/components-props.md></a>Props</h1>
<blockquote>
<p>This page assumes you've already read the <a href="components.html">Components Basics</a>. Read that first if you are new to components.</p>
</blockquote>
<div class="vueschool">
<a href="https://vueschool.io/lessons/reusable-components-with-props?friend=vuejs" target="_blank" rel="sponsored noopener" title="Learn how component props work with Vue School">Learn how component props work with a free lesson on Vue School</a>
</div>
<h2 id="prop-casing-camelcase-vs-kebab-case">Prop Casing (camelCase vs kebab-case)</h2>
<p>HTML attribute names are case-insensitive, so browsers will interpret any uppercase characters as lowercase. That means when you're using in-DOM templates, camelCased prop names need to use their kebab-cased (hyphen-delimited) equivalents:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;blog-post&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="co">// camelCase in JavaScript</span>
  <span class="dt">props</span><span class="op">:</span> [<span class="st">&#39;postTitle&#39;</span>]<span class="op">,</span>
  <span class="dt">template</span><span class="op">:</span> <span class="st">&#39;&lt;h3&gt;{{ postTitle }}&lt;/h3&gt;&#39;</span>
<span class="op">}</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- kebab-case in HTML --&gt;</span>
<span class="kw">&lt;blog-post</span><span class="ot"> post-title=</span><span class="st">&quot;hello!&quot;</span><span class="kw">&gt;&lt;/blog-post&gt;</span></code></pre></div>
<p>Again, if you're using string templates, this limitation does not apply.</p>
<h2 id="prop-types">Prop Types</h2>
<p>So far, we've only seen props listed as an array of strings:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">props<span class="op">:</span> [<span class="st">&#39;title&#39;</span><span class="op">,</span> <span class="st">&#39;likes&#39;</span><span class="op">,</span> <span class="st">&#39;isPublished&#39;</span><span class="op">,</span> <span class="st">&#39;commentIds&#39;</span><span class="op">,</span> <span class="st">&#39;author&#39;</span>]</code></pre></div>
<p>Usually though, you'll want every prop to be a specific type of value. In these cases, you can list props as an object, where the properties' names and values contain the prop names and types, respectively:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">props<span class="op">:</span> <span class="op">{</span>
  <span class="dt">title</span><span class="op">:</span> String<span class="op">,</span>
  <span class="dt">likes</span><span class="op">:</span> Number<span class="op">,</span>
  <span class="dt">isPublished</span><span class="op">:</span> Boolean<span class="op">,</span>
  <span class="dt">commentIds</span><span class="op">:</span> Array<span class="op">,</span>
  <span class="dt">author</span><span class="op">:</span> Object<span class="op">,</span>
  <span class="dt">callback</span><span class="op">:</span> Function<span class="op">,</span>
  <span class="dt">contactsPromise</span><span class="op">:</span> Promise <span class="co">// or any other constructor</span>
<span class="op">}</span></code></pre></div>
<p>This not only documents your component, but will also warn users in the browser's JavaScript console if they pass the wrong type. You'll learn much more about <a href="#Prop-Validation">type checks and other prop validations</a> further down this page.</p>
<h2 id="passing-static-or-dynamic-props">Passing Static or Dynamic Props</h2>
<p>So far, you've seen props passed a static value, like in:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;blog-post</span><span class="ot"> title=</span><span class="st">&quot;My journey with Vue&quot;</span><span class="kw">&gt;&lt;/blog-post&gt;</span></code></pre></div>
<p>You've also seen props assigned dynamically with <code>v-bind</code>, such as in:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- Dynamically assign the value of a variable --&gt;</span>
<span class="kw">&lt;blog-post</span><span class="ot"> v-bind:title=</span><span class="st">&quot;post.title&quot;</span><span class="kw">&gt;&lt;/blog-post&gt;</span>

<span class="co">&lt;!-- Dynamically assign the value of a complex expression --&gt;</span>
<span class="kw">&lt;blog-post</span>
<span class="ot">  v-bind:title=</span><span class="st">&quot;post.title + &#39; by &#39; + post.author.name&quot;</span>
<span class="kw">&gt;&lt;/blog-post&gt;</span></code></pre></div>
<p>In the two examples above, we happen to pass string values, but <em>any</em> type of value can actually be passed to a prop.</p>
<h3 id="passing-a-number">Passing a Number</h3>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- Even though `42` is static, we need v-bind to tell Vue that --&gt;</span>
<span class="co">&lt;!-- this is a JavaScript expression rather than a string.       --&gt;</span>
<span class="kw">&lt;blog-post</span><span class="ot"> v-bind:likes=</span><span class="st">&quot;42&quot;</span><span class="kw">&gt;&lt;/blog-post&gt;</span>

<span class="co">&lt;!-- Dynamically assign to the value of a variable. --&gt;</span>
<span class="kw">&lt;blog-post</span><span class="ot"> v-bind:likes=</span><span class="st">&quot;post.likes&quot;</span><span class="kw">&gt;&lt;/blog-post&gt;</span></code></pre></div>
<h3 id="passing-a-boolean">Passing a Boolean</h3>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- Including the prop with no value will imply `true`. --&gt;</span>
<span class="kw">&lt;blog-post</span><span class="ot"> is-published</span><span class="kw">&gt;&lt;/blog-post&gt;</span>

<span class="co">&lt;!-- Even though `false` is static, we need v-bind to tell Vue that --&gt;</span>
<span class="co">&lt;!-- this is a JavaScript expression rather than a string.          --&gt;</span>
<span class="kw">&lt;blog-post</span><span class="ot"> v-bind:is-published=</span><span class="st">&quot;false&quot;</span><span class="kw">&gt;&lt;/blog-post&gt;</span>

<span class="co">&lt;!-- Dynamically assign to the value of a variable. --&gt;</span>
<span class="kw">&lt;blog-post</span><span class="ot"> v-bind:is-published=</span><span class="st">&quot;post.isPublished&quot;</span><span class="kw">&gt;&lt;/blog-post&gt;</span></code></pre></div>
<h3 id="passing-an-array">Passing an Array</h3>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- Even though the array is static, we need v-bind to tell Vue that --&gt;</span>
<span class="co">&lt;!-- this is a JavaScript expression rather than a string.            --&gt;</span>
<span class="kw">&lt;blog-post</span><span class="ot"> v-bind:comment-ids=</span><span class="st">&quot;[234, 266, 273]&quot;</span><span class="kw">&gt;&lt;/blog-post&gt;</span>

<span class="co">&lt;!-- Dynamically assign to the value of a variable. --&gt;</span>
<span class="kw">&lt;blog-post</span><span class="ot"> v-bind:comment-ids=</span><span class="st">&quot;post.commentIds&quot;</span><span class="kw">&gt;&lt;/blog-post&gt;</span></code></pre></div>
<h3 id="passing-an-object">Passing an Object</h3>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- Even though the object is static, we need v-bind to tell Vue that --&gt;</span>
<span class="co">&lt;!-- this is a JavaScript expression rather than a string.             --&gt;</span>
<span class="kw">&lt;blog-post</span>
<span class="ot">  v-bind:author=</span><span class="st">&quot;{</span>
<span class="st">    name: &#39;Veronica&#39;,</span>
<span class="st">    company: &#39;Veridian Dynamics&#39;</span>
<span class="st">  }&quot;</span>
<span class="kw">&gt;&lt;/blog-post&gt;</span>

<span class="co">&lt;!-- Dynamically assign to the value of a variable. --&gt;</span>
<span class="kw">&lt;blog-post</span><span class="ot"> v-bind:author=</span><span class="st">&quot;post.author&quot;</span><span class="kw">&gt;&lt;/blog-post&gt;</span></code></pre></div>
<h3 id="passing-the-properties-of-an-object">Passing the Properties of an Object</h3>
<p>If you want to pass all the properties of an object as props, you can use <code>v-bind</code> without an argument (<code>v-bind</code> instead of <code>v-bind:prop-name</code>). For example, given a <code>post</code> object:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">post<span class="op">:</span> <span class="op">{</span>
  <span class="dt">id</span><span class="op">:</span> <span class="dv">1</span><span class="op">,</span>
  <span class="dt">title</span><span class="op">:</span> <span class="st">&#39;My Journey with Vue&#39;</span>
<span class="op">}</span></code></pre></div>
<p>The following template:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;blog-post</span><span class="ot"> v-bind=</span><span class="st">&quot;post&quot;</span><span class="kw">&gt;&lt;/blog-post&gt;</span></code></pre></div>
<p>Will be equivalent to:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;blog-post</span>
<span class="ot">  v-bind:id=</span><span class="st">&quot;post.id&quot;</span>
<span class="ot">  v-bind:title=</span><span class="st">&quot;post.title&quot;</span>
<span class="kw">&gt;&lt;/blog-post&gt;</span></code></pre></div>
<h2 id="one-way-data-flow">One-Way Data Flow</h2>
<p>All props form a <strong>one-way-down binding</strong> between the child property and the parent one: when the parent property updates, it will flow down to the child, but not the other way around. This prevents child components from accidentally mutating the parent's state, which can make your app's data flow harder to understand.</p>
<p>In addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should <strong>not</strong> attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console.</p>
<p>There are usually two cases where it's tempting to mutate a prop:</p>
<ol style="list-style-type: decimal">
<li><strong>The prop is used to pass in an initial value; the child component wants to use it as a local data property afterwards.</strong> In this case, it's best to define a local data property that uses the prop as its initial value:</li>
</ol>
<p><code>js   props: ['initialCounter'],   data: function () {     return {       counter: this.initialCounter     }   }</code></p>
<ol start="2" style="list-style-type: decimal">
<li><strong>The prop is passed in as a raw value that needs to be transformed.</strong> In this case, it's best to define a computed property using the prop's value:</li>
</ol>
<p><code>js   props: ['size'],   computed: {     normalizedSize: function () {       return this.size.trim().toLowerCase()     }   }</code></p>
<p class="tip">
Note that objects and arrays in JavaScript are passed by reference, so if the prop is an array or object, mutating the object or array itself inside the child component <strong>will</strong> affect parent state.
</p>
<h2 id="prop-validation">Prop Validation</h2>
<p>Components can specify requirements for their props, such as the types you've already seen. If a requirement isn't met, Vue will warn you in the browser's JavaScript console. This is especially useful when developing a component that's intended to be used by others.</p>
<p>To specify prop validations, you can provide an object with validation requirements to the value of <code>props</code>, instead of an array of strings. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;my-component&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">props</span><span class="op">:</span> <span class="op">{</span>
    <span class="co">// Basic type check (`null` and `undefined` values will pass any type validation)</span>
    <span class="dt">propA</span><span class="op">:</span> Number<span class="op">,</span>
    <span class="co">// Multiple possible types</span>
    <span class="dt">propB</span><span class="op">:</span> [String<span class="op">,</span> Number]<span class="op">,</span>
    <span class="co">// Required string</span>
    <span class="dt">propC</span><span class="op">:</span> <span class="op">{</span>
      <span class="dt">type</span><span class="op">:</span> String<span class="op">,</span>
      <span class="dt">required</span><span class="op">:</span> <span class="kw">true</span>
    <span class="op">},</span>
    <span class="co">// Number with a default value</span>
    <span class="dt">propD</span><span class="op">:</span> <span class="op">{</span>
      <span class="dt">type</span><span class="op">:</span> Number<span class="op">,</span>
      <span class="dt">default</span><span class="op">:</span> <span class="dv">100</span>
    <span class="op">},</span>
    <span class="co">// Object with a default value</span>
    <span class="dt">propE</span><span class="op">:</span> <span class="op">{</span>
      <span class="dt">type</span><span class="op">:</span> Object<span class="op">,</span>
      <span class="co">// Object or array defaults must be returned from</span>
      <span class="co">// a factory function</span>
      <span class="dt">default</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
        <span class="cf">return</span> <span class="op">{</span> <span class="dt">message</span><span class="op">:</span> <span class="st">&#39;hello&#39;</span> <span class="op">}</span>
      <span class="op">}</span>
    <span class="op">},</span>
    <span class="co">// Custom validator function</span>
    <span class="dt">propF</span><span class="op">:</span> <span class="op">{</span>
      <span class="dt">validator</span><span class="op">:</span> <span class="kw">function</span> (value) <span class="op">{</span>
        <span class="co">// The value must match one of these strings</span>
        <span class="cf">return</span> [<span class="st">&#39;success&#39;</span><span class="op">,</span> <span class="st">&#39;warning&#39;</span><span class="op">,</span> <span class="st">&#39;danger&#39;</span>].<span class="at">indexOf</span>(value) <span class="op">!==</span> <span class="dv">-1</span>
      <span class="op">}</span>
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>When prop validation fails, Vue will produce a console warning (if using the development build).</p>
<p class="tip">
Note that props are validated <strong>before</strong> a component instance is created, so instance properties (e.g. <code>data</code>, <code>computed</code>, etc) will not be available inside <code>default</code> or <code>validator</code> functions.
</p>
<h3 id="type-checks">Type Checks</h3>
<p>The <code>type</code> can be one of the following native constructors:</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Array</li>
<li>Object</li>
<li>Date</li>
<li>Function</li>
<li>Symbol</li>
</ul>
<p>In addition, <code>type</code> can also be a custom constructor function and the assertion will be made with an <code>instanceof</code> check. For example, given the following constructor function exists:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">Person</span> (firstName<span class="op">,</span> lastName) <span class="op">{</span>
  <span class="kw">this</span>.<span class="at">firstName</span> <span class="op">=</span> firstName
  <span class="kw">this</span>.<span class="at">lastName</span> <span class="op">=</span> lastName
<span class="op">}</span></code></pre></div>
<p>You could use:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;blog-post&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">props</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">author</span><span class="op">:</span> Person
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>to validate that the value of the <code>author</code> prop was created with <code>new Person</code>.</p>
<h2 id="non-prop-attributes">Non-Prop Attributes</h2>
<p>A non-prop attribute is an attribute that is passed to a component, but does not have a corresponding prop defined.</p>
<p>While explicitly defined props are preferred for passing information to a child component, authors of component libraries can't always foresee the contexts in which their components might be used. That's why components can accept arbitrary attributes, which are added to the component's root element.</p>
<p>For example, imagine we're using a 3rd-party <code>bootstrap-date-input</code> component with a Bootstrap plugin that requires a <code>data-date-picker</code> attribute on the <code>input</code>. We can add this attribute to our component instance:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;bootstrap-date-input</span><span class="ot"> data-date-picker=</span><span class="st">&quot;activated&quot;</span><span class="kw">&gt;&lt;/bootstrap-date-input&gt;</span></code></pre></div>
<p>And the <code>data-date-picker=&quot;activated&quot;</code> attribute will automatically be added to the root element of <code>bootstrap-date-input</code>.</p>
<h3 id="replacingmerging-with-existing-attributes">Replacing/Merging with Existing Attributes</h3>
<p>Imagine this is the template for <code>bootstrap-date-input</code>:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&quot;date&quot;</span><span class="ot"> class=</span><span class="st">&quot;form-control&quot;</span><span class="kw">&gt;</span></code></pre></div>
<p>To specify a theme for our date picker plugin, we might need to add a specific class, like this:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;bootstrap-date-input</span>
<span class="ot">  data-date-picker=</span><span class="st">&quot;activated&quot;</span>
<span class="ot">  class=</span><span class="st">&quot;date-picker-theme-dark&quot;</span>
<span class="kw">&gt;&lt;/bootstrap-date-input&gt;</span></code></pre></div>
<p>In this case, two different values for <code>class</code> are defined:</p>
<ul>
<li><code>form-control</code>, which is set by the component in its template</li>
<li><code>date-picker-theme-dark</code>, which is passed to the component by its parent</li>
</ul>
<p>For most attributes, the value provided to the component will replace the value set by the component. So for example, passing <code>type=&quot;text&quot;</code> will replace <code>type=&quot;date&quot;</code> and probably break it! Fortunately, the <code>class</code> and <code>style</code> attributes are a little smarter, so both values are merged, making the final value: <code>form-control date-picker-theme-dark</code>.</p>
<h3 id="disabling-attribute-inheritance">Disabling Attribute Inheritance</h3>
<p>If you do <strong>not</strong> want the root element of a component to inherit attributes, you can set <code>inheritAttrs: false</code> in the component's options. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;my-component&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">inheritAttrs</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span>
  <span class="co">// ...</span>
<span class="op">}</span>)</code></pre></div>
<p>This can be especially useful in combination with the <code>$attrs</code> instance property, which contains the attribute names and values passed to a component, such as:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="op">{</span>
  <span class="dt">required</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
  <span class="dt">placeholder</span><span class="op">:</span> <span class="st">&#39;Enter your username&#39;</span>
<span class="op">}</span></code></pre></div>
<p>With <code>inheritAttrs: false</code> and <code>$attrs</code>, you can manually decide which element you want to forward attributes to, which is often desirable for <a href="../style-guide/#Base-component-names-strongly-recommended">base components</a>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;base-input&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">inheritAttrs</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span>
  <span class="dt">props</span><span class="op">:</span> [<span class="st">&#39;label&#39;</span><span class="op">,</span> <span class="st">&#39;value&#39;</span>]<span class="op">,</span>
  <span class="dt">template</span><span class="op">:</span> <span class="vs">`</span>
<span class="vs">    &lt;label&gt;</span>
<span class="vs">      {{ label }}</span>
<span class="vs">      &lt;input</span>
<span class="vs">        v-bind=&quot;$attrs&quot;</span>
<span class="vs">        v-bind:value=&quot;value&quot;</span>
<span class="vs">        v-on:input=&quot;$emit(&#39;input&#39;, $event.target.value)&quot;</span>
<span class="vs">      &gt;</span>
<span class="vs">    &lt;/label&gt;</span>
<span class="vs">  `</span>
<span class="op">}</span>)</code></pre></div>
<p class="tip">
Note that <code>inheritAttrs: false</code> option does <strong>not</strong> affect <code>style</code> and <code>class</code> bindings.
</p>
<p>This pattern allows you to use base components more like raw HTML elements, without having to care about which element is actually at its root:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;base-input</span>
<span class="ot">  v-model=</span><span class="st">&quot;username&quot;</span>
<span class="ot">  required</span>
<span class="ot">  placeholder=</span><span class="st">&quot;Enter your username&quot;</span>
<span class="kw">&gt;&lt;/base-input&gt;</span></code></pre></div>
<h1 id="custom-events"><a name=#guide/components-custom-events.md></a>Custom Events</h1>
<blockquote>
<p>This page assumes you've already read the <a href="components.html">Components Basics</a>. Read that first if you are new to components.</p>
</blockquote>
<div class="vueschool">
<a href="https://vueschool.io/lessons/communication-between-components?friend=vuejs" target="_blank" rel="sponsored noopener" title="Learn how to work with custom events on Vue School">Learn how to work with custom events in a free Vue School lesson</a>
</div>
<h2 id="event-names">Event Names</h2>
<p>Unlike components and props, event names don't provide any automatic case transformation. Instead, the name of an emitted event must exactly match the name used to listen to that event. For example, if emitting a camelCased event name:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">this</span>.<span class="at">$emit</span>(<span class="st">&#39;myEvent&#39;</span>)</code></pre></div>
<p>Listening to the kebab-cased version will have no effect:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- Won&#39;t work --&gt;</span>
<span class="kw">&lt;my-component</span><span class="ot"> v-on:my-event=</span><span class="st">&quot;doSomething&quot;</span><span class="kw">&gt;&lt;/my-component&gt;</span></code></pre></div>
<p>Unlike components and props, event names will never be used as variable or property names in JavaScript, so there's no reason to use camelCase or PascalCase. Additionally, <code>v-on</code> event listeners inside DOM templates will be automatically transformed to lowercase (due to HTML's case-insensitivity), so <code>v-on:myEvent</code> would become <code>v-on:myevent</code> -- making <code>myEvent</code> impossible to listen to.</p>
<p>For these reasons, we recommend you <strong>always use kebab-case for event names</strong>.</p>
<h2 id="customizing-component-v-model">Customizing Component <code>v-model</code></h2>
<blockquote>
<p>New in 2.2.0+</p>
</blockquote>
<p>By default, <code>v-model</code> on a component uses <code>value</code> as the prop and <code>input</code> as the event, but some input types such as checkboxes and radio buttons may want to use the <code>value</code> attribute for a <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value">different purpose</a>. Using the <code>model</code> option can avoid a conflict in such cases:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;base-checkbox&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">model</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">prop</span><span class="op">:</span> <span class="st">&#39;checked&#39;</span><span class="op">,</span>
    <span class="dt">event</span><span class="op">:</span> <span class="st">&#39;change&#39;</span>
  <span class="op">},</span>
  <span class="dt">props</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">checked</span><span class="op">:</span> Boolean
  <span class="op">},</span>
  <span class="dt">template</span><span class="op">:</span> <span class="vs">`</span>
<span class="vs">    &lt;input</span>
<span class="vs">      type=&quot;checkbox&quot;</span>
<span class="vs">      v-bind:checked=&quot;checked&quot;</span>
<span class="vs">      v-on:change=&quot;$emit(&#39;change&#39;, $event.target.checked)&quot;</span>
<span class="vs">    &gt;</span>
<span class="vs">  `</span>
<span class="op">}</span>)</code></pre></div>
<p>Now when using <code>v-model</code> on this component:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;base-checkbox</span><span class="ot"> v-model=</span><span class="st">&quot;lovingVue&quot;</span><span class="kw">&gt;&lt;/base-checkbox&gt;</span></code></pre></div>
<p>the value of <code>lovingVue</code> will be passed to the <code>checked</code> prop. The <code>lovingVue</code> property will then be updated when <code>&lt;base-checkbox&gt;</code> emits a <code>change</code> event with a new value.</p>
<p class="tip">
Note that you still have to declare the <code>checked</code> prop in the component's <code>props</code> option.
</p>
<h2 id="binding-native-events-to-components">Binding Native Events to Components</h2>
<p>There may be times when you want to listen directly to a native event on the root element of a component. In these cases, you can use the <code>.native</code> modifier for <code>v-on</code>:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;base-input</span><span class="ot"> v-on:focus.native=</span><span class="st">&quot;onFocus&quot;</span><span class="kw">&gt;&lt;/base-input&gt;</span></code></pre></div>
<p>This can be useful sometimes, but it's not a good idea when you're trying to listen on a very specific element, like an <code>&lt;input&gt;</code>. For example, the <code>&lt;base-input&gt;</code> component above might refactor so that the root element is actually a <code>&lt;label&gt;</code> element:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;label&gt;</span>
  {{ label }}
  <span class="kw">&lt;input</span>
<span class="ot">    v-bind=</span><span class="st">&quot;$attrs&quot;</span>
<span class="ot">    v-bind:value=</span><span class="st">&quot;value&quot;</span>
<span class="ot">    v-on:input=</span><span class="st">&quot;$emit(&#39;input&#39;, $event.target.value)&quot;</span>
  <span class="kw">&gt;</span>
<span class="kw">&lt;/label&gt;</span></code></pre></div>
<p>In that case, the <code>.native</code> listener in the parent would silently break. There would be no errors, but the <code>onFocus</code> handler wouldn't be called when we expected it to.</p>
<p>To solve this problem, Vue provides a <code>$listeners</code> property containing an object of listeners being used on the component. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="op">{</span>
  <span class="dt">focus</span><span class="op">:</span> <span class="kw">function</span> (event) <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span>
  <span class="dt">input</span><span class="op">:</span> <span class="kw">function</span> (value) <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">},</span>
<span class="op">}</span></code></pre></div>
<p>Using the <code>$listeners</code> property, you can forward all event listeners on the component to a specific child element with <code>v-on=&quot;$listeners&quot;</code>. For elements like <code>&lt;input&gt;</code>, that you also want to work with <code>v-model</code>, it's often useful to create a new computed property for listeners, like <code>inputListeners</code> below:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;base-input&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">inheritAttrs</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span>
  <span class="dt">props</span><span class="op">:</span> [<span class="st">&#39;label&#39;</span><span class="op">,</span> <span class="st">&#39;value&#39;</span>]<span class="op">,</span>
  <span class="dt">computed</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">inputListeners</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="kw">var</span> vm <span class="op">=</span> <span class="kw">this</span>
      <span class="co">// `Object.assign` merges objects together to form a new object</span>
      <span class="cf">return</span> <span class="va">Object</span>.<span class="at">assign</span>(<span class="op">{},</span>
        <span class="co">// We add all the listeners from the parent</span>
        <span class="kw">this</span>.<span class="at">$listeners</span><span class="op">,</span>
        <span class="co">// Then we can add custom listeners or override the</span>
        <span class="co">// behavior of some listeners.</span>
        <span class="op">{</span>
          <span class="co">// This ensures that the component works with v-model</span>
          <span class="dt">input</span><span class="op">:</span> <span class="kw">function</span> (event) <span class="op">{</span>
            <span class="va">vm</span>.<span class="at">$emit</span>(<span class="st">&#39;input&#39;</span><span class="op">,</span> <span class="va">event</span>.<span class="va">target</span>.<span class="at">value</span>)
          <span class="op">}</span>
        <span class="op">}</span>
      )
    <span class="op">}</span>
  <span class="op">},</span>
  <span class="dt">template</span><span class="op">:</span> <span class="vs">`</span>
<span class="vs">    &lt;label&gt;</span>
<span class="vs">      {{ label }}</span>
<span class="vs">      &lt;input</span>
<span class="vs">        v-bind=&quot;$attrs&quot;</span>
<span class="vs">        v-bind:value=&quot;value&quot;</span>
<span class="vs">        v-on=&quot;inputListeners&quot;</span>
<span class="vs">      &gt;</span>
<span class="vs">    &lt;/label&gt;</span>
<span class="vs">  `</span>
<span class="op">}</span>)</code></pre></div>
<p>Now the <code>&lt;base-input&gt;</code> component is a <strong>fully transparent wrapper</strong>, meaning it can be used exactly like a normal <code>&lt;input&gt;</code> element: all the same attributes and listeners will work, without the <code>.native</code> modifier.</p>
<h2 id="sync-modifier"><code>.sync</code> Modifier</h2>
<blockquote>
<p>New in 2.3.0+</p>
</blockquote>
<p>In some cases, we may need &quot;two-way binding&quot; for a prop. Unfortunately, true two-way binding can create maintenance issues, because child components can mutate the parent without the source of that mutation being obvious in both the parent and the child.</p>
<p>That's why instead, we recommend emitting events in the pattern of <code>update:myPropName</code>. For example, in a hypothetical component with a <code>title</code> prop, we could communicate the intent of assigning a new value with:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">this</span>.<span class="at">$emit</span>(<span class="st">&#39;update:title&#39;</span><span class="op">,</span> newTitle)</code></pre></div>
<p>Then the parent can listen to that event and update a local data property, if it wants to. For example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;text-document</span>
<span class="ot">  v-bind:title=</span><span class="st">&quot;doc.title&quot;</span>
<span class="ot">  v-on:update:title=</span><span class="st">&quot;doc.title = $event&quot;</span>
<span class="kw">&gt;&lt;/text-document&gt;</span></code></pre></div>
<p>For convenience, we offer a shorthand for this pattern with the <code>.sync</code> modifier:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;text-document</span><span class="ot"> v-bind:title.sync=</span><span class="st">&quot;doc.title&quot;</span><span class="kw">&gt;&lt;/text-document&gt;</span></code></pre></div>
<p class="tip">
Note that <code>v-bind</code> with the <code>.sync</code> modifier does <strong>not</strong> work with expressions (e.g. <code>v-bind:title.sync=&quot;doc.title + '!'&quot;</code> is invalid). Instead, you must only provide the name of the property you want to bind, similar to <code>v-model</code>.
</p>
<p>The <code>.sync</code> modifier can also be used with <code>v-bind</code> when using an object to set multiple props at once:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;text-document</span><span class="ot"> v-bind.sync=</span><span class="st">&quot;doc&quot;</span><span class="kw">&gt;&lt;/text-document&gt;</span></code></pre></div>
<p>This passes each property in the <code>doc</code> object (e.g. <code>title</code>) as an individual prop, then adds <code>v-on</code> update listeners for each one.</p>
<p class="tip">
Using <code>v-bind.sync</code> with a literal object, such as in <code>v-bind.sync=&quot;{ title: doc.title }&quot;</code>, will not work, because there are too many edge cases to consider in parsing a complex expression like this.
</p>
<h1 id="slots"><a name=#guide/components-slots.md></a>Slots</h1>
<blockquote>
<p>This page assumes you've already read the <a href="components.html">Components Basics</a>. Read that first if you are new to components.</p>
</blockquote>
<blockquote>
<p>In 2.6.0, we introduced a new unified syntax (the <code>v-slot</code> directive) for named and scoped slots. It replaces the <code>slot</code> and <code>slot-scope</code> attributes, which are now deprecated, but have <em>not</em> been removed and are still documented <a href="#Deprecated-Syntax">here</a>. The rationale for introducing the new syntax is described in this <a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md">RFC</a>.</p>
</blockquote>
<h2 id="slot-content">Slot Content</h2>
<p>Vue implements a content distribution API inspired by the <a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md">Web Components spec draft</a>, using the <code>&lt;slot&gt;</code> element to serve as distribution outlets for content.</p>
<p>This allows you to compose components like this:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;navigation-link</span><span class="ot"> url=</span><span class="st">&quot;/profile&quot;</span><span class="kw">&gt;</span>
  Your Profile
<span class="kw">&lt;/navigation-link&gt;</span></code></pre></div>
<p>Then in the template for <code>&lt;navigation-link&gt;</code>, you might have:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;a</span>
<span class="ot">  v-bind:href=</span><span class="st">&quot;url&quot;</span>
<span class="ot">  class=</span><span class="st">&quot;nav-link&quot;</span>
<span class="kw">&gt;</span>
  <span class="kw">&lt;slot&gt;&lt;/slot&gt;</span>
<span class="kw">&lt;/a&gt;</span></code></pre></div>
<p>When the component renders, <code>&lt;slot&gt;&lt;/slot&gt;</code> will be replaced by &quot;Your Profile&quot;. Slots can contain any template code, including HTML:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;navigation-link</span><span class="ot"> url=</span><span class="st">&quot;/profile&quot;</span><span class="kw">&gt;</span>
  <span class="co">&lt;!-- Add a Font Awesome icon --&gt;</span>
  <span class="kw">&lt;span</span><span class="ot"> class=</span><span class="st">&quot;fa fa-user&quot;</span><span class="kw">&gt;&lt;/span&gt;</span>
  Your Profile
<span class="kw">&lt;/navigation-link&gt;</span></code></pre></div>
<p>Or even other components:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;navigation-link</span><span class="ot"> url=</span><span class="st">&quot;/profile&quot;</span><span class="kw">&gt;</span>
  <span class="co">&lt;!-- Use a component to add an icon --&gt;</span>
  <span class="kw">&lt;font-awesome-icon</span><span class="ot"> name=</span><span class="st">&quot;user&quot;</span><span class="kw">&gt;&lt;/font-awesome-icon&gt;</span>
  Your Profile
<span class="kw">&lt;/navigation-link&gt;</span></code></pre></div>
<p>If <code>&lt;navigation-link&gt;</code>'s template did <strong>not</strong> contain a <code>&lt;slot&gt;</code> element, any content provided between its opening and closing tag would be discarded.</p>
<h2 id="compilation-scope">Compilation Scope</h2>
<p>When you want to use data inside a slot, such as in:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;navigation-link</span><span class="ot"> url=</span><span class="st">&quot;/profile&quot;</span><span class="kw">&gt;</span>
  Logged in as {{ user.name }}
<span class="kw">&lt;/navigation-link&gt;</span></code></pre></div>
<p>That slot has access to the same instance properties (i.e. the same &quot;scope&quot;) as the rest of the template. The slot does <strong>not</strong> have access to <code>&lt;navigation-link&gt;</code>'s scope. For example, trying to access <code>url</code> would not work:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;navigation-link</span><span class="ot"> url=</span><span class="st">&quot;/profile&quot;</span><span class="kw">&gt;</span>
  Clicking here will send you to: {{ url }}
  <span class="co">&lt;!--</span>
<span class="co">  The `url` will be undefined, because this content is passed</span>
<span class="co">  _to_ &lt;navigation-link&gt;, rather than defined _inside_ the</span>
<span class="co">  &lt;navigation-link&gt; component.</span>
<span class="co">  --&gt;</span>
<span class="kw">&lt;/navigation-link&gt;</span></code></pre></div>
<p>As a rule, remember that:</p>
<blockquote>
<p>Everything in the parent template is compiled in parent scope; everything in the child template is compiled in the child scope.</p>
</blockquote>
<h2 id="fallback-content">Fallback Content</h2>
<p>There are cases when it's useful to specify fallback (i.e. default) content for a slot, to be rendered only when no content is provided. For example, in a <code>&lt;submit-button&gt;</code> component:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;button</span><span class="ot"> type=</span><span class="st">&quot;submit&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;slot&gt;&lt;/slot&gt;</span>
<span class="kw">&lt;/button&gt;</span></code></pre></div>
<p>We might want the text &quot;Submit&quot; to be rendered inside the <code>&lt;button&gt;</code> most of the time. To make &quot;Submit&quot; the fallback content, we can place it in between the <code>&lt;slot&gt;</code> tags:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;button</span><span class="ot"> type=</span><span class="st">&quot;submit&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;slot&gt;</span>Submit<span class="kw">&lt;/slot&gt;</span>
<span class="kw">&lt;/button&gt;</span></code></pre></div>
<p>Now when we use <code>&lt;submit-button&gt;</code> in a parent component, providing no content for the slot:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;submit-button&gt;&lt;/submit-button&gt;</span></code></pre></div>
<p>will render the fallback content, &quot;Submit&quot;:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;button</span><span class="ot"> type=</span><span class="st">&quot;submit&quot;</span><span class="kw">&gt;</span>
  Submit
<span class="kw">&lt;/button&gt;</span></code></pre></div>
<p>But if we provide content:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;submit-button&gt;</span>
  Save
<span class="kw">&lt;/submit-button&gt;</span></code></pre></div>
<p>Then the provided content will be rendered instead:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;button</span><span class="ot"> type=</span><span class="st">&quot;submit&quot;</span><span class="kw">&gt;</span>
  Save
<span class="kw">&lt;/button&gt;</span></code></pre></div>
<h2 id="named-slots">Named Slots</h2>
<blockquote>
<p>Updated in 2.6.0+. <a href="#Deprecated-Syntax">See here</a> for the deprecated syntax using the <code>slot</code> attribute.</p>
</blockquote>
<p>There are times when it's useful to have multiple slots. For example, in a <code>&lt;base-layout&gt;</code> component with the following template:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;container&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;header&gt;</span>
    <span class="co">&lt;!-- We want header content here --&gt;</span>
  <span class="kw">&lt;/header&gt;</span>
  <span class="kw">&lt;main&gt;</span>
    <span class="co">&lt;!-- We want main content here --&gt;</span>
  <span class="kw">&lt;/main&gt;</span>
  <span class="kw">&lt;footer&gt;</span>
    <span class="co">&lt;!-- We want footer content here --&gt;</span>
  <span class="kw">&lt;/footer&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<p>For these cases, the <code>&lt;slot&gt;</code> element has a special attribute, <code>name</code>, which can be used to define additional slots:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;container&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;header&gt;</span>
    <span class="kw">&lt;slot</span><span class="ot"> name=</span><span class="st">&quot;header&quot;</span><span class="kw">&gt;&lt;/slot&gt;</span>
  <span class="kw">&lt;/header&gt;</span>
  <span class="kw">&lt;main&gt;</span>
    <span class="kw">&lt;slot&gt;&lt;/slot&gt;</span>
  <span class="kw">&lt;/main&gt;</span>
  <span class="kw">&lt;footer&gt;</span>
    <span class="kw">&lt;slot</span><span class="ot"> name=</span><span class="st">&quot;footer&quot;</span><span class="kw">&gt;&lt;/slot&gt;</span>
  <span class="kw">&lt;/footer&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<p>A <code>&lt;slot&gt;</code> outlet without <code>name</code> implicitly has the name &quot;default&quot;.</p>
<p>To provide content to named slots, we can use the <code>v-slot</code> directive on a <code>&lt;template&gt;</code>, providing the name of the slot as <code>v-slot</code>'s argument:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;base-layout&gt;</span>
  <span class="kw">&lt;template</span><span class="ot"> v-slot:header</span><span class="kw">&gt;</span>
    <span class="kw">&lt;h1&gt;</span>Here might be a page title<span class="kw">&lt;/h1&gt;</span>
  <span class="kw">&lt;/template&gt;</span>

  <span class="kw">&lt;p&gt;</span>A paragraph for the main content.<span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;p&gt;</span>And another one.<span class="kw">&lt;/p&gt;</span>

  <span class="kw">&lt;template</span><span class="ot"> v-slot:footer</span><span class="kw">&gt;</span>
    <span class="kw">&lt;p&gt;</span>Here&#39;s some contact info<span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;/template&gt;</span>
<span class="kw">&lt;/base-layout&gt;</span></code></pre></div>
<p>Now everything inside the <code>&lt;template&gt;</code> elements will be passed to the corresponding slots. Any content not wrapped in a <code>&lt;template&gt;</code> using <code>v-slot</code> is assumed to be for the default slot.</p>
<p>However, you can still wrap default slot content in a <code>&lt;template&gt;</code> if you wish to be explicit:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;base-layout&gt;</span>
  <span class="kw">&lt;template</span><span class="ot"> v-slot:header</span><span class="kw">&gt;</span>
    <span class="kw">&lt;h1&gt;</span>Here might be a page title<span class="kw">&lt;/h1&gt;</span>
  <span class="kw">&lt;/template&gt;</span>

  <span class="kw">&lt;template</span><span class="ot"> v-slot:default</span><span class="kw">&gt;</span>
    <span class="kw">&lt;p&gt;</span>A paragraph for the main content.<span class="kw">&lt;/p&gt;</span>
    <span class="kw">&lt;p&gt;</span>And another one.<span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;/template&gt;</span>

  <span class="kw">&lt;template</span><span class="ot"> v-slot:footer</span><span class="kw">&gt;</span>
    <span class="kw">&lt;p&gt;</span>Here&#39;s some contact info<span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;/template&gt;</span>
<span class="kw">&lt;/base-layout&gt;</span></code></pre></div>
<p>Either way, the rendered HTML will be:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;container&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;header&gt;</span>
    <span class="kw">&lt;h1&gt;</span>Here might be a page title<span class="kw">&lt;/h1&gt;</span>
  <span class="kw">&lt;/header&gt;</span>
  <span class="kw">&lt;main&gt;</span>
    <span class="kw">&lt;p&gt;</span>A paragraph for the main content.<span class="kw">&lt;/p&gt;</span>
    <span class="kw">&lt;p&gt;</span>And another one.<span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;/main&gt;</span>
  <span class="kw">&lt;footer&gt;</span>
    <span class="kw">&lt;p&gt;</span>Here&#39;s some contact info<span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;/footer&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<p>Note that <strong><code>v-slot</code> can only be added to a <code>&lt;template&gt;</code></strong> (with <a href="#Abbreviated-Syntax-for-Lone-Default-Slots">one exception</a>), unlike the deprecated <a href="#Deprecated-Syntax"><code>slot</code> attribute</a>.</p>
<h2 id="scoped-slots">Scoped Slots</h2>
<blockquote>
<p>Updated in 2.6.0+. <a href="#Deprecated-Syntax">See here</a> for the deprecated syntax using the <code>slot-scope</code> attribute.</p>
</blockquote>
<p>Sometimes, it's useful for slot content to have access to data only available in the child component. For example, imagine a <code>&lt;current-user&gt;</code> component with the following template:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;span&gt;</span>
  <span class="kw">&lt;slot&gt;</span>{{ user.lastName }}<span class="kw">&lt;/slot&gt;</span>
<span class="kw">&lt;/span&gt;</span></code></pre></div>
<p>We might want to replace this fallback content to display the user's first name, instead of last, like this:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;current-user&gt;</span>
  {{ user.firstName }}
<span class="kw">&lt;/current-user&gt;</span></code></pre></div>
<p>That won't work, however, because only the <code>&lt;current-user&gt;</code> component has access to the <code>user</code> and the content we're providing is rendered in the parent.</p>
<p>To make <code>user</code> available to the slot content in the parent, we can bind <code>user</code> as an attribute to the <code>&lt;slot&gt;</code> element:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;span&gt;</span>
  <span class="kw">&lt;slot</span><span class="ot"> v-bind:user=</span><span class="st">&quot;user&quot;</span><span class="kw">&gt;</span>
    {{ user.lastName }}
  <span class="kw">&lt;/slot&gt;</span>
<span class="kw">&lt;/span&gt;</span></code></pre></div>
<p>Attributes bound to a <code>&lt;slot&gt;</code> element are called <strong>slot props</strong>. Now, in the parent scope, we can use <code>v-slot</code> with a value to define a name for the slot props we've been provided:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;current-user&gt;</span>
  <span class="kw">&lt;template</span><span class="ot"> v-slot:default=</span><span class="st">&quot;slotProps&quot;</span><span class="kw">&gt;</span>
    {{ slotProps.user.firstName }}
  <span class="kw">&lt;/template&gt;</span>
<span class="kw">&lt;/current-user&gt;</span></code></pre></div>
<p>In this example, we've chosen to name the object containing all our slot props <code>slotProps</code>, but you can use any name you like.</p>
<h3 id="abbreviated-syntax-for-lone-default-slots">Abbreviated Syntax for Lone Default Slots</h3>
<p>In cases like above, when <em>only</em> the default slot is provided content, the component's tags can be used as the slot's template. This allows us to use <code>v-slot</code> directly on the component:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;current-user</span><span class="ot"> v-slot:default=</span><span class="st">&quot;slotProps&quot;</span><span class="kw">&gt;</span>
  {{ slotProps.user.firstName }}
<span class="kw">&lt;/current-user&gt;</span></code></pre></div>
<p>This can be shortened even further. Just as non-specified content is assumed to be for the default slot, <code>v-slot</code> without an argument is assumed to refer to the default slot:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;current-user</span><span class="ot"> v-slot=</span><span class="st">&quot;slotProps&quot;</span><span class="kw">&gt;</span>
  {{ slotProps.user.firstName }}
<span class="kw">&lt;/current-user&gt;</span></code></pre></div>
<p>Note that the abbreviated syntax for default slot <strong>cannot</strong> be mixed with named slots, as it would lead to scope ambiguity:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- INVALID, will result in warning --&gt;</span>
<span class="kw">&lt;current-user</span><span class="ot"> v-slot=</span><span class="st">&quot;slotProps&quot;</span><span class="kw">&gt;</span>
  {{ slotProps.user.firstName }}
  <span class="kw">&lt;template</span><span class="ot"> v-slot:other=</span><span class="st">&quot;otherSlotProps&quot;</span><span class="kw">&gt;</span>
    slotProps is NOT available here
  <span class="kw">&lt;/template&gt;</span>
<span class="kw">&lt;/current-user&gt;</span></code></pre></div>
<p>Whenever there are multiple slots, use the full <code>&lt;template&gt;</code> based syntax for <em>all</em> slots:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;current-user&gt;</span>
  <span class="kw">&lt;template</span><span class="ot"> v-slot:default=</span><span class="st">&quot;slotProps&quot;</span><span class="kw">&gt;</span>
    {{ slotProps.user.firstName }}
  <span class="kw">&lt;/template&gt;</span>

  <span class="kw">&lt;template</span><span class="ot"> v-slot:other=</span><span class="st">&quot;otherSlotProps&quot;</span><span class="kw">&gt;</span>
    ...
  <span class="kw">&lt;/template&gt;</span>
<span class="kw">&lt;/current-user&gt;</span></code></pre></div>
<h3 id="destructuring-slot-props">Destructuring Slot Props</h3>
<p>Internally, scoped slots work by wrapping your slot content in a function passed a single argument:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> (slotProps) <span class="op">{</span>
  <span class="co">// ... slot content ...</span>
<span class="op">}</span></code></pre></div>
<p>That means the value of <code>v-slot</code> can actually accept any valid JavaScript expression that can appear in the argument position of a function definition. So in supported environments (<a href="single-file-components.html">single-file components</a> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility">modern browsers</a>), you can also use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring">ES2015 destructuring</a> to pull out specific slot props, like so:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;current-user</span><span class="ot"> v-slot=</span><span class="st">&quot;{ user }&quot;</span><span class="kw">&gt;</span>
  {{ user.firstName }}
<span class="kw">&lt;/current-user&gt;</span></code></pre></div>
<p>This can make the template much cleaner, especially when the slot provides many props. It also opens other possibilities, such as renaming props, e.g. <code>user</code> to <code>person</code>:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;current-user</span><span class="ot"> v-slot=</span><span class="st">&quot;{ user: person }&quot;</span><span class="kw">&gt;</span>
  {{ person.firstName }}
<span class="kw">&lt;/current-user&gt;</span></code></pre></div>
<p>You can even define fallbacks, to be used in case a slot prop is undefined:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;current-user</span><span class="ot"> v-slot=</span><span class="st">&quot;{ user = { firstName: &#39;Guest&#39; } }&quot;</span><span class="kw">&gt;</span>
  {{ user.firstName }}
<span class="kw">&lt;/current-user&gt;</span></code></pre></div>
<h2 id="dynamic-slot-names">Dynamic Slot Names</h2>
<blockquote>
<p>New in 2.6.0+</p>
</blockquote>
<p><a href="syntax.html#Dynamic-Arguments">Dynamic directive arguments</a> also work on <code>v-slot</code>, allowing the definition of dynamic slot names:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;base-layout&gt;</span>
  <span class="kw">&lt;template</span><span class="ot"> v-slot:</span><span class="er">[dynamicSlotName]</span><span class="kw">&gt;</span>
    ...
  <span class="kw">&lt;/template&gt;</span>
<span class="kw">&lt;/base-layout&gt;</span></code></pre></div>
<h2 id="named-slots-shorthand">Named Slots Shorthand</h2>
<blockquote>
<p>New in 2.6.0+</p>
</blockquote>
<p>Similar to <code>v-on</code> and <code>v-bind</code>, <code>v-slot</code> also has a shorthand, replacing everything before the argument (<code>v-slot:</code>) with the special symbol <code>#</code>. For example, <code>v-slot:header</code> can be rewritten as <code>#header</code>:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;base-layout&gt;</span>
  <span class="kw">&lt;template</span><span class="ot"> #header</span><span class="kw">&gt;</span>
    <span class="kw">&lt;h1&gt;</span>Here might be a page title<span class="kw">&lt;/h1&gt;</span>
  <span class="kw">&lt;/template&gt;</span>

  <span class="kw">&lt;p&gt;</span>A paragraph for the main content.<span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;p&gt;</span>And another one.<span class="kw">&lt;/p&gt;</span>

  <span class="kw">&lt;template</span><span class="ot"> #footer</span><span class="kw">&gt;</span>
    <span class="kw">&lt;p&gt;</span>Here&#39;s some contact info<span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;/template&gt;</span>
<span class="kw">&lt;/base-layout&gt;</span></code></pre></div>
<p>However, just as with other directives, the shorthand is only available when an argument is provided. That means the following syntax is invalid:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- This will trigger a warning --&gt;</span>
<span class="kw">&lt;current-user</span><span class="ot"> #=</span><span class="st">&quot;{ user }&quot;</span><span class="kw">&gt;</span>
  {{ user.firstName }}
<span class="kw">&lt;/current-user&gt;</span></code></pre></div>
<p>Instead, you must always specify the name of the slot if you wish to use the shorthand:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;current-user</span><span class="ot"> #default=</span><span class="st">&quot;{ user }&quot;</span><span class="kw">&gt;</span>
  {{ user.firstName }}
<span class="kw">&lt;/current-user&gt;</span></code></pre></div>
<h2 id="other-examples">Other Examples</h2>
<p><strong>Slot props allow us to turn slots into reusable templates that can render different content based on input props.</strong> This is most useful when you are designing a reusable component that encapsulates data logic while allowing the consuming parent component to customize part of its layout.</p>
<p>For example, we are implementing a <code>&lt;todo-list&gt;</code> component that contains the layout and filtering logic for a list:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;ul&gt;</span>
  <span class="kw">&lt;li</span>
<span class="ot">    v-for=</span><span class="st">&quot;todo in filteredTodos&quot;</span>
<span class="ot">    v-bind:key=</span><span class="st">&quot;todo.id&quot;</span>
  <span class="kw">&gt;</span>
    {{ todo.text }}
  <span class="kw">&lt;/li&gt;</span>
<span class="kw">&lt;/ul&gt;</span></code></pre></div>
<p>Instead of hard-coding the content for each todo, we can let the parent component take control by making every todo a slot, then binding <code>todo</code> as a slot prop:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;ul&gt;</span>
  <span class="kw">&lt;li</span>
<span class="ot">    v-for=</span><span class="st">&quot;todo in filteredTodos&quot;</span>
<span class="ot">    v-bind:key=</span><span class="st">&quot;todo.id&quot;</span>
  <span class="kw">&gt;</span>
    <span class="co">&lt;!--</span>
<span class="co">    We have a slot for each todo, passing it the</span>
<span class="co">    `todo` object as a slot prop.</span>
<span class="co">    --&gt;</span>
    <span class="kw">&lt;slot</span><span class="ot"> name=</span><span class="st">&quot;todo&quot;</span><span class="ot"> v-bind:todo=</span><span class="st">&quot;todo&quot;</span><span class="kw">&gt;</span>
      <span class="co">&lt;!-- Fallback content --&gt;</span>
      {{ todo.text }}
    <span class="kw">&lt;/slot&gt;</span>
  <span class="kw">&lt;/li&gt;</span>
<span class="kw">&lt;/ul&gt;</span></code></pre></div>
<p>Now when we use the <code>&lt;todo-list&gt;</code> component, we can optionally define an alternative <code>&lt;template&gt;</code> for todo items, but with access to data from the child:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;todo-list</span><span class="ot"> v-bind:todos=</span><span class="st">&quot;todos&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;template</span><span class="ot"> v-slot:todo=</span><span class="st">&quot;{ todo }&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;span</span><span class="ot"> v-if=</span><span class="st">&quot;todo.isComplete&quot;</span><span class="kw">&gt;</span>✓<span class="kw">&lt;/span&gt;</span>
    {{ todo.text }}
  <span class="kw">&lt;/template&gt;</span>
<span class="kw">&lt;/todo-list&gt;</span></code></pre></div>
<p>However, even this barely scratches the surface of what scoped slots are capable of. For real-life, powerful examples of scoped slot usage, we recommend browsing libraries such as <a href="https://github.com/Akryum/vue-virtual-scroller">Vue Virtual Scroller</a>, <a href="https://github.com/posva/vue-promised">Vue Promised</a>, and <a href="https://github.com/LinusBorg/portal-vue">Portal Vue</a>.</p>
<h2 id="deprecated-syntax">Deprecated Syntax</h2>
<blockquote>
<p>The <code>v-slot</code> directive was introduced in Vue 2.6.0, offering an improved, alternative API to the still-supported <code>slot</code> and <code>slot-scope</code> attributes. The full rationale for introducing <code>v-slot</code> is described in this <a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md">RFC</a>. The <code>slot</code> and <code>slot-scope</code> attributes will continue to be supported in all future 2.x releases, but are officially deprecated and will eventually be removed in Vue 3.</p>
</blockquote>
<h3 id="named-slots-with-the-slot-attribute">Named Slots with the <code>slot</code> Attribute</h3>
<blockquote>
<p><abbr title="Still supported in all 2.x versions of Vue, but no longer recommended.">Deprecated</abbr> in 2.6.0+. See <a href="#Named-Slots">here</a> for the new, recommended syntax.</p>
</blockquote>
<p>To pass content to named slots from the parent, use the special <code>slot</code> attribute on <code>&lt;template&gt;</code> (using the <code>&lt;base-layout&gt;</code> component described <a href="#Named-Slots">here</a> as example):</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;base-layout&gt;</span>
  <span class="kw">&lt;template</span><span class="ot"> slot=</span><span class="st">&quot;header&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;h1&gt;</span>Here might be a page title<span class="kw">&lt;/h1&gt;</span>
  <span class="kw">&lt;/template&gt;</span>

  <span class="kw">&lt;p&gt;</span>A paragraph for the main content.<span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;p&gt;</span>And another one.<span class="kw">&lt;/p&gt;</span>

  <span class="kw">&lt;template</span><span class="ot"> slot=</span><span class="st">&quot;footer&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;p&gt;</span>Here&#39;s some contact info<span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;/template&gt;</span>
<span class="kw">&lt;/base-layout&gt;</span></code></pre></div>
<p>Or, the <code>slot</code> attribute can also be used directly on a normal element:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;base-layout&gt;</span>
  <span class="kw">&lt;h1</span><span class="ot"> slot=</span><span class="st">&quot;header&quot;</span><span class="kw">&gt;</span>Here might be a page title<span class="kw">&lt;/h1&gt;</span>

  <span class="kw">&lt;p&gt;</span>A paragraph for the main content.<span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;p&gt;</span>And another one.<span class="kw">&lt;/p&gt;</span>

  <span class="kw">&lt;p</span><span class="ot"> slot=</span><span class="st">&quot;footer&quot;</span><span class="kw">&gt;</span>Here&#39;s some contact info<span class="kw">&lt;/p&gt;</span>
<span class="kw">&lt;/base-layout&gt;</span></code></pre></div>
<p>There can still be one unnamed slot, which is the <strong>default slot</strong> that serves as a catch-all for any unmatched content. In both examples above, the rendered HTML would be:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;container&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;header&gt;</span>
    <span class="kw">&lt;h1&gt;</span>Here might be a page title<span class="kw">&lt;/h1&gt;</span>
  <span class="kw">&lt;/header&gt;</span>
  <span class="kw">&lt;main&gt;</span>
    <span class="kw">&lt;p&gt;</span>A paragraph for the main content.<span class="kw">&lt;/p&gt;</span>
    <span class="kw">&lt;p&gt;</span>And another one.<span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;/main&gt;</span>
  <span class="kw">&lt;footer&gt;</span>
    <span class="kw">&lt;p&gt;</span>Here&#39;s some contact info<span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;/footer&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<h3 id="scoped-slots-with-the-slot-scope-attribute">Scoped Slots with the <code>slot-scope</code> Attribute</h3>
<blockquote>
<p><abbr title="Still supported in all 2.x versions of Vue, but no longer recommended.">Deprecated</abbr> in 2.6.0+. See <a href="#Scoped-Slots">here</a> for the new, recommended syntax.</p>
</blockquote>
<p>To receive props passed to a slot, the parent component can use <code>&lt;template&gt;</code> with the <code>slot-scope</code> attribute (using the <code>&lt;slot-example&gt;</code> described <a href="#Scoped-Slots">here</a> as example):</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;slot-example&gt;</span>
  <span class="kw">&lt;template</span><span class="ot"> slot=</span><span class="st">&quot;default&quot;</span><span class="ot"> slot-scope=</span><span class="st">&quot;slotProps&quot;</span><span class="kw">&gt;</span>
    {{ slotProps.msg }}
  <span class="kw">&lt;/template&gt;</span>
<span class="kw">&lt;/slot-example&gt;</span></code></pre></div>
<p>Here, <code>slot-scope</code> declares the received props object as the <code>slotProps</code> variable, and makes it available inside the <code>&lt;template&gt;</code> scope. You can name <code>slotProps</code> anything you like similar to naming function arguments in JavaScript.</p>
<p>Here <code>slot=&quot;default&quot;</code> can be omitted as it is implied:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;slot-example&gt;</span>
  <span class="kw">&lt;template</span><span class="ot"> slot-scope=</span><span class="st">&quot;slotProps&quot;</span><span class="kw">&gt;</span>
    {{ slotProps.msg }}
  <span class="kw">&lt;/template&gt;</span>
<span class="kw">&lt;/slot-example&gt;</span></code></pre></div>
<p>The <code>slot-scope</code> attribute can also be used directly on a non-<code>&lt;template&gt;</code> element (including components):</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;slot-example&gt;</span>
  <span class="kw">&lt;span</span><span class="ot"> slot-scope=</span><span class="st">&quot;slotProps&quot;</span><span class="kw">&gt;</span>
    {{ slotProps.msg }}
  <span class="kw">&lt;/span&gt;</span>
<span class="kw">&lt;/slot-example&gt;</span></code></pre></div>
<p>The value of <code>slot-scope</code> can accept any valid JavaScript expression that can appear in the argument position of a function definition. This means in supported environments (<a href="single-file-components.html">single-file components</a> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility">modern browsers</a>) you can also use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring">ES2015 destructuring</a> in the expression, like so:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;slot-example&gt;</span>
  <span class="kw">&lt;span</span><span class="ot"> slot-scope=</span><span class="st">&quot;{ msg }&quot;</span><span class="kw">&gt;</span>
    {{ msg }}
  <span class="kw">&lt;/span&gt;</span>
<span class="kw">&lt;/slot-example&gt;</span></code></pre></div>
<p>Using the <code>&lt;todo-list&gt;</code> described <a href="#Other-Examples">here</a> as an example, here's the equivalent usage using <code>slot-scope</code>:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;todo-list</span><span class="ot"> v-bind:todos=</span><span class="st">&quot;todos&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;template</span><span class="ot"> slot=</span><span class="st">&quot;todo&quot;</span><span class="ot"> slot-scope=</span><span class="st">&quot;{ todo }&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;span</span><span class="ot"> v-if=</span><span class="st">&quot;todo.isComplete&quot;</span><span class="kw">&gt;</span>✓<span class="kw">&lt;/span&gt;</span>
    {{ todo.text }}
  <span class="kw">&lt;/template&gt;</span>
<span class="kw">&lt;/todo-list&gt;</span></code></pre></div>
<h1 id="dynamic-async-components"><a name=#guide/components-dynamic-async.md></a>Dynamic &amp; Async Components</h1>
<blockquote>
<p>This page assumes you've already read the <a href="components.html">Components Basics</a>. Read that first if you are new to components.</p>
</blockquote>
<h2 id="keep-alive-with-dynamic-components"><code>keep-alive</code> with Dynamic Components</h2>
<p>Earlier, we used the <code>is</code> attribute to switch between components in a tabbed interface:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;component</span><span class="ot"> v-bind:is=</span><span class="st">&quot;currentTabComponent&quot;</span><span class="kw">&gt;&lt;/component&gt;</span></code></pre></div>
<p>When switching between these components though, you'll sometimes want to maintain their state or avoid re-rendering for performance reasons. For example, when expanding our tabbed interface a little:</p>
<p>You'll notice that if you select a post, switch to the <em>Archive</em> tab, then switch back to <em>Posts</em>, it's no longer showing the post you selected. That's because each time you switch to a new tab, Vue creates a new instance of the <code>currentTabComponent</code>.</p>
<p>Recreating dynamic components is normally useful behavior, but in this case, we'd really like those tab component instances to be cached once they're created for the first time. To solve this problem, we can wrap our dynamic component with a <code>&lt;keep-alive&gt;</code> element:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- Inactive components will be cached! --&gt;</span>
<span class="kw">&lt;keep-alive&gt;</span>
  <span class="kw">&lt;component</span><span class="ot"> v-bind:is=</span><span class="st">&quot;currentTabComponent&quot;</span><span class="kw">&gt;&lt;/component&gt;</span>
<span class="kw">&lt;/keep-alive&gt;</span></code></pre></div>
<p>Check out the result below:</p>
<p>Now the <em>Posts</em> tab maintains its state (the selected post) even when it's not rendered. See <a href="https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-keep-alive-with-dynamic-components">this example</a> for the complete code.</p>
<p class="tip">
Note that <code>&lt;keep-alive&gt;</code> requires the components being switched between to all have names, either using the <code>name</code> option on a component, or through local/global registration.
</p>
<p>Check out more details on <code>&lt;keep-alive&gt;</code> in the <a href="../api/#keep-alive">API reference</a>.</p>
<h2 id="async-components">Async Components</h2>
<div class="vueschool">
<a href="https://vueschool.io/lessons/dynamically-load-components?friend=vuejs" target="_blank" rel="sponsored noopener" title="Free Vue.js Async Components lesson">Watch a free video lesson on Vue School</a>
</div>
<p>In large applications, we may need to divide the app into smaller chunks and only load a component from the server when it's needed. To make that easier, Vue allows you to define your component as a factory function that asynchronously resolves your component definition. Vue will only trigger the factory function when the component needs to be rendered and will cache the result for future re-renders. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;async-example&#39;</span><span class="op">,</span> <span class="kw">function</span> (resolve<span class="op">,</span> reject) <span class="op">{</span>
  <span class="at">setTimeout</span>(<span class="kw">function</span> () <span class="op">{</span>
    <span class="co">// Pass the component definition to the resolve callback</span>
    <span class="at">resolve</span>(<span class="op">{</span>
      <span class="dt">template</span><span class="op">:</span> <span class="st">&#39;&lt;div&gt;I am async!&lt;/div&gt;&#39;</span>
    <span class="op">}</span>)
  <span class="op">},</span> <span class="dv">1000</span>)
<span class="op">}</span>)</code></pre></div>
<p>As you can see, the factory function receives a <code>resolve</code> callback, which should be called when you have retrieved your component definition from the server. You can also call <code>reject(reason)</code> to indicate the load has failed. The <code>setTimeout</code> here is for demonstration; how to retrieve the component is up to you. One recommended approach is to use async components together with <a href="https://webpack.js.org/guides/code-splitting/">Webpack's code-splitting feature</a>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;async-webpack-example&#39;</span><span class="op">,</span> <span class="kw">function</span> (resolve) <span class="op">{</span>
  <span class="co">// This special require syntax will instruct Webpack to</span>
  <span class="co">// automatically split your built code into bundles which</span>
  <span class="co">// are loaded over Ajax requests.</span>
  <span class="at">require</span>([<span class="st">&#39;./my-async-component&#39;</span>]<span class="op">,</span> resolve)
<span class="op">}</span>)</code></pre></div>
<p>You can also return a <code>Promise</code> in the factory function, so with Webpack 2 and ES2015 syntax you can make use of dynamic imports:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(
  <span class="st">&#39;async-webpack-example&#39;</span><span class="op">,</span>
  <span class="co">// A dynamic import returns a Promise.</span>
  () <span class="op">=&gt;</span> <span class="im">import</span>(<span class="st">&#39;./my-async-component&#39;</span>)
)</code></pre></div>
<p>When using <a href="components-registration.html#Local-Registration">local registration</a>, you can also directly provide a function that returns a <code>Promise</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="co">// ...</span>
  <span class="dt">components</span><span class="op">:</span> <span class="op">{</span>
    <span class="st">&#39;my-component&#39;</span><span class="op">:</span> () <span class="op">=&gt;</span> <span class="im">import</span>(<span class="st">&#39;./my-async-component&#39;</span>)
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p class="tip">
If you're a <strong>Browserify</strong> user that would like to use async components, its creator has unfortunately <a href="https://github.com/substack/node-browserify/issues/58#issuecomment-21978224">made it clear</a> that async loading &quot;is not something that Browserify will ever support.&quot; Officially, at least. The Browserify community has found <a href="https://github.com/vuejs/vuejs.org/issues/620">some workarounds</a>, which may be helpful for existing and complex applications. For all other scenarios, we recommend using Webpack for built-in, first-class async support.
</p>
<h3 id="handling-loading-state">Handling Loading State</h3>
<blockquote>
<p>New in 2.3.0+</p>
</blockquote>
<p>The async component factory can also return an object of the following format:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">const</span> AsyncComponent <span class="op">=</span> () <span class="op">=&gt;</span> (<span class="op">{</span>
  <span class="co">// The component to load (should be a Promise)</span>
  <span class="dt">component</span><span class="op">:</span> <span class="im">import</span>(<span class="st">&#39;./MyComponent.vue&#39;</span>)<span class="op">,</span>
  <span class="co">// A component to use while the async component is loading</span>
  <span class="dt">loading</span><span class="op">:</span> LoadingComponent<span class="op">,</span>
  <span class="co">// A component to use if the load fails</span>
  <span class="dt">error</span><span class="op">:</span> ErrorComponent<span class="op">,</span>
  <span class="co">// Delay before showing the loading component. Default: 200ms.</span>
  <span class="dt">delay</span><span class="op">:</span> <span class="dv">200</span><span class="op">,</span>
  <span class="co">// The error component will be displayed if a timeout is</span>
  <span class="co">// provided and exceeded. Default: Infinity.</span>
  <span class="dt">timeout</span><span class="op">:</span> <span class="dv">3000</span>
<span class="op">}</span>)</code></pre></div>
<blockquote>
<p>Note that you must use <a href="https://github.com/vuejs/vue-router">Vue Router</a> 2.4.0+ if you wish to use the above syntax for route components.</p>
</blockquote>
<h1 id="handling-edge-cases"><a name=#guide/components-edge-cases.md></a>Handling Edge Cases</h1>
<blockquote>
<p>This page assumes you've already read the <a href="components.html">Components Basics</a>. Read that first if you are new to components.</p>
</blockquote>
<p class="tip">
All the features on this page document the handling of edge cases, meaning unusual situations that sometimes require bending Vue's rules a little. Note however, that they all have disadvantages or situations where they could be dangerous. These are noted in each case, so keep them in mind when deciding to use each feature.
</p>
<h2 id="element-component-access">Element &amp; Component Access</h2>
<p>In most cases, it's best to avoid reaching into other component instances or manually manipulating DOM elements. There are cases, however, when it can be appropriate.</p>
<h3 id="accessing-the-root-instance">Accessing the Root Instance</h3>
<p>In every subcomponent of a <code>new Vue</code> instance, this root instance can be accessed with the <code>$root</code> property. For example, in this root instance:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// The root Vue instance</span>
<span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">foo</span><span class="op">:</span> <span class="dv">1</span>
  <span class="op">},</span>
  <span class="dt">computed</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">bar</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span>
  <span class="op">},</span>
  <span class="dt">methods</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">baz</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>All subcomponents will now be able to access this instance and use it as a global store:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// Get root data</span>
<span class="kw">this</span>.<span class="va">$root</span>.<span class="at">foo</span>

<span class="co">// Set root data</span>
<span class="kw">this</span>.<span class="va">$root</span>.<span class="at">foo</span> <span class="op">=</span> <span class="dv">2</span>

<span class="co">// Access root computed properties</span>
<span class="kw">this</span>.<span class="va">$root</span>.<span class="at">bar</span>

<span class="co">// Call root methods</span>
<span class="kw">this</span>.<span class="va">$root</span>.<span class="at">baz</span>()</code></pre></div>
<p class="tip">
This can be convenient for demos or very small apps with a handful of components. However, the pattern does not scale well to medium or large-scale applications, so we strongly recommend using <a href="https://github.com/vuejs/vuex">Vuex</a> to manage state in most cases.
</p>
<h3 id="accessing-the-parent-component-instance">Accessing the Parent Component Instance</h3>
<p>Similar to <code>$root</code>, the <code>$parent</code> property can be used to access the parent instance from a child. This can be tempting to reach for as a lazy alternative to passing data with a prop.</p>
<p class="tip">
In most cases, reaching into the parent makes your application more difficult to debug and understand, especially if you mutate data in the parent. When looking at that component later, it will be very difficult to figure out where that mutation came from.
</p>
<p>There are cases however, particularly shared component libraries, when this <em>might</em> be appropriate. For example, in abstract components that interact with JavaScript APIs instead of rendering HTML, like these hypothetical Google Maps components:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;google-map&gt;</span>
  <span class="kw">&lt;google-map-markers</span><span class="ot"> v-bind:places=</span><span class="st">&quot;iceCreamShops&quot;</span><span class="kw">&gt;&lt;/google-map-markers&gt;</span>
<span class="kw">&lt;/google-map&gt;</span></code></pre></div>
<p>The <code>&lt;google-map&gt;</code> component might define a <code>map</code> property that all subcomponents need access to. In this case <code>&lt;google-map-markers&gt;</code> might want to access that map with something like <code>this.$parent.getMap</code>, in order to add a set of markers to it. You can see this pattern <a href="https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-accessing-parent-component-instance">in action here</a>.</p>
<p>Keep in mind, however, that components built with this pattern are still inherently fragile. For example, imagine we add a new <code>&lt;google-map-region&gt;</code> component and when <code>&lt;google-map-markers&gt;</code> appears within that, it should only render markers that fall within that region:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;google-map&gt;</span>
  <span class="kw">&lt;google-map-region</span><span class="ot"> v-bind:shape=</span><span class="st">&quot;cityBoundaries&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;google-map-markers</span><span class="ot"> v-bind:places=</span><span class="st">&quot;iceCreamShops&quot;</span><span class="kw">&gt;&lt;/google-map-markers&gt;</span>
  <span class="kw">&lt;/google-map-region&gt;</span>
<span class="kw">&lt;/google-map&gt;</span></code></pre></div>
<p>Then inside <code>&lt;google-map-markers&gt;</code> you might find yourself reaching for a hack like this:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> map <span class="op">=</span> <span class="kw">this</span>.<span class="va">$parent</span>.<span class="at">map</span> <span class="op">||</span> <span class="kw">this</span>.<span class="va">$parent</span>.<span class="va">$parent</span>.<span class="at">map</span></code></pre></div>
<p>This has quickly gotten out of hand. That's why to provide context information to descendent components arbitrarily deep, we instead recommend <a href="#Dependency-Injection">dependency injection</a>.</p>
<h3 id="accessing-child-component-instances-child-elements">Accessing Child Component Instances &amp; Child Elements</h3>
<p>Despite the existence of props and events, sometimes you might still need to directly access a child component in JavaScript. To achieve this you can assign a reference ID to the child component using the <code>ref</code> attribute. For example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;base-input</span><span class="ot"> ref=</span><span class="st">&quot;usernameInput&quot;</span><span class="kw">&gt;&lt;/base-input&gt;</span></code></pre></div>
<p>Now in the component where you've defined this <code>ref</code>, you can use:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">this</span>.<span class="va">$refs</span>.<span class="at">usernameInput</span></code></pre></div>
<p>to access the <code>&lt;base-input&gt;</code> instance. This may be useful when you want to, for example, programmatically focus this input from a parent. In that case, the <code>&lt;base-input&gt;</code> component may similarly use a <code>ref</code> to provide access to specific elements inside it, such as:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;input</span><span class="ot"> ref=</span><span class="st">&quot;input&quot;</span><span class="kw">&gt;</span></code></pre></div>
<p>And even define methods for use by the parent:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">methods<span class="op">:</span> <span class="op">{</span>
  <span class="co">// Used to focus the input from the parent</span>
  <span class="dt">focus</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="kw">this</span>.<span class="va">$refs</span>.<span class="va">input</span>.<span class="at">focus</span>()
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>Thus allowing the parent component to focus the input inside <code>&lt;base-input&gt;</code> with:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">this</span>.<span class="va">$refs</span>.<span class="va">usernameInput</span>.<span class="at">focus</span>()</code></pre></div>
<p>When <code>ref</code> is used together with <code>v-for</code>, the ref you get will be an array containing the child components mirroring the data source.</p>
<p class="tip">
<code><span class="math inline"><em>r</em><em>e</em><em>f</em><em>s</em> &lt; /<em>c</em><em>o</em><em>d</em><em>e</em> &gt; <em>a</em><em>r</em><em>e</em><em>o</em><em>n</em><em>l</em><em>y</em><em>p</em><em>o</em><em>p</em><em>u</em><em>l</em><em>a</em><em>t</em><em>e</em><em>d</em><em>a</em><em>f</em><em>t</em><em>e</em><em>r</em><em>t</em><em>h</em><em>e</em><em>c</em><em>o</em><em>m</em><em>p</em><em>o</em><em>n</em><em>e</em><em>n</em><em>t</em><em>h</em><em>a</em><em>s</em><em>b</em><em>e</em><em>e</em><em>n</em><em>r</em><em>e</em><em>n</em><em>d</em><em>e</em><em>r</em><em>e</em><em>d</em>, <em>a</em><em>n</em><em>d</em><em>t</em><em>h</em><em>e</em><em>y</em><em>a</em><em>r</em><em>e</em><em>n</em><em>o</em><em>t</em><em>r</em><em>e</em><em>a</em><em>c</em><em>t</em><em>i</em><em>v</em><em>e</em>.<em>I</em><em>t</em><em>i</em><em>s</em><em>o</em><em>n</em><em>l</em><em>y</em><em>m</em><em>e</em><em>a</em><em>n</em><em>t</em><em>a</em><em>s</em><em>a</em><em>n</em><em>e</em><em>s</em><em>c</em><em>a</em><em>p</em><em>e</em><em>h</em><em>a</em><em>t</em><em>c</em><em>h</em><em>f</em><em>o</em><em>r</em><em>d</em><em>i</em><em>r</em><em>e</em><em>c</em><em>t</em><em>c</em><em>h</em><em>i</em><em>l</em><em>d</em><em>m</em><em>a</em><em>n</em><em>i</em><em>p</em><em>u</em><em>l</em><em>a</em><em>t</em><em>i</em><em>o</em><em>n</em> − <em>y</em><em>o</em><em>u</em><em>s</em><em>h</em><em>o</em><em>u</em><em>l</em><em>d</em><em>a</em><em>v</em><em>o</em><em>i</em><em>d</em><em>a</em><em>c</em><em>c</em><em>e</em><em>s</em><em>s</em><em>i</em><em>n</em><em>g</em> &lt; <em>c</em><em>o</em><em>d</em><em>e</em>&gt;</span>refs</code> from within templates or computed properties.
</p>
<h3 id="dependency-injection">Dependency Injection</h3>
<p>Earlier, when we described <a href="#Accessing-the-Parent-Component-Instance">Accessing the Parent Component Instance</a>, we showed an example like this:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;google-map&gt;</span>
  <span class="kw">&lt;google-map-region</span><span class="ot"> v-bind:shape=</span><span class="st">&quot;cityBoundaries&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;google-map-markers</span><span class="ot"> v-bind:places=</span><span class="st">&quot;iceCreamShops&quot;</span><span class="kw">&gt;&lt;/google-map-markers&gt;</span>
  <span class="kw">&lt;/google-map-region&gt;</span>
<span class="kw">&lt;/google-map&gt;</span></code></pre></div>
<p>In this component, all descendants of <code>&lt;google-map&gt;</code> needed access to a <code>getMap</code> method, in order to know which map to interact with. Unfortunately, using the <code>$parent</code> property didn't scale well to more deeply nested components. That's where dependency injection can be useful, using two new instance options: <code>provide</code> and <code>inject</code>.</p>
<p>The <code>provide</code> options allows us to specify the data/methods we want to <strong>provide</strong> to descendent components. In this case, that's the <code>getMap</code> method inside <code>&lt;google-map&gt;</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">provide<span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
  <span class="cf">return</span> <span class="op">{</span>
    <span class="dt">getMap</span><span class="op">:</span> <span class="kw">this</span>.<span class="at">getMap</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>Then in any descendants, we can use the <code>inject</code> option to receive specific properties we'd like to add to that instance:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">inject<span class="op">:</span> [<span class="st">&#39;getMap&#39;</span>]</code></pre></div>
<p>You can see the <a href="https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-dependency-injection">full example here</a>. The advantage over using <code>$parent</code> is that we can access <code>getMap</code> in <em>any</em> descendant component, without exposing the entire instance of <code>&lt;google-map&gt;</code>. This allows us to more safely keep developing that component, without fear that we might change/remove something that a child component is relying on. The interface between these components remains clearly defined, just as with <code>props</code>.</p>
<p>In fact, you can think of dependency injection as sort of &quot;long-range props&quot;, except:</p>
<ul>
<li>ancestor components don't need to know which descendants use the properties it provides</li>
<li>descendant components don't need to know where injected properties are coming from</li>
</ul>
<p class="tip">
However, there are downsides to dependency injection. It couples components in your application to the way they're currently organized, making refactoring more difficult. Provided properties are also not reactive. This is by design, because using them to create a central data store scales just as poorly as <a href="#Accessing-the-Root-Instance">using <code>$root</code></a> for the same purpose. If the properties you want to share are specific to your app, rather than generic, or if you ever want to update provided data inside ancestors, then that's a good sign that you probably need a real state management solution like <a href="https://github.com/vuejs/vuex">Vuex</a> instead.
</p>
<p>Learn more about dependency injection in <a href="https://vuejs.org/v2/api/#provide-inject">the API doc</a>.</p>
<h2 id="programmatic-event-listeners">Programmatic Event Listeners</h2>
<p>So far, you've seen uses of <code>$emit</code>, listened to with <code>v-on</code>, but Vue instances also offer other methods in its events interface. We can:</p>
<ul>
<li>Listen for an event with <code>$on(eventName, eventHandler)</code></li>
<li>Listen for an event only once with <code>$once(eventName, eventHandler)</code></li>
<li>Stop listening for an event with <code>$off(eventName, eventHandler)</code></li>
</ul>
<p>You normally won't have to use these, but they're available for cases when you need to manually listen for events on a component instance. They can also be useful as a code organization tool. For example, you may often see this pattern for integrating a 3rd-party library:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// Attach the datepicker to an input once</span>
<span class="co">// it&#39;s mounted to the DOM.</span>
mounted<span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
  <span class="co">// Pikaday is a 3rd-party datepicker library</span>
  <span class="kw">this</span>.<span class="at">picker</span> <span class="op">=</span> <span class="kw">new</span> <span class="at">Pikaday</span>(<span class="op">{</span>
    <span class="dt">field</span><span class="op">:</span> <span class="kw">this</span>.<span class="va">$refs</span>.<span class="at">input</span><span class="op">,</span>
    <span class="dt">format</span><span class="op">:</span> <span class="st">&#39;YYYY-MM-DD&#39;</span>
  <span class="op">}</span>)
<span class="op">},</span>
<span class="co">// Right before the component is destroyed,</span>
<span class="co">// also destroy the datepicker.</span>
beforeDestroy<span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
  <span class="kw">this</span>.<span class="va">picker</span>.<span class="at">destroy</span>()
<span class="op">}</span></code></pre></div>
<p>This has two potential issues:</p>
<ul>
<li>It requires saving the <code>picker</code> to the component instance, when it's possible that only lifecycle hooks need access to it. This isn't terrible, but it could be considered clutter.</li>
<li>Our setup code is kept separate from our cleanup code, making it more difficult to programmatically clean up anything we set up.</li>
</ul>
<p>You could resolve both issues with a programmatic listener:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">mounted<span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
  <span class="kw">var</span> picker <span class="op">=</span> <span class="kw">new</span> <span class="at">Pikaday</span>(<span class="op">{</span>
    <span class="dt">field</span><span class="op">:</span> <span class="kw">this</span>.<span class="va">$refs</span>.<span class="at">input</span><span class="op">,</span>
    <span class="dt">format</span><span class="op">:</span> <span class="st">&#39;YYYY-MM-DD&#39;</span>
  <span class="op">}</span>)

  <span class="kw">this</span>.<span class="at">$once</span>(<span class="st">&#39;hook:beforeDestroy&#39;</span><span class="op">,</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="va">picker</span>.<span class="at">destroy</span>()
  <span class="op">}</span>)
<span class="op">}</span></code></pre></div>
<p>Using this strategy, we could even use Pikaday with several input elements, with each new instance automatically cleaning up after itself:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">mounted<span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
  <span class="kw">this</span>.<span class="at">attachDatepicker</span>(<span class="st">&#39;startDateInput&#39;</span>)
  <span class="kw">this</span>.<span class="at">attachDatepicker</span>(<span class="st">&#39;endDateInput&#39;</span>)
<span class="op">},</span>
methods<span class="op">:</span> <span class="op">{</span>
  <span class="dt">attachDatepicker</span><span class="op">:</span> <span class="kw">function</span> (refName) <span class="op">{</span>
    <span class="kw">var</span> picker <span class="op">=</span> <span class="kw">new</span> <span class="at">Pikaday</span>(<span class="op">{</span>
      <span class="dt">field</span><span class="op">:</span> <span class="kw">this</span>.<span class="at">$refs</span>[refName]<span class="op">,</span>
      <span class="dt">format</span><span class="op">:</span> <span class="st">&#39;YYYY-MM-DD&#39;</span>
    <span class="op">}</span>)

    <span class="kw">this</span>.<span class="at">$once</span>(<span class="st">&#39;hook:beforeDestroy&#39;</span><span class="op">,</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="va">picker</span>.<span class="at">destroy</span>()
    <span class="op">}</span>)
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>See <a href="https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-programmatic-event-listeners">this example</a> for the full code. Note, however, that if you find yourself having to do a lot of setup and cleanup within a single component, the best solution will usually be to create more modular components. In this case, we'd recommend creating a reusable <code>&lt;input-datepicker&gt;</code> component.</p>
<p>To learn more about programmatic listeners, check out the API for <a href="https://vuejs.org/v2/api/#Instance-Methods-Events">Events Instance Methods</a>.</p>
<p class="tip">
Note that Vue's event system is different from the browser's <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget">EventTarget API</a>. Though they work similarly, <code><span class="math inline"><em>e</em><em>m</em><em>i</em><em>t</em> &lt; /<em>c</em><em>o</em><em>d</em><em>e</em> &gt; , &lt; <em>c</em><em>o</em><em>d</em><em>e</em>&gt;</span>on</code>, and <code>$off</code> are <strong>not</strong> aliases for <code>dispatchEvent</code>, <code>addEventListener</code>, and <code>removeEventListener</code>.
</p>
<h2 id="circular-references">Circular References</h2>
<h3 id="recursive-components">Recursive Components</h3>
<p>Components can recursively invoke themselves in their own template. However, they can only do so with the <code>name</code> option:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">name<span class="op">:</span> <span class="st">&#39;unique-name-of-my-component&#39;</span></code></pre></div>
<p>When you register a component globally using <code>Vue.component</code>, the global ID is automatically set as the component's <code>name</code> option.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;unique-name-of-my-component&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="co">// ...</span>
<span class="op">}</span>)</code></pre></div>
<p>If you're not careful, recursive components can also lead to infinite loops:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">name<span class="op">:</span> <span class="st">&#39;stack-overflow&#39;</span><span class="op">,</span>
template<span class="op">:</span> <span class="st">&#39;&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;&#39;</span></code></pre></div>
<p>A component like the above will result in a &quot;max stack size exceeded&quot; error, so make sure recursive invocation is conditional (i.e. uses a <code>v-if</code> that will eventually be <code>false</code>).</p>
<h3 id="circular-references-between-components">Circular References Between Components</h3>
<p>Let's say you're building a file directory tree, like in Finder or File Explorer. You might have a <code>tree-folder</code> component with this template:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;p&gt;</span>
  <span class="kw">&lt;span&gt;</span>{{ folder.name }}<span class="kw">&lt;/span&gt;</span>
  <span class="kw">&lt;tree-folder-contents</span><span class="ot"> :children=</span><span class="st">&quot;folder.children&quot;</span><span class="kw">/&gt;</span>
<span class="kw">&lt;/p&gt;</span></code></pre></div>
<p>Then a <code>tree-folder-contents</code> component with this template:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;ul&gt;</span>
  <span class="kw">&lt;li</span><span class="ot"> v-for=</span><span class="st">&quot;child in children&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;tree-folder</span><span class="ot"> v-if=</span><span class="st">&quot;child.children&quot;</span><span class="ot"> :folder=</span><span class="st">&quot;child&quot;</span><span class="kw">/&gt;</span>
    <span class="kw">&lt;span</span><span class="ot"> v-else</span><span class="kw">&gt;</span>{{ child.name }}<span class="kw">&lt;/span&gt;</span>
  <span class="kw">&lt;/li&gt;</span>
<span class="kw">&lt;/ul&gt;</span></code></pre></div>
<p>When you look closely, you'll see that these components will actually be each other's descendent <em>and</em> ancestor in the render tree - a paradox! When registering components globally with <code>Vue.component</code>, this paradox is resolved for you automatically. If that's you, you can stop reading here.</p>
<p>However, if you're requiring/importing components using a <strong>module system</strong>, e.g. via Webpack or Browserify, you'll get an error:</p>
<pre><code>Failed to mount component: template or render function not defined.</code></pre>
<p>To explain what's happening, let's call our components A and B. The module system sees that it needs A, but first A needs B, but B needs A, but A needs B, etc. It's stuck in a loop, not knowing how to fully resolve either component without first resolving the other. To fix this, we need to give the module system a point at which it can say, &quot;A needs B <em>eventually</em>, but there's no need to resolve B first.&quot;</p>
<p>In our case, let's make that point the <code>tree-folder</code> component. We know the child that creates the paradox is the <code>tree-folder-contents</code> component, so we'll wait until the <code>beforeCreate</code> lifecycle hook to register it:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">beforeCreate<span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
  <span class="kw">this</span>.<span class="va">$options</span>.<span class="va">components</span>.<span class="at">TreeFolderContents</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;./tree-folder-contents.vue&#39;</span>).<span class="at">default</span>
<span class="op">}</span></code></pre></div>
<p>Or alternatively, you could use Webpack's asynchronous <code>import</code> when you register the component locally:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">components<span class="op">:</span> <span class="op">{</span>
  <span class="dt">TreeFolderContents</span><span class="op">:</span> () <span class="op">=&gt;</span> <span class="im">import</span>(<span class="st">&#39;./tree-folder-contents.vue&#39;</span>)
<span class="op">}</span></code></pre></div>
<p>Problem solved!</p>
<h2 id="alternate-template-definitions">Alternate Template Definitions</h2>
<h3 id="inline-templates">Inline Templates</h3>
<p>When the <code>inline-template</code> special attribute is present on a child component, the component will use its inner content as its template, rather than treating it as distributed content. This allows more flexible template-authoring.</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;my-component</span><span class="ot"> inline-template</span><span class="kw">&gt;</span>
  <span class="kw">&lt;div&gt;</span>
    <span class="kw">&lt;p&gt;</span>These are compiled as the component&#39;s own template.<span class="kw">&lt;/p&gt;</span>
    <span class="kw">&lt;p&gt;</span>Not parent&#39;s transclusion content.<span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;/div&gt;</span>
<span class="kw">&lt;/my-component&gt;</span></code></pre></div>
<p>Your inline template needs to be defined inside the DOM element to which Vue is attached.</p>
<p class="tip">
However, <code>inline-template</code> makes the scope of your templates harder to reason about. As a best practice, prefer defining templates inside the component using the <code>template</code> option or in a <code>&lt;template&gt;</code> element in a <code>.vue</code> file.
</p>
<h3 id="x-templates">X-Templates</h3>
<p>Another way to define templates is inside of a script element with the type <code>text/x-template</code>, then referencing the template by an id. For example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;script</span><span class="ot"> type=</span><span class="st">&quot;text/x-template&quot;</span><span class="ot"> id=</span><span class="st">&quot;hello-world-template&quot;</span><span class="kw">&gt;</span>
  <span class="op">&lt;</span>p<span class="op">&gt;</span>Hello hello hello<span class="op">&lt;</span><span class="ss">/p&gt;</span>
<span class="ss">&lt;/script</span><span class="op">&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;hello-world&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">template</span><span class="op">:</span> <span class="st">&#39;#hello-world-template&#39;</span>
<span class="op">}</span>)</code></pre></div>
<p>Your x-template needs to be defined outside the DOM element to which Vue is attached.</p>
<p class="tip">
These can be useful for demos with large templates or in extremely small applications, but should otherwise be avoided, because they separate templates from the rest of the component definition.
</p>
<h2 id="controlling-updates">Controlling Updates</h2>
<p>Thanks to Vue's Reactivity system, it always knows when to update (if you use it correctly). There are edge cases, however, when you might want to force an update, despite the fact that no reactive data has changed. Then there are other cases when you might want to prevent unnecessary updates.</p>
<h3 id="forcing-an-update">Forcing an Update</h3>
<p class="tip">
If you find yourself needing to force an update in Vue, in 99.99% of cases, you've made a mistake somewhere.
</p>
<p>You may not have accounted for change detection caveats <a href="https://vuejs.org/v2/guide/list.html#Caveats">with arrays</a> or <a href="https://vuejs.org/v2/guide/list.html#Object-Change-Detection-Caveats">objects</a>, or you may be relying on state that isn't tracked by Vue's reactivity system, e.g. with <code>data</code>.</p>
<p>However, if you've ruled out the above and find yourself in this extremely rare situation of having to manually force an update, you can do so with <a href="../api/#vm-forceUpdate"><code>$forceUpdate</code></a>.</p>
<h3 id="cheap-static-components-with-v-once">Cheap Static Components with <code>v-once</code></h3>
<p>Rendering plain HTML elements is very fast in Vue, but sometimes you might have a component that contains <strong>a lot</strong> of static content. In these cases, you can ensure that it's only evaluated once and then cached by adding the <code>v-once</code> directive to the root element, like this:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;terms-of-service&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">template</span><span class="op">:</span> <span class="vs">`</span>
<span class="vs">    &lt;div v-once&gt;</span>
<span class="vs">      &lt;h1&gt;Terms of Service&lt;/h1&gt;</span>
<span class="vs">      ... a lot of static content ...</span>
<span class="vs">    &lt;/div&gt;</span>
<span class="vs">  `</span>
<span class="op">}</span>)</code></pre></div>
<p class="tip">
Once again, try not to overuse this pattern. While convenient in those rare cases when you have to render a lot of static content, it's simply not necessary unless you actually notice slow rendering -- plus, it could cause a lot of confusion later. For example, imagine another developer who's not familiar with <code>v-once</code> or simply misses it in the template. They might spend hours trying to figure out why the template isn't updating correctly.
</p>
<h1 id="enterleave-list-transitions"><a name=#guide/transitions.md></a>Enter/Leave &amp; List Transitions</h1>
<h2 id="overview">Overview</h2>
<p>Vue provides a variety of ways to apply transition effects when items are inserted, updated, or removed from the DOM. This includes tools to:</p>
<ul>
<li>automatically apply classes for CSS transitions and animations</li>
<li>integrate 3rd-party CSS animation libraries, such as Animate.css</li>
<li>use JavaScript to directly manipulate the DOM during transition hooks</li>
<li>integrate 3rd-party JavaScript animation libraries, such as Velocity.js</li>
</ul>
<p>On this page, we'll only cover entering, leaving, and list transitions, but you can see the next section for <a href="transitioning-state.html">managing state transitions</a>.</p>
<h2 id="transitioning-single-elementscomponents">Transitioning Single Elements/Components</h2>
<p>Vue provides a <code>transition</code> wrapper component, allowing you to add entering/leaving transitions for any element or component in the following contexts:</p>
<ul>
<li>Conditional rendering (using <code>v-if</code>)</li>
<li>Conditional display (using <code>v-show</code>)</li>
<li>Dynamic components</li>
<li>Component root nodes</li>
</ul>
<p>This is what an example looks like in action:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;demo&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;button</span><span class="ot"> v-on:click=</span><span class="st">&quot;show = !show&quot;</span><span class="kw">&gt;</span>
    Toggle
  <span class="kw">&lt;/button&gt;</span>
  <span class="kw">&lt;transition</span><span class="ot"> name=</span><span class="st">&quot;fade&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;p</span><span class="ot"> v-if=</span><span class="st">&quot;show&quot;</span><span class="kw">&gt;</span>hello<span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;/transition&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#demo&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">show</span><span class="op">:</span> <span class="kw">true</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode css"><code class="sourceCode css"><span class="fu">.fade-enter-active</span>, <span class="fu">.fade-leave-active</span> {
  <span class="kw">transition</span>: opacity <span class="dv">.5s</span>;
}
<span class="fu">.fade-enter</span>, <span class="fu">.fade-leave-to</span> <span class="co">/* .fade-leave-active below version 2.1.8 */</span> {
  <span class="kw">opacity</span>: <span class="dv">0</span>;
}</code></pre></div>
<p>When an element wrapped in a <code>transition</code> component is inserted or removed, this is what happens:</p>
<ol style="list-style-type: decimal">
<li><p>Vue will automatically sniff whether the target element has CSS transitions or animations applied. If it does, CSS transition classes will be added/removed at appropriate timings.</p></li>
<li><p>If the transition component provided <a href="#JavaScript-Hooks">JavaScript hooks</a>, these hooks will be called at appropriate timings.</p></li>
<li><p>If no CSS transitions/animations are detected and no JavaScript hooks are provided, the DOM operations for insertion and/or removal will be executed immediately on next frame (Note: this is a browser animation frame, different from Vue's concept of <code>nextTick</code>).</p></li>
</ol>
<h3 id="transition-classes">Transition Classes</h3>
<p>There are six classes applied for enter/leave transitions.</p>
<ol style="list-style-type: decimal">
<li><p><code>v-enter</code>: Starting state for enter. Added before element is inserted, removed one frame after element is inserted.</p></li>
<li><p><code>v-enter-active</code>: Active state for enter. Applied during the entire entering phase. Added before element is inserted, removed when transition/animation finishes. This class can be used to define the duration, delay and easing curve for the entering transition.</p></li>
<li><p><code>v-enter-to</code>: <strong>Only available in versions 2.1.8+.</strong> Ending state for enter. Added one frame after element is inserted (at the same time <code>v-enter</code> is removed), removed when transition/animation finishes.</p></li>
<li><p><code>v-leave</code>: Starting state for leave. Added immediately when a leaving transition is triggered, removed after one frame.</p></li>
<li><p><code>v-leave-active</code>: Active state for leave. Applied during the entire leaving phase. Added immediately when leave transition is triggered, removed when the transition/animation finishes. This class can be used to define the duration, delay and easing curve for the leaving transition.</p></li>
<li><p><code>v-leave-to</code>: <strong>Only available in versions 2.1.8+.</strong> Ending state for leave. Added one frame after a leaving transition is triggered (at the same time <code>v-leave</code> is removed), removed when the transition/animation finishes.</p></li>
</ol>
<div class="figure">
<img src="../images/transition.png" alt="Transition Diagram" />
<p class="caption">Transition Diagram</p>
</div>
<p>Each of these classes will be prefixed with the name of the transition. Here the <code>v-</code> prefix is the default when you use a <code>&lt;transition&gt;</code> element with no name. If you use <code>&lt;transition name=&quot;my-transition&quot;&gt;</code> for example, then the <code>v-enter</code> class would instead be <code>my-transition-enter</code>.</p>
<p><code>v-enter-active</code> and <code>v-leave-active</code> give you the ability to specify different easing curves for enter/leave transitions, which you'll see an example of in the following section.</p>
<h3 id="css-transitions">CSS Transitions</h3>
<p>One of the most common transition types uses CSS transitions. Here's an example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;example-1&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;button</span> <span class="er">@click</span><span class="ot">=</span><span class="st">&quot;show = !show&quot;</span><span class="kw">&gt;</span>
    Toggle render
  <span class="kw">&lt;/button&gt;</span>
  <span class="kw">&lt;transition</span><span class="ot"> name=</span><span class="st">&quot;slide-fade&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;p</span><span class="ot"> v-if=</span><span class="st">&quot;show&quot;</span><span class="kw">&gt;</span>hello<span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;/transition&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#example-1&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">show</span><span class="op">:</span> <span class="kw">true</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode css"><code class="sourceCode css"><span class="co">/* Enter and leave animations can use different */</span>
<span class="co">/* durations and timing functions.              */</span>
<span class="fu">.slide-fade-enter-active</span> {
  <span class="kw">transition</span>: all <span class="dv">.3s</span> ease;
}
<span class="fu">.slide-fade-leave-active</span> {
  <span class="kw">transition</span>: all <span class="dv">.8s</span> cubic-bezier(<span class="dv">1.0</span>, <span class="dv">0.5</span>, <span class="dv">0.8</span>, <span class="dv">1.0</span>);
}
<span class="fu">.slide-fade-enter</span>, <span class="fu">.slide-fade-leave-to</span>
<span class="co">/* .slide-fade-leave-active below version 2.1.8 */</span> {
  <span class="kw">transform</span>: translateX(<span class="dv">10px</span>);
  <span class="kw">opacity</span>: <span class="dv">0</span>;
}</code></pre></div>
<h3 id="css-animations">CSS Animations</h3>
<p>CSS animations are applied in the same way as CSS transitions, the difference being that <code>v-enter</code> is not removed immediately after the element is inserted, but on an <code>animationend</code> event.</p>
<p>Here's an example, omitting prefixed CSS rules for the sake of brevity:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;example-2&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;button</span> <span class="er">@click</span><span class="ot">=</span><span class="st">&quot;show = !show&quot;</span><span class="kw">&gt;</span>Toggle show<span class="kw">&lt;/button&gt;</span>
  <span class="kw">&lt;transition</span><span class="ot"> name=</span><span class="st">&quot;bounce&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;p</span><span class="ot"> v-if=</span><span class="st">&quot;show&quot;</span><span class="kw">&gt;</span>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris facilisis enim libero, at lacinia diam fermentum id. Pellentesque habitant morbi tristique senectus et netus.<span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;/transition&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#example-2&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">show</span><span class="op">:</span> <span class="kw">true</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode css"><code class="sourceCode css"><span class="fu">.bounce-enter-active</span> {
  animation: bounce-in <span class="dv">.5s</span>;
}
<span class="fu">.bounce-leave-active</span> {
  animation: bounce-in <span class="dv">.5s</span> reverse;
}
<span class="im">@keyframes</span> bounce-in {
  0% {
    <span class="kw">transform</span>: scale(<span class="dv">0</span>);
  }
  50% {
    <span class="kw">transform</span>: scale(<span class="dv">1.5</span>);
  }
  100% {
    <span class="kw">transform</span>: scale(<span class="dv">1</span>);
  }
}</code></pre></div>
<h3 id="custom-transition-classes">Custom Transition Classes</h3>
<p>You can also specify custom transition classes by providing the following attributes:</p>
<ul>
<li><code>enter-class</code></li>
<li><code>enter-active-class</code></li>
<li><code>enter-to-class</code> (2.1.8+)</li>
<li><code>leave-class</code></li>
<li><code>leave-active-class</code></li>
<li><code>leave-to-class</code> (2.1.8+)</li>
</ul>
<p>These will override the conventional class names. This is especially useful when you want to combine Vue's transition system with an existing CSS animation library, such as <a href="https://daneden.github.io/animate.css/">Animate.css</a>.</p>
<p>Here's an example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;link</span><span class="ot"> href=</span><span class="st">&quot;https://cdn.jsdelivr.net/npm/animate.css@3.5.1&quot;</span><span class="ot"> rel=</span><span class="st">&quot;stylesheet&quot;</span><span class="ot"> type=</span><span class="st">&quot;text/css&quot;</span><span class="kw">&gt;</span>

<span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;example-3&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;button</span> <span class="er">@click</span><span class="ot">=</span><span class="st">&quot;show = !show&quot;</span><span class="kw">&gt;</span>
    Toggle render
  <span class="kw">&lt;/button&gt;</span>
  <span class="kw">&lt;transition</span>
<span class="ot">    name=</span><span class="st">&quot;custom-classes-transition&quot;</span>
<span class="ot">    enter-active-class=</span><span class="st">&quot;animated tada&quot;</span>
<span class="ot">    leave-active-class=</span><span class="st">&quot;animated bounceOutRight&quot;</span>
  <span class="kw">&gt;</span>
    <span class="kw">&lt;p</span><span class="ot"> v-if=</span><span class="st">&quot;show&quot;</span><span class="kw">&gt;</span>hello<span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;/transition&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#example-3&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">show</span><span class="op">:</span> <span class="kw">true</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<h3 id="using-transitions-and-animations-together">Using Transitions and Animations Together</h3>
<p>Vue needs to attach event listeners in order to know when a transition has ended. It can either be <code>transitionend</code> or <code>animationend</code>, depending on the type of CSS rules applied. If you are only using one or the other, Vue can automatically detect the correct type.</p>
<p>However, in some cases you may want to have both on the same element, for example having a CSS animation triggered by Vue, along with a CSS transition effect on hover. In these cases, you will have to explicitly declare the type you want Vue to care about in a <code>type</code> attribute, with a value of either <code>animation</code> or <code>transition</code>.</p>
<h3 id="explicit-transition-durations">Explicit Transition Durations</h3>
<blockquote>
<p>New in 2.2.0+</p>
</blockquote>
<p>In most cases, Vue can automatically figure out when the transition has finished. By default, Vue waits for the first <code>transitionend</code> or <code>animationend</code> event on the root transition element. However, this may not always be desired - for example, we may have a choreographed transition sequence where some nested inner elements have a delayed transition or a longer transition duration than the root transition element.</p>
<p>In such cases you can specify an explicit transition duration (in milliseconds) using the <code>duration</code> prop on the <code>&lt;transition&gt;</code> component:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;transition</span><span class="ot"> :duration=</span><span class="st">&quot;1000&quot;</span><span class="kw">&gt;</span>...<span class="kw">&lt;/transition&gt;</span></code></pre></div>
<p>You can also specify separate values for enter and leave durations:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;transition</span><span class="ot"> :duration=</span><span class="st">&quot;{ enter: 500, leave: 800 }&quot;</span><span class="kw">&gt;</span>...<span class="kw">&lt;/transition&gt;</span></code></pre></div>
<h3 id="javascript-hooks">JavaScript Hooks</h3>
<p>You can also define JavaScript hooks in attributes:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;transition</span>
<span class="ot">  v-on:before-enter=</span><span class="st">&quot;beforeEnter&quot;</span>
<span class="ot">  v-on:enter=</span><span class="st">&quot;enter&quot;</span>
<span class="ot">  v-on:after-enter=</span><span class="st">&quot;afterEnter&quot;</span>
<span class="ot">  v-on:enter-cancelled=</span><span class="st">&quot;enterCancelled&quot;</span>

<span class="ot">  v-on:before-leave=</span><span class="st">&quot;beforeLeave&quot;</span>
<span class="ot">  v-on:leave=</span><span class="st">&quot;leave&quot;</span>
<span class="ot">  v-on:after-leave=</span><span class="st">&quot;afterLeave&quot;</span>
<span class="ot">  v-on:leave-cancelled=</span><span class="st">&quot;leaveCancelled&quot;</span>
<span class="kw">&gt;</span>
  <span class="co">&lt;!-- ... --&gt;</span>
<span class="kw">&lt;/transition&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// ...</span>
methods<span class="op">:</span> <span class="op">{</span>
  <span class="co">// --------</span>
  <span class="co">// ENTERING</span>
  <span class="co">// --------</span>

  <span class="dt">beforeEnter</span><span class="op">:</span> <span class="kw">function</span> (el) <span class="op">{</span>
    <span class="co">// ...</span>
  <span class="op">},</span>
  <span class="co">// the done callback is optional when</span>
  <span class="co">// used in combination with CSS</span>
  <span class="dt">enter</span><span class="op">:</span> <span class="kw">function</span> (el<span class="op">,</span> done) <span class="op">{</span>
    <span class="co">// ...</span>
    <span class="at">done</span>()
  <span class="op">},</span>
  <span class="dt">afterEnter</span><span class="op">:</span> <span class="kw">function</span> (el) <span class="op">{</span>
    <span class="co">// ...</span>
  <span class="op">},</span>
  <span class="dt">enterCancelled</span><span class="op">:</span> <span class="kw">function</span> (el) <span class="op">{</span>
    <span class="co">// ...</span>
  <span class="op">},</span>

  <span class="co">// --------</span>
  <span class="co">// LEAVING</span>
  <span class="co">// --------</span>

  <span class="dt">beforeLeave</span><span class="op">:</span> <span class="kw">function</span> (el) <span class="op">{</span>
    <span class="co">// ...</span>
  <span class="op">},</span>
  <span class="co">// the done callback is optional when</span>
  <span class="co">// used in combination with CSS</span>
  <span class="dt">leave</span><span class="op">:</span> <span class="kw">function</span> (el<span class="op">,</span> done) <span class="op">{</span>
    <span class="co">// ...</span>
    <span class="at">done</span>()
  <span class="op">},</span>
  <span class="dt">afterLeave</span><span class="op">:</span> <span class="kw">function</span> (el) <span class="op">{</span>
    <span class="co">// ...</span>
  <span class="op">},</span>
  <span class="co">// leaveCancelled only available with v-show</span>
  <span class="dt">leaveCancelled</span><span class="op">:</span> <span class="kw">function</span> (el) <span class="op">{</span>
    <span class="co">// ...</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>These hooks can be used in combination with CSS transitions/animations or on their own.</p>
<p class="tip">
When using JavaScript-only transitions, <strong>the <code>done</code> callbacks are required for the <code>enter</code> and <code>leave</code> hooks</strong>. Otherwise, the hooks will be called synchronously and the transition will finish immediately.
</p>
<p class="tip">
It's also a good idea to explicitly add <code>v-bind:css=&quot;false&quot;</code> for JavaScript-only transitions so that Vue can skip the CSS detection. This also prevents CSS rules from accidentally interfering with the transition.
</p>
<p>Now let's dive into an example. Here's a JavaScript transition using Velocity.js:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!--</span>
<span class="co">Velocity works very much like jQuery.animate and is</span>
<span class="co">a great option for JavaScript animations</span>
<span class="co">--&gt;</span>
<span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js&quot;</span><span class="kw">&gt;&lt;/script&gt;</span>

<span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;example-4&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;button</span> <span class="er">@click</span><span class="ot">=</span><span class="st">&quot;show = !show&quot;</span><span class="kw">&gt;</span>
    Toggle
  <span class="kw">&lt;/button&gt;</span>
  <span class="kw">&lt;transition</span>
<span class="ot">    v-on:before-enter=</span><span class="st">&quot;beforeEnter&quot;</span>
<span class="ot">    v-on:enter=</span><span class="st">&quot;enter&quot;</span>
<span class="ot">    v-on:leave=</span><span class="st">&quot;leave&quot;</span>
<span class="ot">    v-bind:css=</span><span class="st">&quot;false&quot;</span>
  <span class="kw">&gt;</span>
    <span class="kw">&lt;p</span><span class="ot"> v-if=</span><span class="st">&quot;show&quot;</span><span class="kw">&gt;</span>
      Demo
    <span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;/transition&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#example-4&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">show</span><span class="op">:</span> <span class="kw">false</span>
  <span class="op">},</span>
  <span class="dt">methods</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">beforeEnter</span><span class="op">:</span> <span class="kw">function</span> (el) <span class="op">{</span>
      <span class="va">el</span>.<span class="va">style</span>.<span class="at">opacity</span> <span class="op">=</span> <span class="dv">0</span>
      <span class="va">el</span>.<span class="va">style</span>.<span class="at">transformOrigin</span> <span class="op">=</span> <span class="st">&#39;left&#39;</span>
    <span class="op">},</span>
    <span class="dt">enter</span><span class="op">:</span> <span class="kw">function</span> (el<span class="op">,</span> done) <span class="op">{</span>
      <span class="at">Velocity</span>(el<span class="op">,</span> <span class="op">{</span> <span class="dt">opacity</span><span class="op">:</span> <span class="dv">1</span><span class="op">,</span> <span class="dt">fontSize</span><span class="op">:</span> <span class="st">&#39;1.4em&#39;</span> <span class="op">},</span> <span class="op">{</span> <span class="dt">duration</span><span class="op">:</span> <span class="dv">300</span> <span class="op">}</span>)
      <span class="at">Velocity</span>(el<span class="op">,</span> <span class="op">{</span> <span class="dt">fontSize</span><span class="op">:</span> <span class="st">&#39;1em&#39;</span> <span class="op">},</span> <span class="op">{</span> <span class="dt">complete</span><span class="op">:</span> done <span class="op">}</span>)
    <span class="op">},</span>
    <span class="dt">leave</span><span class="op">:</span> <span class="kw">function</span> (el<span class="op">,</span> done) <span class="op">{</span>
      <span class="at">Velocity</span>(el<span class="op">,</span> <span class="op">{</span> <span class="dt">translateX</span><span class="op">:</span> <span class="st">&#39;15px&#39;</span><span class="op">,</span> <span class="dt">rotateZ</span><span class="op">:</span> <span class="st">&#39;50deg&#39;</span> <span class="op">},</span> <span class="op">{</span> <span class="dt">duration</span><span class="op">:</span> <span class="dv">600</span> <span class="op">}</span>)
      <span class="at">Velocity</span>(el<span class="op">,</span> <span class="op">{</span> <span class="dt">rotateZ</span><span class="op">:</span> <span class="st">&#39;100deg&#39;</span> <span class="op">},</span> <span class="op">{</span> <span class="dt">loop</span><span class="op">:</span> <span class="dv">2</span> <span class="op">}</span>)
      <span class="at">Velocity</span>(el<span class="op">,</span> <span class="op">{</span>
        <span class="dt">rotateZ</span><span class="op">:</span> <span class="st">&#39;45deg&#39;</span><span class="op">,</span>
        <span class="dt">translateY</span><span class="op">:</span> <span class="st">&#39;30px&#39;</span><span class="op">,</span>
        <span class="dt">translateX</span><span class="op">:</span> <span class="st">&#39;30px&#39;</span><span class="op">,</span>
        <span class="dt">opacity</span><span class="op">:</span> <span class="dv">0</span>
      <span class="op">},</span> <span class="op">{</span> <span class="dt">complete</span><span class="op">:</span> done <span class="op">}</span>)
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<h2 id="transitions-on-initial-render">Transitions on Initial Render</h2>
<p>If you also want to apply a transition on the initial render of a node, you can add the <code>appear</code> attribute:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;transition</span><span class="ot"> appear</span><span class="kw">&gt;</span>
  <span class="co">&lt;!-- ... --&gt;</span>
<span class="kw">&lt;/transition&gt;</span></code></pre></div>
<p>By default, this will use the transitions specified for entering and leaving. If you'd like however, you can also specify custom CSS classes:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;transition</span>
<span class="ot">  appear</span>
<span class="ot">  appear-class=</span><span class="st">&quot;custom-appear-class&quot;</span>
<span class="ot">  appear-to-class=</span><span class="st">&quot;custom-appear-to-class&quot;</span><span class="ot"> (2.1.8</span><span class="er">+)</span>
<span class="ot">  appear-active-class=</span><span class="st">&quot;custom-appear-active-class&quot;</span>
<span class="kw">&gt;</span>
  <span class="co">&lt;!-- ... --&gt;</span>
<span class="kw">&lt;/transition&gt;</span></code></pre></div>
<p>and custom JavaScript hooks:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;transition</span>
<span class="ot">  appear</span>
<span class="ot">  v-on:before-appear=</span><span class="st">&quot;customBeforeAppearHook&quot;</span>
<span class="ot">  v-on:appear=</span><span class="st">&quot;customAppearHook&quot;</span>
<span class="ot">  v-on:after-appear=</span><span class="st">&quot;customAfterAppearHook&quot;</span>
<span class="ot">  v-on:appear-cancelled=</span><span class="st">&quot;customAppearCancelledHook&quot;</span>
<span class="kw">&gt;</span>
  <span class="co">&lt;!-- ... --&gt;</span>
<span class="kw">&lt;/transition&gt;</span></code></pre></div>
<p>In the example above, either <code>appear</code> attribute or <code>v-on:appear</code> hook will cause an appear transition.</p>
<h2 id="transitioning-between-elements">Transitioning Between Elements</h2>
<p>We discuss <a href="#Transitioning-Between-Components">transitioning between components</a> later, but you can also transition between raw elements using <code>v-if</code>/<code>v-else</code>. One of the most common two-element transitions is between a list container and a message describing an empty list:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;transition&gt;</span>
  <span class="kw">&lt;table</span><span class="ot"> v-if=</span><span class="st">&quot;items.length &gt; 0&quot;</span><span class="kw">&gt;</span>
    <span class="co">&lt;!-- ... --&gt;</span>
  <span class="kw">&lt;/table&gt;</span>
  <span class="kw">&lt;p</span><span class="ot"> v-else</span><span class="kw">&gt;</span>Sorry, no items found.<span class="kw">&lt;/p&gt;</span>
<span class="kw">&lt;/transition&gt;</span></code></pre></div>
<p>This works well, but there's one caveat to be aware of:</p>
<p class="tip">
When toggling between elements that have <strong>the same tag name</strong>, you must tell Vue that they are distinct elements by giving them unique <code>key</code> attributes. Otherwise, Vue's compiler will only replace the content of the element for efficiency. Even when technically unnecessary though, <strong>it's considered good practice to always key multiple items within a <code>&lt;transition&gt;</code> component.</strong>
</p>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;transition&gt;</span>
  <span class="kw">&lt;button</span><span class="ot"> v-if=</span><span class="st">&quot;isEditing&quot;</span><span class="ot"> key=</span><span class="st">&quot;save&quot;</span><span class="kw">&gt;</span>
    Save
  <span class="kw">&lt;/button&gt;</span>
  <span class="kw">&lt;button</span><span class="ot"> v-else key=</span><span class="st">&quot;edit&quot;</span><span class="kw">&gt;</span>
    Edit
  <span class="kw">&lt;/button&gt;</span>
<span class="kw">&lt;/transition&gt;</span></code></pre></div>
<p>In these cases, you can also use the <code>key</code> attribute to transition between different states of the same element. Instead of using <code>v-if</code> and <code>v-else</code>, the above example could be rewritten as:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;transition&gt;</span>
  <span class="kw">&lt;button</span><span class="ot"> v-bind:key=</span><span class="st">&quot;isEditing&quot;</span><span class="kw">&gt;</span>
    {{ isEditing ? &#39;Save&#39; : &#39;Edit&#39; }}
  <span class="kw">&lt;/button&gt;</span>
<span class="kw">&lt;/transition&gt;</span></code></pre></div>
<p>It's actually possible to transition between any number of elements, either by using multiple <code>v-if</code>s or binding a single element to a dynamic property. For example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;transition&gt;</span>
  <span class="kw">&lt;button</span><span class="ot"> v-if=</span><span class="st">&quot;docState === &#39;saved&#39;&quot;</span><span class="ot"> key=</span><span class="st">&quot;saved&quot;</span><span class="kw">&gt;</span>
    Edit
  <span class="kw">&lt;/button&gt;</span>
  <span class="kw">&lt;button</span><span class="ot"> v-if=</span><span class="st">&quot;docState === &#39;edited&#39;&quot;</span><span class="ot"> key=</span><span class="st">&quot;edited&quot;</span><span class="kw">&gt;</span>
    Save
  <span class="kw">&lt;/button&gt;</span>
  <span class="kw">&lt;button</span><span class="ot"> v-if=</span><span class="st">&quot;docState === &#39;editing&#39;&quot;</span><span class="ot"> key=</span><span class="st">&quot;editing&quot;</span><span class="kw">&gt;</span>
    Cancel
  <span class="kw">&lt;/button&gt;</span>
<span class="kw">&lt;/transition&gt;</span></code></pre></div>
<p>Which could also be written as:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;transition&gt;</span>
  <span class="kw">&lt;button</span><span class="ot"> v-bind:key=</span><span class="st">&quot;docState&quot;</span><span class="kw">&gt;</span>
    {{ buttonMessage }}
  <span class="kw">&lt;/button&gt;</span>
<span class="kw">&lt;/transition&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// ...</span>
computed<span class="op">:</span> <span class="op">{</span>
  <span class="dt">buttonMessage</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="cf">switch</span> (<span class="kw">this</span>.<span class="at">docState</span>) <span class="op">{</span>
      <span class="cf">case</span> <span class="st">&#39;saved&#39;</span><span class="op">:</span> <span class="cf">return</span> <span class="st">&#39;Edit&#39;</span>
      <span class="cf">case</span> <span class="st">&#39;edited&#39;</span><span class="op">:</span> <span class="cf">return</span> <span class="st">&#39;Save&#39;</span>
      <span class="cf">case</span> <span class="st">&#39;editing&#39;</span><span class="op">:</span> <span class="cf">return</span> <span class="st">&#39;Cancel&#39;</span>
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<h3 id="transition-modes">Transition Modes</h3>
<p>There's still one problem though. Try clicking the button below:</p>
<p>As it's transitioning between the &quot;on&quot; button and the &quot;off&quot; button, both buttons are rendered - one transitioning out while the other transitions in. This is the default behavior of <code>&lt;transition&gt;</code> - entering and leaving happens simultaneously.</p>
<p>Sometimes this works great, like when transitioning items are absolutely positioned on top of each other:</p>
<p>And then maybe also translated so that they look like slide transitions:</p>
<p>Simultaneous entering and leaving transitions aren't always desirable though, so Vue offers some alternative <strong>transition modes</strong>:</p>
<ul>
<li><p><code>in-out</code>: New element transitions in first, then when complete, the current element transitions out.</p></li>
<li><p><code>out-in</code>: Current element transitions out first, then when complete, the new element transitions in.</p></li>
</ul>
<p>Now let's update the transition for our on/off buttons with <code>out-in</code>:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;transition</span><span class="ot"> name=</span><span class="st">&quot;fade&quot;</span><span class="ot"> mode=</span><span class="st">&quot;out-in&quot;</span><span class="kw">&gt;</span>
  <span class="co">&lt;!-- ... the buttons ... --&gt;</span>
<span class="kw">&lt;/transition&gt;</span></code></pre></div>
<p>With one attribute addition, we've fixed that original transition without having to add any special styling.</p>
<p>The <code>in-out</code> mode isn't used as often, but can sometimes be useful for a slightly different transition effect. Let's try combining it with the slide-fade transition we worked on earlier:</p>
<p>Pretty cool, right?</p>
<h2 id="transitioning-between-components">Transitioning Between Components</h2>
<p>Transitioning between components is even simpler - we don't even need the <code>key</code> attribute. Instead, we wrap a <a href="components.html#Dynamic-Components">dynamic component</a>:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;transition</span><span class="ot"> name=</span><span class="st">&quot;component-fade&quot;</span><span class="ot"> mode=</span><span class="st">&quot;out-in&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;component</span><span class="ot"> v-bind:is=</span><span class="st">&quot;view&quot;</span><span class="kw">&gt;&lt;/component&gt;</span>
<span class="kw">&lt;/transition&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#transition-components-demo&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">view</span><span class="op">:</span> <span class="st">&#39;v-a&#39;</span>
  <span class="op">},</span>
  <span class="dt">components</span><span class="op">:</span> <span class="op">{</span>
    <span class="st">&#39;v-a&#39;</span><span class="op">:</span> <span class="op">{</span>
      <span class="dt">template</span><span class="op">:</span> <span class="st">&#39;&lt;div&gt;Component A&lt;/div&gt;&#39;</span>
    <span class="op">},</span>
    <span class="st">&#39;v-b&#39;</span><span class="op">:</span> <span class="op">{</span>
      <span class="dt">template</span><span class="op">:</span> <span class="st">&#39;&lt;div&gt;Component B&lt;/div&gt;&#39;</span>
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode css"><code class="sourceCode css"><span class="fu">.component-fade-enter-active</span>, <span class="fu">.component-fade-leave-active</span> {
  <span class="kw">transition</span>: opacity <span class="dv">.3s</span> ease;
}
<span class="fu">.component-fade-enter</span>, <span class="fu">.component-fade-leave-to</span>
<span class="co">/* .component-fade-leave-active below version 2.1.8 */</span> {
  <span class="kw">opacity</span>: <span class="dv">0</span>;
}</code></pre></div>
<h2 id="list-transitions">List Transitions</h2>
<p>So far, we've managed transitions for:</p>
<ul>
<li>Individual nodes</li>
<li>Multiple nodes where only 1 is rendered at a time</li>
</ul>
<p>So what about for when we have a whole list of items we want to render simultaneously, for example with <code>v-for</code>? In this case, we'll use the <code>&lt;transition-group&gt;</code> component. Before we dive into an example though, there are a few things that are important to know about this component:</p>
<ul>
<li>Unlike <code>&lt;transition&gt;</code>, it renders an actual element: a <code>&lt;span&gt;</code> by default. You can change the element that's rendered with the <code>tag</code> attribute.</li>
<li><a href="#Transition-Modes">Transition modes</a> are not available, because we are no longer alternating between mutually exclusive elements.</li>
<li>Elements inside are <strong>always required</strong> to have a unique <code>key</code> attribute.</li>
<li>CSS transition classes will be applied to inner elements and not to the group/container itself.</li>
</ul>
<h3 id="list-enteringleaving-transitions">List Entering/Leaving Transitions</h3>
<p>Now let's dive into an example, transitioning entering and leaving using the same CSS classes we've used previously:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;list-demo&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;button</span><span class="ot"> v-on:click=</span><span class="st">&quot;add&quot;</span><span class="kw">&gt;</span>Add<span class="kw">&lt;/button&gt;</span>
  <span class="kw">&lt;button</span><span class="ot"> v-on:click=</span><span class="st">&quot;remove&quot;</span><span class="kw">&gt;</span>Remove<span class="kw">&lt;/button&gt;</span>
  <span class="kw">&lt;transition-group</span><span class="ot"> name=</span><span class="st">&quot;list&quot;</span><span class="ot"> tag=</span><span class="st">&quot;p&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;span</span><span class="ot"> v-for=</span><span class="st">&quot;item in items&quot;</span><span class="ot"> v-bind:key=</span><span class="st">&quot;item&quot;</span><span class="ot"> class=</span><span class="st">&quot;list-item&quot;</span><span class="kw">&gt;</span>
      {{ item }}
    <span class="kw">&lt;/span&gt;</span>
  <span class="kw">&lt;/transition-group&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#list-demo&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">items</span><span class="op">:</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span><span class="op">,</span><span class="dv">6</span><span class="op">,</span><span class="dv">7</span><span class="op">,</span><span class="dv">8</span><span class="op">,</span><span class="dv">9</span>]<span class="op">,</span>
    <span class="dt">nextNum</span><span class="op">:</span> <span class="dv">10</span>
  <span class="op">},</span>
  <span class="dt">methods</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">randomIndex</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="cf">return</span> <span class="va">Math</span>.<span class="at">floor</span>(<span class="va">Math</span>.<span class="at">random</span>() <span class="op">*</span> <span class="kw">this</span>.<span class="va">items</span>.<span class="at">length</span>)
    <span class="op">},</span>
    <span class="dt">add</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="kw">this</span>.<span class="va">items</span>.<span class="at">splice</span>(<span class="kw">this</span>.<span class="at">randomIndex</span>()<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">this</span>.<span class="at">nextNum</span><span class="op">++</span>)
    <span class="op">},</span>
    <span class="dt">remove</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="kw">this</span>.<span class="va">items</span>.<span class="at">splice</span>(<span class="kw">this</span>.<span class="at">randomIndex</span>()<span class="op">,</span> <span class="dv">1</span>)
    <span class="op">},</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode css"><code class="sourceCode css"><span class="fu">.list-item</span> {
  <span class="kw">display</span>: <span class="dv">inline-block</span>;
  <span class="kw">margin-right</span>: <span class="dv">10px</span>;
}
<span class="fu">.list-enter-active</span>, <span class="fu">.list-leave-active</span> {
  <span class="kw">transition</span>: all <span class="dv">1s</span>;
}
<span class="fu">.list-enter</span>, <span class="fu">.list-leave-to</span> <span class="co">/* .list-leave-active below version 2.1.8 */</span> {
  <span class="kw">opacity</span>: <span class="dv">0</span>;
  <span class="kw">transform</span>: translateY(<span class="dv">30px</span>);
}</code></pre></div>
<p>There's one problem with this example. When you add or remove an item, the ones around it instantly snap into their new place instead of smoothly transitioning. We'll fix that later.</p>
<h3 id="list-move-transitions">List Move Transitions</h3>
<p>The <code>&lt;transition-group&gt;</code> component has another trick up its sleeve. It can not only animate entering and leaving, but also changes in position. The only new concept you need to know to use this feature is the addition of <strong>the <code>v-move</code> class</strong>, which is added when items are changing positions. Like the other classes, its prefix will match the value of a provided <code>name</code> attribute and you can also manually specify a class with the <code>move-class</code> attribute.</p>
<p>This class is mostly useful for specifying the transition timing and easing curve, as you'll see below:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js&quot;</span><span class="kw">&gt;&lt;/script&gt;</span>

<span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;flip-list-demo&quot;</span><span class="ot"> class=</span><span class="st">&quot;demo&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;button</span><span class="ot"> v-on:click=</span><span class="st">&quot;shuffle&quot;</span><span class="kw">&gt;</span>Shuffle<span class="kw">&lt;/button&gt;</span>
  <span class="kw">&lt;transition-group</span><span class="ot"> name=</span><span class="st">&quot;flip-list&quot;</span><span class="ot"> tag=</span><span class="st">&quot;ul&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;li</span><span class="ot"> v-for=</span><span class="st">&quot;item in items&quot;</span><span class="ot"> v-bind:key=</span><span class="st">&quot;item&quot;</span><span class="kw">&gt;</span>
      {{ item }}
    <span class="kw">&lt;/li&gt;</span>
  <span class="kw">&lt;/transition-group&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#flip-list-demo&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">items</span><span class="op">:</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span><span class="op">,</span><span class="dv">6</span><span class="op">,</span><span class="dv">7</span><span class="op">,</span><span class="dv">8</span><span class="op">,</span><span class="dv">9</span>]
  <span class="op">},</span>
  <span class="dt">methods</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">shuffle</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="kw">this</span>.<span class="at">items</span> <span class="op">=</span> <span class="va">_</span>.<span class="at">shuffle</span>(<span class="kw">this</span>.<span class="at">items</span>)
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode css"><code class="sourceCode css"><span class="fu">.flip-list-move</span> {
  <span class="kw">transition</span>: transform <span class="dv">1s</span>;
}</code></pre></div>
<p>This might seem like magic, but under the hood, Vue is using an animation technique called <a href="https://aerotwist.com/blog/flip-your-animations/">FLIP</a> to smoothly transition elements from their old position to their new position using transforms.</p>
<p>We can combine this technique with our previous implementation to animate every possible change to our list!</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js&quot;</span><span class="kw">&gt;&lt;/script&gt;</span>

<span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;list-complete-demo&quot;</span><span class="ot"> class=</span><span class="st">&quot;demo&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;button</span><span class="ot"> v-on:click=</span><span class="st">&quot;shuffle&quot;</span><span class="kw">&gt;</span>Shuffle<span class="kw">&lt;/button&gt;</span>
  <span class="kw">&lt;button</span><span class="ot"> v-on:click=</span><span class="st">&quot;add&quot;</span><span class="kw">&gt;</span>Add<span class="kw">&lt;/button&gt;</span>
  <span class="kw">&lt;button</span><span class="ot"> v-on:click=</span><span class="st">&quot;remove&quot;</span><span class="kw">&gt;</span>Remove<span class="kw">&lt;/button&gt;</span>
  <span class="kw">&lt;transition-group</span><span class="ot"> name=</span><span class="st">&quot;list-complete&quot;</span><span class="ot"> tag=</span><span class="st">&quot;p&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;span</span>
<span class="ot">      v-for=</span><span class="st">&quot;item in items&quot;</span>
<span class="ot">      v-bind:key=</span><span class="st">&quot;item&quot;</span>
<span class="ot">      class=</span><span class="st">&quot;list-complete-item&quot;</span>
    <span class="kw">&gt;</span>
      {{ item }}
    <span class="kw">&lt;/span&gt;</span>
  <span class="kw">&lt;/transition-group&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#list-complete-demo&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">items</span><span class="op">:</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span><span class="dv">5</span><span class="op">,</span><span class="dv">6</span><span class="op">,</span><span class="dv">7</span><span class="op">,</span><span class="dv">8</span><span class="op">,</span><span class="dv">9</span>]<span class="op">,</span>
    <span class="dt">nextNum</span><span class="op">:</span> <span class="dv">10</span>
  <span class="op">},</span>
  <span class="dt">methods</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">randomIndex</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="cf">return</span> <span class="va">Math</span>.<span class="at">floor</span>(<span class="va">Math</span>.<span class="at">random</span>() <span class="op">*</span> <span class="kw">this</span>.<span class="va">items</span>.<span class="at">length</span>)
    <span class="op">},</span>
    <span class="dt">add</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="kw">this</span>.<span class="va">items</span>.<span class="at">splice</span>(<span class="kw">this</span>.<span class="at">randomIndex</span>()<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">this</span>.<span class="at">nextNum</span><span class="op">++</span>)
    <span class="op">},</span>
    <span class="dt">remove</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="kw">this</span>.<span class="va">items</span>.<span class="at">splice</span>(<span class="kw">this</span>.<span class="at">randomIndex</span>()<span class="op">,</span> <span class="dv">1</span>)
    <span class="op">},</span>
    <span class="dt">shuffle</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="kw">this</span>.<span class="at">items</span> <span class="op">=</span> <span class="va">_</span>.<span class="at">shuffle</span>(<span class="kw">this</span>.<span class="at">items</span>)
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode css"><code class="sourceCode css"><span class="fu">.list-complete-item</span> {
  <span class="kw">transition</span>: all <span class="dv">1s</span>;
  <span class="kw">display</span>: <span class="dv">inline-block</span>;
  <span class="kw">margin-right</span>: <span class="dv">10px</span>;
}
<span class="fu">.list-complete-enter</span>, <span class="fu">.list-complete-leave-to</span>
<span class="co">/* .list-complete-leave-active below version 2.1.8 */</span> {
  <span class="kw">opacity</span>: <span class="dv">0</span>;
  <span class="kw">transform</span>: translateY(<span class="dv">30px</span>);
}
<span class="fu">.list-complete-leave-active</span> {
  <span class="kw">position</span>: <span class="dv">absolute</span>;
}</code></pre></div>
<p class="tip">
One important note is that these FLIP transitions do not work with elements set to <code>display: inline</code>. As an alternative, you can use <code>display: inline-block</code> or place elements in a flex context.
</p>
<p>These FLIP animations are also not limited to a single axis. Items in a multidimensional grid can be <a href="https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-list-move-transitions">transitioned too</a>:</p>
<h3 id="staggering-list-transitions">Staggering List Transitions</h3>
<p>By communicating with JavaScript transitions through data attributes, it's also possible to stagger transitions in a list:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js&quot;</span><span class="kw">&gt;&lt;/script&gt;</span>

<span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;staggered-list-demo&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;input</span><span class="ot"> v-model=</span><span class="st">&quot;query&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;transition-group</span>
<span class="ot">    name=</span><span class="st">&quot;staggered-fade&quot;</span>
<span class="ot">    tag=</span><span class="st">&quot;ul&quot;</span>
<span class="ot">    v-bind:css=</span><span class="st">&quot;false&quot;</span>
<span class="ot">    v-on:before-enter=</span><span class="st">&quot;beforeEnter&quot;</span>
<span class="ot">    v-on:enter=</span><span class="st">&quot;enter&quot;</span>
<span class="ot">    v-on:leave=</span><span class="st">&quot;leave&quot;</span>
  <span class="kw">&gt;</span>
    <span class="kw">&lt;li</span>
<span class="ot">      v-for=</span><span class="st">&quot;(item, index) in computedList&quot;</span>
<span class="ot">      v-bind:key=</span><span class="st">&quot;item.msg&quot;</span>
<span class="ot">      v-bind:data-index=</span><span class="st">&quot;index&quot;</span>
    <span class="kw">&gt;</span>{{ item.msg }}<span class="kw">&lt;/li&gt;</span>
  <span class="kw">&lt;/transition-group&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#staggered-list-demo&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">query</span><span class="op">:</span> <span class="st">&#39;&#39;</span><span class="op">,</span>
    <span class="dt">list</span><span class="op">:</span> [
      <span class="op">{</span> <span class="dt">msg</span><span class="op">:</span> <span class="st">&#39;Bruce Lee&#39;</span> <span class="op">},</span>
      <span class="op">{</span> <span class="dt">msg</span><span class="op">:</span> <span class="st">&#39;Jackie Chan&#39;</span> <span class="op">},</span>
      <span class="op">{</span> <span class="dt">msg</span><span class="op">:</span> <span class="st">&#39;Chuck Norris&#39;</span> <span class="op">},</span>
      <span class="op">{</span> <span class="dt">msg</span><span class="op">:</span> <span class="st">&#39;Jet Li&#39;</span> <span class="op">},</span>
      <span class="op">{</span> <span class="dt">msg</span><span class="op">:</span> <span class="st">&#39;Kung Fury&#39;</span> <span class="op">}</span>
    ]
  <span class="op">},</span>
  <span class="dt">computed</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">computedList</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="kw">var</span> vm <span class="op">=</span> <span class="kw">this</span>
      <span class="cf">return</span> <span class="kw">this</span>.<span class="va">list</span>.<span class="at">filter</span>(<span class="kw">function</span> (item) <span class="op">{</span>
        <span class="cf">return</span> <span class="va">item</span>.<span class="va">msg</span>.<span class="at">toLowerCase</span>().<span class="at">indexOf</span>(<span class="va">vm</span>.<span class="va">query</span>.<span class="at">toLowerCase</span>()) <span class="op">!==</span> <span class="dv">-1</span>
      <span class="op">}</span>)
    <span class="op">}</span>
  <span class="op">},</span>
  <span class="dt">methods</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">beforeEnter</span><span class="op">:</span> <span class="kw">function</span> (el) <span class="op">{</span>
      <span class="va">el</span>.<span class="va">style</span>.<span class="at">opacity</span> <span class="op">=</span> <span class="dv">0</span>
      <span class="va">el</span>.<span class="va">style</span>.<span class="at">height</span> <span class="op">=</span> <span class="dv">0</span>
    <span class="op">},</span>
    <span class="dt">enter</span><span class="op">:</span> <span class="kw">function</span> (el<span class="op">,</span> done) <span class="op">{</span>
      <span class="kw">var</span> delay <span class="op">=</span> <span class="va">el</span>.<span class="va">dataset</span>.<span class="at">index</span> <span class="op">*</span> <span class="dv">150</span>
      <span class="at">setTimeout</span>(<span class="kw">function</span> () <span class="op">{</span>
        <span class="at">Velocity</span>(
          el<span class="op">,</span>
          <span class="op">{</span> <span class="dt">opacity</span><span class="op">:</span> <span class="dv">1</span><span class="op">,</span> <span class="dt">height</span><span class="op">:</span> <span class="st">&#39;1.6em&#39;</span> <span class="op">},</span>
          <span class="op">{</span> <span class="dt">complete</span><span class="op">:</span> done <span class="op">}</span>
        )
      <span class="op">},</span> delay)
    <span class="op">},</span>
    <span class="dt">leave</span><span class="op">:</span> <span class="kw">function</span> (el<span class="op">,</span> done) <span class="op">{</span>
      <span class="kw">var</span> delay <span class="op">=</span> <span class="va">el</span>.<span class="va">dataset</span>.<span class="at">index</span> <span class="op">*</span> <span class="dv">150</span>
      <span class="at">setTimeout</span>(<span class="kw">function</span> () <span class="op">{</span>
        <span class="at">Velocity</span>(
          el<span class="op">,</span>
          <span class="op">{</span> <span class="dt">opacity</span><span class="op">:</span> <span class="dv">0</span><span class="op">,</span> <span class="dt">height</span><span class="op">:</span> <span class="dv">0</span> <span class="op">},</span>
          <span class="op">{</span> <span class="dt">complete</span><span class="op">:</span> done <span class="op">}</span>
        )
      <span class="op">},</span> delay)
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<h2 id="reusable-transitions">Reusable Transitions</h2>
<p>Transitions can be reused through Vue's component system. To create a reusable transition, all you have to do is place a <code>&lt;transition&gt;</code> or <code>&lt;transition-group&gt;</code> component at the root, then pass any children into the transition component.</p>
<p>Here's an example using a template component:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;my-special-transition&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">template</span><span class="op">:</span> <span class="st">&#39;\</span>
<span class="st">    &lt;transition\</span>
<span class="st">      name=&quot;very-special-transition&quot;\</span>
<span class="st">      mode=&quot;out-in&quot;\</span>
<span class="st">      v-on:before-enter=&quot;beforeEnter&quot;\</span>
<span class="st">      v-on:after-enter=&quot;afterEnter&quot;\</span>
<span class="st">    &gt;\</span>
<span class="st">      &lt;slot&gt;&lt;/slot&gt;\</span>
<span class="st">    &lt;/transition&gt;\</span>
<span class="st">  &#39;</span><span class="op">,</span>
  <span class="dt">methods</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">beforeEnter</span><span class="op">:</span> <span class="kw">function</span> (el) <span class="op">{</span>
      <span class="co">// ...</span>
    <span class="op">},</span>
    <span class="dt">afterEnter</span><span class="op">:</span> <span class="kw">function</span> (el) <span class="op">{</span>
      <span class="co">// ...</span>
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>And <a href="render-function.html#Functional-Components">functional components</a> are especially well-suited to this task:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;my-special-transition&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">functional</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
  <span class="dt">render</span><span class="op">:</span> <span class="kw">function</span> (createElement<span class="op">,</span> context) <span class="op">{</span>
    <span class="kw">var</span> data <span class="op">=</span> <span class="op">{</span>
      <span class="dt">props</span><span class="op">:</span> <span class="op">{</span>
        <span class="dt">name</span><span class="op">:</span> <span class="st">&#39;very-special-transition&#39;</span><span class="op">,</span>
        <span class="dt">mode</span><span class="op">:</span> <span class="st">&#39;out-in&#39;</span>
      <span class="op">},</span>
      <span class="dt">on</span><span class="op">:</span> <span class="op">{</span>
        <span class="dt">beforeEnter</span><span class="op">:</span> <span class="kw">function</span> (el) <span class="op">{</span>
          <span class="co">// ...</span>
        <span class="op">},</span>
        <span class="dt">afterEnter</span><span class="op">:</span> <span class="kw">function</span> (el) <span class="op">{</span>
          <span class="co">// ...</span>
        <span class="op">}</span>
      <span class="op">}</span>
    <span class="op">}</span>
    <span class="cf">return</span> <span class="at">createElement</span>(<span class="st">&#39;transition&#39;</span><span class="op">,</span> data<span class="op">,</span> <span class="va">context</span>.<span class="at">children</span>)
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<h2 id="dynamic-transitions">Dynamic Transitions</h2>
<p>Yes, even transitions in Vue are data-driven! The most basic example of a dynamic transition binds the <code>name</code> attribute to a dynamic property.</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;transition</span><span class="ot"> v-bind:name=</span><span class="st">&quot;transitionName&quot;</span><span class="kw">&gt;</span>
  <span class="co">&lt;!-- ... --&gt;</span>
<span class="kw">&lt;/transition&gt;</span></code></pre></div>
<p>This can be useful when you've defined CSS transitions/animations using Vue's transition class conventions and want to switch between them.</p>
<p>Really though, any transition attribute can be dynamically bound. And it's not only attributes. Since event hooks are methods, they have access to any data in the context. That means depending on the state of your component, your JavaScript transitions can behave differently.</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js&quot;</span><span class="kw">&gt;&lt;/script&gt;</span>

<span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;dynamic-fade-demo&quot;</span><span class="ot"> class=</span><span class="st">&quot;demo&quot;</span><span class="kw">&gt;</span>
  Fade In: <span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&quot;range&quot;</span><span class="ot"> v-model=</span><span class="st">&quot;fadeInDuration&quot;</span><span class="ot"> min=</span><span class="st">&quot;0&quot;</span><span class="ot"> v-bind:max=</span><span class="st">&quot;maxFadeDuration&quot;</span><span class="kw">&gt;</span>
  Fade Out: <span class="kw">&lt;input</span><span class="ot"> type=</span><span class="st">&quot;range&quot;</span><span class="ot"> v-model=</span><span class="st">&quot;fadeOutDuration&quot;</span><span class="ot"> min=</span><span class="st">&quot;0&quot;</span><span class="ot"> v-bind:max=</span><span class="st">&quot;maxFadeDuration&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;transition</span>
<span class="ot">    v-bind:css=</span><span class="st">&quot;false&quot;</span>
<span class="ot">    v-on:before-enter=</span><span class="st">&quot;beforeEnter&quot;</span>
<span class="ot">    v-on:enter=</span><span class="st">&quot;enter&quot;</span>
<span class="ot">    v-on:leave=</span><span class="st">&quot;leave&quot;</span>
  <span class="kw">&gt;</span>
    <span class="kw">&lt;p</span><span class="ot"> v-if=</span><span class="st">&quot;show&quot;</span><span class="kw">&gt;</span>hello<span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;/transition&gt;</span>
  <span class="kw">&lt;button</span>
<span class="ot">    v-if=</span><span class="st">&quot;stop&quot;</span>
<span class="ot">    v-on:click=</span><span class="st">&quot;stop = false; show = false&quot;</span>
  <span class="kw">&gt;</span>Start animating<span class="kw">&lt;/button&gt;</span>
  <span class="kw">&lt;button</span>
<span class="ot">    v-else</span>
<span class="ot">    v-on:click=</span><span class="st">&quot;stop = true&quot;</span>
  <span class="kw">&gt;</span>Stop it!<span class="kw">&lt;/button&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#dynamic-fade-demo&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">show</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
    <span class="dt">fadeInDuration</span><span class="op">:</span> <span class="dv">1000</span><span class="op">,</span>
    <span class="dt">fadeOutDuration</span><span class="op">:</span> <span class="dv">1000</span><span class="op">,</span>
    <span class="dt">maxFadeDuration</span><span class="op">:</span> <span class="dv">1500</span><span class="op">,</span>
    <span class="dt">stop</span><span class="op">:</span> <span class="kw">true</span>
  <span class="op">},</span>
  <span class="dt">mounted</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="kw">this</span>.<span class="at">show</span> <span class="op">=</span> <span class="kw">false</span>
  <span class="op">},</span>
  <span class="dt">methods</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">beforeEnter</span><span class="op">:</span> <span class="kw">function</span> (el) <span class="op">{</span>
      <span class="va">el</span>.<span class="va">style</span>.<span class="at">opacity</span> <span class="op">=</span> <span class="dv">0</span>
    <span class="op">},</span>
    <span class="dt">enter</span><span class="op">:</span> <span class="kw">function</span> (el<span class="op">,</span> done) <span class="op">{</span>
      <span class="kw">var</span> vm <span class="op">=</span> <span class="kw">this</span>
      <span class="at">Velocity</span>(el<span class="op">,</span>
        <span class="op">{</span> <span class="dt">opacity</span><span class="op">:</span> <span class="dv">1</span> <span class="op">},</span>
        <span class="op">{</span>
          <span class="dt">duration</span><span class="op">:</span> <span class="kw">this</span>.<span class="at">fadeInDuration</span><span class="op">,</span>
          <span class="dt">complete</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
            <span class="at">done</span>()
            <span class="cf">if</span> (<span class="op">!</span><span class="va">vm</span>.<span class="at">stop</span>) <span class="va">vm</span>.<span class="at">show</span> <span class="op">=</span> <span class="kw">false</span>
          <span class="op">}</span>
        <span class="op">}</span>
      )
    <span class="op">},</span>
    <span class="dt">leave</span><span class="op">:</span> <span class="kw">function</span> (el<span class="op">,</span> done) <span class="op">{</span>
      <span class="kw">var</span> vm <span class="op">=</span> <span class="kw">this</span>
      <span class="at">Velocity</span>(el<span class="op">,</span>
        <span class="op">{</span> <span class="dt">opacity</span><span class="op">:</span> <span class="dv">0</span> <span class="op">},</span>
        <span class="op">{</span>
          <span class="dt">duration</span><span class="op">:</span> <span class="kw">this</span>.<span class="at">fadeOutDuration</span><span class="op">,</span>
          <span class="dt">complete</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
            <span class="at">done</span>()
            <span class="va">vm</span>.<span class="at">show</span> <span class="op">=</span> <span class="kw">true</span>
          <span class="op">}</span>
        <span class="op">}</span>
      )
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>Finally, the ultimate way of creating dynamic transitions is through components that accept props to change the nature of the transition(s) to be used. It may sound cheesy, but the only limit really is your imagination.</p>
<h1 id="state-transitions"><a name=#guide/transitioning-state.md></a>State Transitions</h1>
<p>Vue's transition system offers many simple ways to animate entering, leaving, and lists, but what about animating your data itself? For example:</p>
<ul>
<li>numbers and calculations</li>
<li>colors displayed</li>
<li>the positions of SVG nodes</li>
<li>the sizes and other properties of elements</li>
</ul>
<p>All of these are either already stored as raw numbers or can be converted into numbers. Once we do that, we can animate these state changes using 3rd-party libraries to tween state, in combination with Vue's reactivity and component systems.</p>
<h2 id="animating-state-with-watchers">Animating State with Watchers</h2>
<p>Watchers allow us to animate changes of any numerical property into another property. That may sound complicated in the abstract, so let's dive into an example using <a href="https://greensock.com/">GreenSock</a>:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;https://cdnjs.cloudflare.com/ajax/libs/gsap/3.2.4/gsap.min.js&quot;</span><span class="kw">&gt;&lt;/script&gt;</span>

<span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;animated-number-demo&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;input</span><span class="ot"> v-model.number=</span><span class="st">&quot;number&quot;</span><span class="ot"> type=</span><span class="st">&quot;number&quot;</span><span class="ot"> step=</span><span class="st">&quot;20&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;p&gt;</span>{{ animatedNumber }}<span class="kw">&lt;/p&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#animated-number-demo&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">number</span><span class="op">:</span> <span class="dv">0</span><span class="op">,</span>
    <span class="dt">tweenedNumber</span><span class="op">:</span> <span class="dv">0</span>
  <span class="op">},</span>
  <span class="dt">computed</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">animatedNumber</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span>
      <span class="cf">return</span> <span class="kw">this</span>.<span class="va">tweenedNumber</span>.<span class="at">toFixed</span>(<span class="dv">0</span>)<span class="op">;</span>
    <span class="op">}</span>
  <span class="op">},</span>
  <span class="dt">watch</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">number</span><span class="op">:</span> <span class="kw">function</span>(newValue) <span class="op">{</span>
      <span class="va">gsap</span>.<span class="at">to</span>(<span class="kw">this</span>.<span class="at">$data</span><span class="op">,</span> <span class="op">{</span> <span class="dt">duration</span><span class="op">:</span> <span class="fl">0.5</span><span class="op">,</span> <span class="dt">tweenedNumber</span><span class="op">:</span> newValue <span class="op">}</span>)<span class="op">;</span>
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>When you update the number, the change is animated below the input. This makes for a nice demo, but what about something that isn't directly stored as a number, like any valid CSS color for example? Here's how we could accomplish this with <a href="https://github.com/tweenjs/tween.js">Tween.js</a> and <a href="https://github.com/brehaut/color-js">Color.js</a>:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;https://cdn.jsdelivr.net/npm/tween.js@16.3.4&quot;</span><span class="kw">&gt;&lt;/script&gt;</span>
<span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;https://cdn.jsdelivr.net/npm/color-js@1.0.3&quot;</span><span class="kw">&gt;&lt;/script&gt;</span>

<span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;example-7&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;input</span>
<span class="ot">    v-model=</span><span class="st">&quot;colorQuery&quot;</span>
<span class="ot">    v-on:keyup.enter=</span><span class="st">&quot;updateColor&quot;</span>
<span class="ot">    placeholder=</span><span class="st">&quot;Enter a color&quot;</span>
  <span class="kw">&gt;</span>
  <span class="kw">&lt;button</span><span class="ot"> v-on:click=</span><span class="st">&quot;updateColor&quot;</span><span class="kw">&gt;</span>Update<span class="kw">&lt;/button&gt;</span>
  <span class="kw">&lt;p&gt;</span>Preview:<span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;span</span>
<span class="ot">    v-bind:style=</span><span class="st">&quot;{ backgroundColor: tweenedCSSColor }&quot;</span>
<span class="ot">    class=</span><span class="st">&quot;example-7-color-preview&quot;</span>
  <span class="kw">&gt;&lt;/span&gt;</span>
  <span class="kw">&lt;p&gt;</span>{{ tweenedCSSColor }}<span class="kw">&lt;/p&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> Color <span class="op">=</span> <span class="va">net</span>.<span class="va">brehaut</span>.<span class="at">Color</span>

<span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#example-7&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">colorQuery</span><span class="op">:</span> <span class="st">&#39;&#39;</span><span class="op">,</span>
    <span class="dt">color</span><span class="op">:</span> <span class="op">{</span>
      <span class="dt">red</span><span class="op">:</span> <span class="dv">0</span><span class="op">,</span>
      <span class="dt">green</span><span class="op">:</span> <span class="dv">0</span><span class="op">,</span>
      <span class="dt">blue</span><span class="op">:</span> <span class="dv">0</span><span class="op">,</span>
      <span class="dt">alpha</span><span class="op">:</span> <span class="dv">1</span>
    <span class="op">},</span>
    <span class="dt">tweenedColor</span><span class="op">:</span> <span class="op">{}</span>
  <span class="op">},</span>
  <span class="dt">created</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="kw">this</span>.<span class="at">tweenedColor</span> <span class="op">=</span> <span class="va">Object</span>.<span class="at">assign</span>(<span class="op">{},</span> <span class="kw">this</span>.<span class="at">color</span>)
  <span class="op">},</span>
  <span class="dt">watch</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">color</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="kw">function</span> <span class="at">animate</span> () <span class="op">{</span>
        <span class="cf">if</span> (<span class="va">TWEEN</span>.<span class="at">update</span>()) <span class="op">{</span>
          <span class="at">requestAnimationFrame</span>(animate)
        <span class="op">}</span>
      <span class="op">}</span>

      <span class="kw">new</span> <span class="va">TWEEN</span>.<span class="at">Tween</span>(<span class="kw">this</span>.<span class="at">tweenedColor</span>)
        .<span class="at">to</span>(<span class="kw">this</span>.<span class="at">color</span><span class="op">,</span> <span class="dv">750</span>)
        .<span class="at">start</span>()

      <span class="at">animate</span>()
    <span class="op">}</span>
  <span class="op">},</span>
  <span class="dt">computed</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">tweenedCSSColor</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="cf">return</span> <span class="kw">new</span> <span class="at">Color</span>(<span class="op">{</span>
        <span class="dt">red</span><span class="op">:</span> <span class="kw">this</span>.<span class="va">tweenedColor</span>.<span class="at">red</span><span class="op">,</span>
        <span class="dt">green</span><span class="op">:</span> <span class="kw">this</span>.<span class="va">tweenedColor</span>.<span class="at">green</span><span class="op">,</span>
        <span class="dt">blue</span><span class="op">:</span> <span class="kw">this</span>.<span class="va">tweenedColor</span>.<span class="at">blue</span><span class="op">,</span>
        <span class="dt">alpha</span><span class="op">:</span> <span class="kw">this</span>.<span class="va">tweenedColor</span>.<span class="at">alpha</span>
      <span class="op">}</span>).<span class="at">toCSS</span>()
    <span class="op">}</span>
  <span class="op">},</span>
  <span class="dt">methods</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">updateColor</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="kw">this</span>.<span class="at">color</span> <span class="op">=</span> <span class="kw">new</span> <span class="at">Color</span>(<span class="kw">this</span>.<span class="at">colorQuery</span>).<span class="at">toRGB</span>()
      <span class="kw">this</span>.<span class="at">colorQuery</span> <span class="op">=</span> <span class="st">&#39;&#39;</span>
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode css"><code class="sourceCode css"><span class="fu">.example-7-color-preview</span> {
  <span class="kw">display</span>: <span class="dv">inline-block</span>;
  <span class="kw">width</span>: <span class="dv">50px</span>;
  <span class="kw">height</span>: <span class="dv">50px</span>;
}</code></pre></div>
<h2 id="dynamic-state-transitions">Dynamic State Transitions</h2>
<p>As with Vue's transition components, the data backing state transitions can be updated in real time, which is especially useful for prototyping! Even using a simple SVG polygon, you can achieve many effects that would be difficult to conceive of until you've played with the variables a little.</p>
<p>See <a href="https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-dynamic-state-transitions">this example</a> for the complete code behind the above demo.</p>
<h2 id="organizing-transitions-into-components">Organizing Transitions into Components</h2>
<p>Managing many state transitions can quickly increase the complexity of a Vue instance or component. Fortunately, many animations can be extracted out into dedicated child components. Let's do this with the animated integer from our earlier example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;https://cdn.jsdelivr.net/npm/tween.js@16.3.4&quot;</span><span class="kw">&gt;&lt;/script&gt;</span>

<span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;example-8&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;input</span><span class="ot"> v-model.number=</span><span class="st">&quot;firstNumber&quot;</span><span class="ot"> type=</span><span class="st">&quot;number&quot;</span><span class="ot"> step=</span><span class="st">&quot;20&quot;</span><span class="kw">&gt;</span> +
  <span class="kw">&lt;input</span><span class="ot"> v-model.number=</span><span class="st">&quot;secondNumber&quot;</span><span class="ot"> type=</span><span class="st">&quot;number&quot;</span><span class="ot"> step=</span><span class="st">&quot;20&quot;</span><span class="kw">&gt;</span> =
  {{ result }}
  <span class="kw">&lt;p&gt;</span>
    <span class="kw">&lt;animated-integer</span><span class="ot"> v-bind:value=</span><span class="st">&quot;firstNumber&quot;</span><span class="kw">&gt;&lt;/animated-integer&gt;</span> +
    <span class="kw">&lt;animated-integer</span><span class="ot"> v-bind:value=</span><span class="st">&quot;secondNumber&quot;</span><span class="kw">&gt;&lt;/animated-integer&gt;</span> =
    <span class="kw">&lt;animated-integer</span><span class="ot"> v-bind:value=</span><span class="st">&quot;result&quot;</span><span class="kw">&gt;&lt;/animated-integer&gt;</span>
  <span class="kw">&lt;/p&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// This complex tweening logic can now be reused between</span>
<span class="co">// any integers we may wish to animate in our application.</span>
<span class="co">// Components also offer a clean interface for configuring</span>
<span class="co">// more dynamic transitions and complex transition</span>
<span class="co">// strategies.</span>
<span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;animated-integer&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">template</span><span class="op">:</span> <span class="st">&#39;&lt;span&gt;{{ tweeningValue }}&lt;/span&gt;&#39;</span><span class="op">,</span>
  <span class="dt">props</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">value</span><span class="op">:</span> <span class="op">{</span>
      <span class="dt">type</span><span class="op">:</span> Number<span class="op">,</span>
      <span class="dt">required</span><span class="op">:</span> <span class="kw">true</span>
    <span class="op">}</span>
  <span class="op">},</span>
  <span class="dt">data</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="cf">return</span> <span class="op">{</span>
      <span class="dt">tweeningValue</span><span class="op">:</span> <span class="dv">0</span>
    <span class="op">}</span>
  <span class="op">},</span>
  <span class="dt">watch</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">value</span><span class="op">:</span> <span class="kw">function</span> (newValue<span class="op">,</span> oldValue) <span class="op">{</span>
      <span class="kw">this</span>.<span class="at">tween</span>(oldValue<span class="op">,</span> newValue)
    <span class="op">}</span>
  <span class="op">},</span>
  <span class="dt">mounted</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="kw">this</span>.<span class="at">tween</span>(<span class="dv">0</span><span class="op">,</span> <span class="kw">this</span>.<span class="at">value</span>)
  <span class="op">},</span>
  <span class="dt">methods</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">tween</span><span class="op">:</span> <span class="kw">function</span> (startValue<span class="op">,</span> endValue) <span class="op">{</span>
      <span class="kw">var</span> vm <span class="op">=</span> <span class="kw">this</span>
      <span class="kw">function</span> <span class="at">animate</span> () <span class="op">{</span>
        <span class="cf">if</span> (<span class="va">TWEEN</span>.<span class="at">update</span>()) <span class="op">{</span>
          <span class="at">requestAnimationFrame</span>(animate)
        <span class="op">}</span>
      <span class="op">}</span>

      <span class="kw">new</span> <span class="va">TWEEN</span>.<span class="at">Tween</span>(<span class="op">{</span> <span class="dt">tweeningValue</span><span class="op">:</span> startValue <span class="op">}</span>)
        .<span class="at">to</span>(<span class="op">{</span> <span class="dt">tweeningValue</span><span class="op">:</span> endValue <span class="op">},</span> <span class="dv">500</span>)
        .<span class="at">onUpdate</span>(<span class="kw">function</span> () <span class="op">{</span>
          <span class="va">vm</span>.<span class="at">tweeningValue</span> <span class="op">=</span> <span class="kw">this</span>.<span class="va">tweeningValue</span>.<span class="at">toFixed</span>(<span class="dv">0</span>)
        <span class="op">}</span>)
        .<span class="at">start</span>()

      <span class="at">animate</span>()
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)

<span class="co">// All complexity has now been removed from the main Vue instance!</span>
<span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#example-8&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">firstNumber</span><span class="op">:</span> <span class="dv">20</span><span class="op">,</span>
    <span class="dt">secondNumber</span><span class="op">:</span> <span class="dv">40</span>
  <span class="op">},</span>
  <span class="dt">computed</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">result</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="cf">return</span> <span class="kw">this</span>.<span class="at">firstNumber</span> <span class="op">+</span> <span class="kw">this</span>.<span class="at">secondNumber</span>
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>Within child components, we can use any combination of transition strategies that have been covered on this page, along with those offered by Vue's <a href="transitions.html">built-in transition system</a>. Together, there are very few limits to what can be accomplished.</p>
<h2 id="bringing-designs-to-life">Bringing Designs to Life</h2>
<p>To animate, by one definition, means to bring to life. Unfortunately, when designers create icons, logos, and mascots, they're usually delivered as images or static SVGs. So although GitHub's octocat, Twitter's bird, and many other logos resemble living creatures, they don't really seem alive.</p>
<p>Vue can help. Since SVGs are just data, we only need examples of what these creatures look like when excited, thinking, or alarmed. Then Vue can help transition between these states, making your welcome pages, loading indicators, and notifications more emotionally compelling.</p>
<p>Sarah Drasner demonstrates this in the demo below, using a combination of timed and interactivity-driven state changes:</p>
<p data-height="265" data-theme-id="light" data-slug-hash="YZBGNp" data-default-tab="result" data-user="sdras" data-embed-version="2" data-pen-title="Vue-controlled Wall-E" class="codepen">
See the Pen <a href="https://codepen.io/sdras/pen/YZBGNp/">Vue-controlled Wall-E</a> by Sarah Drasner (<a href="https://codepen.io/sdras"><span class="citation">@sdras</span></a>) on <a href="https://codepen.io">CodePen</a>.
</p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>
<h1 id="mixins"><a name=#guide/mixins.md></a>Mixins</h1>
<h2 id="basics">Basics</h2>
<p>Mixins are a flexible way to distribute reusable functionalities for Vue components. A mixin object can contain any component options. When a component uses a mixin, all options in the mixin will be &quot;mixed&quot; into the component's own options.</p>
<div class="vue-mastery">
<a href="https://www.vuemastery.com/courses/next-level-vue/mixins" target="_blank" rel="noopener" title="Mixins Tutorial">Watch a video explanation on Vue Mastery</a>
</div>
<p>Example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// define a mixin object</span>
<span class="kw">var</span> myMixin <span class="op">=</span> <span class="op">{</span>
  <span class="dt">created</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="kw">this</span>.<span class="at">hello</span>()
  <span class="op">},</span>
  <span class="dt">methods</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">hello</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;hello from mixin!&#39;</span>)
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>

<span class="co">// define a component that uses this mixin</span>
<span class="kw">var</span> Component <span class="op">=</span> <span class="va">Vue</span>.<span class="at">extend</span>(<span class="op">{</span>
  <span class="dt">mixins</span><span class="op">:</span> [myMixin]
<span class="op">}</span>)

<span class="kw">var</span> component <span class="op">=</span> <span class="kw">new</span> <span class="at">Component</span>() <span class="co">// =&gt; &quot;hello from mixin!&quot;</span></code></pre></div>
<h2 id="option-merging">Option Merging</h2>
<p>When a mixin and the component itself contain overlapping options, they will be &quot;merged&quot; using appropriate strategies.</p>
<p>For example, data objects undergo a recursive merge, with the component's data taking priority in cases of conflicts.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> mixin <span class="op">=</span> <span class="op">{</span>
  <span class="dt">data</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="cf">return</span> <span class="op">{</span>
      <span class="dt">message</span><span class="op">:</span> <span class="st">&#39;hello&#39;</span><span class="op">,</span>
      <span class="dt">foo</span><span class="op">:</span> <span class="st">&#39;abc&#39;</span>
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>

<span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">mixins</span><span class="op">:</span> [mixin]<span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="cf">return</span> <span class="op">{</span>
      <span class="dt">message</span><span class="op">:</span> <span class="st">&#39;goodbye&#39;</span><span class="op">,</span>
      <span class="dt">bar</span><span class="op">:</span> <span class="st">&#39;def&#39;</span>
    <span class="op">}</span>
  <span class="op">},</span>
  <span class="dt">created</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>(<span class="kw">this</span>.<span class="at">$data</span>)
    <span class="co">// =&gt; { message: &quot;goodbye&quot;, foo: &quot;abc&quot;, bar: &quot;def&quot; }</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>Hook functions with the same name are merged into an array so that all of them will be called. Mixin hooks will be called <strong>before</strong> the component's own hooks.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> mixin <span class="op">=</span> <span class="op">{</span>
  <span class="dt">created</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;mixin hook called&#39;</span>)
  <span class="op">}</span>
<span class="op">}</span>

<span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">mixins</span><span class="op">:</span> [mixin]<span class="op">,</span>
  <span class="dt">created</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;component hook called&#39;</span>)
  <span class="op">}</span>
<span class="op">}</span>)

<span class="co">// =&gt; &quot;mixin hook called&quot;</span>
<span class="co">// =&gt; &quot;component hook called&quot;</span></code></pre></div>
<p>Options that expect object values, for example <code>methods</code>, <code>components</code> and <code>directives</code>, will be merged into the same object. The component's options will take priority when there are conflicting keys in these objects:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> mixin <span class="op">=</span> <span class="op">{</span>
  <span class="dt">methods</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">foo</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;foo&#39;</span>)
    <span class="op">},</span>
    <span class="dt">conflicting</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;from mixin&#39;</span>)
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>

<span class="kw">var</span> vm <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">mixins</span><span class="op">:</span> [mixin]<span class="op">,</span>
  <span class="dt">methods</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">bar</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;bar&#39;</span>)
    <span class="op">},</span>
    <span class="dt">conflicting</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;from self&#39;</span>)
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)

<span class="va">vm</span>.<span class="at">foo</span>() <span class="co">// =&gt; &quot;foo&quot;</span>
<span class="va">vm</span>.<span class="at">bar</span>() <span class="co">// =&gt; &quot;bar&quot;</span>
<span class="va">vm</span>.<span class="at">conflicting</span>() <span class="co">// =&gt; &quot;from self&quot;</span></code></pre></div>
<p>Note that the same merge strategies are used in <code>Vue.extend()</code>.</p>
<h2 id="global-mixin">Global Mixin</h2>
<p>You can also apply a mixin globally. Use with caution! Once you apply a mixin globally, it will affect <strong>every</strong> Vue instance created afterwards. When used properly, this can be used to inject processing logic for custom options:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// inject a handler for `myOption` custom option</span>
<span class="va">Vue</span>.<span class="at">mixin</span>(<span class="op">{</span>
  <span class="dt">created</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="kw">var</span> myOption <span class="op">=</span> <span class="kw">this</span>.<span class="va">$options</span>.<span class="at">myOption</span>
    <span class="cf">if</span> (myOption) <span class="op">{</span>
      <span class="va">console</span>.<span class="at">log</span>(myOption)
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)

<span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">myOption</span><span class="op">:</span> <span class="st">&#39;hello!&#39;</span>
<span class="op">}</span>)
<span class="co">// =&gt; &quot;hello!&quot;</span></code></pre></div>
<p class="tip">
Use global mixins sparsely and carefully, because it affects every single Vue instance created, including third party components. In most cases, you should only use it for custom option handling like demonstrated in the example above. It's also a good idea to ship them as <a href="plugins.html">Plugins</a> to avoid duplicate application.
</p>
<h2 id="custom-option-merge-strategies">Custom Option Merge Strategies</h2>
<p>When custom options are merged, they use the default strategy which overwrites the existing value. If you want a custom option to be merged using custom logic, you need to attach a function to <code>Vue.config.optionMergeStrategies</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="va">config</span>.<span class="va">optionMergeStrategies</span>.<span class="at">myOption</span> <span class="op">=</span> <span class="kw">function</span> (toVal<span class="op">,</span> fromVal) <span class="op">{</span>
  <span class="co">// return mergedVal</span>
<span class="op">}</span></code></pre></div>
<p>For most object-based options, you can use the same strategy used by <code>methods</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> strategies <span class="op">=</span> <span class="va">Vue</span>.<span class="va">config</span>.<span class="at">optionMergeStrategies</span>
<span class="va">strategies</span>.<span class="at">myOption</span> <span class="op">=</span> <span class="va">strategies</span>.<span class="at">methods</span></code></pre></div>
<p>A more advanced example can be found on <a href="https://github.com/vuejs/vuex">Vuex</a>'s 1.x merging strategy:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">const</span> merge <span class="op">=</span> <span class="va">Vue</span>.<span class="va">config</span>.<span class="va">optionMergeStrategies</span>.<span class="at">computed</span>
<span class="va">Vue</span>.<span class="va">config</span>.<span class="va">optionMergeStrategies</span>.<span class="at">vuex</span> <span class="op">=</span> <span class="kw">function</span> (toVal<span class="op">,</span> fromVal) <span class="op">{</span>
  <span class="cf">if</span> (<span class="op">!</span>toVal) <span class="cf">return</span> fromVal
  <span class="cf">if</span> (<span class="op">!</span>fromVal) <span class="cf">return</span> toVal
  <span class="cf">return</span> <span class="op">{</span>
    <span class="dt">getters</span><span class="op">:</span> <span class="at">merge</span>(<span class="va">toVal</span>.<span class="at">getters</span><span class="op">,</span> <span class="va">fromVal</span>.<span class="at">getters</span>)<span class="op">,</span>
    <span class="dt">state</span><span class="op">:</span> <span class="at">merge</span>(<span class="va">toVal</span>.<span class="at">state</span><span class="op">,</span> <span class="va">fromVal</span>.<span class="at">state</span>)<span class="op">,</span>
    <span class="dt">actions</span><span class="op">:</span> <span class="at">merge</span>(<span class="va">toVal</span>.<span class="at">actions</span><span class="op">,</span> <span class="va">fromVal</span>.<span class="at">actions</span>)
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<h1 id="custom-directives"><a name=#guide/custom-directive.md></a>Custom Directives</h1>
<h2 id="intro">Intro</h2>
<div class="vueschool">
<a href="https://vueschool.io/lessons/create-vuejs-directive?friend=vuejs" target="_blank" rel="sponsored noopener" title="Free Vue.js Custom Directives lesson">Watch a free video lesson on Vue School</a>
</div>
<p>In addition to the default set of directives shipped in core (<code>v-model</code> and <code>v-show</code>), Vue also allows you to register your own custom directives. Note that in Vue 2.0, the primary form of code reuse and abstraction is components - however there may be cases where you need some low-level DOM access on plain elements, and this is where custom directives would still be useful. An example would be focusing on an input element, like this one:</p>
<p>When the page loads, that element gains focus (note: <code>autofocus</code> doesn't work on mobile Safari). In fact, if you haven't clicked on anything else since visiting this page, the input above should be focused now. Now let's build the directive that accomplishes this:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// Register a global custom directive called `v-focus`</span>
<span class="va">Vue</span>.<span class="at">directive</span>(<span class="st">&#39;focus&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="co">// When the bound element is inserted into the DOM...</span>
  <span class="dt">inserted</span><span class="op">:</span> <span class="kw">function</span> (el) <span class="op">{</span>
    <span class="co">// Focus the element</span>
    <span class="va">el</span>.<span class="at">focus</span>()
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>If you want to register a directive locally instead, components also accept a <code>directives</code> option:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">directives<span class="op">:</span> <span class="op">{</span>
  <span class="dt">focus</span><span class="op">:</span> <span class="op">{</span>
    <span class="co">// directive definition</span>
    <span class="dt">inserted</span><span class="op">:</span> <span class="kw">function</span> (el) <span class="op">{</span>
      <span class="va">el</span>.<span class="at">focus</span>()
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>Then in a template, you can use the new <code>v-focus</code> attribute on any element, like this:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;input</span><span class="ot"> v-focus</span><span class="kw">&gt;</span></code></pre></div>
<h2 id="hook-functions">Hook Functions</h2>
<p>A directive definition object can provide several hook functions (all optional):</p>
<ul>
<li><p><code>bind</code>: called only once, when the directive is first bound to the element. This is where you can do one-time setup work.</p></li>
<li><p><code>inserted</code>: called when the bound element has been inserted into its parent node (this only guarantees parent node presence, not necessarily in-document).</p></li>
<li><p><code>update</code>: called after the containing component's VNode has updated, <strong>but possibly before its children have updated</strong>. The directive's value may or may not have changed, but you can skip unnecessary updates by comparing the binding's current and old values (see below on hook arguments).</p></li>
</ul>
<p class="tip">
We'll cover VNodes in more detail <a href="./render-function.html#The-Virtual-DOM">later</a>, when we discuss <a href="./render-function.html">render functions</a>.
</p>
<ul>
<li><p><code>componentUpdated</code>: called after the containing component's VNode <strong>and the VNodes of its children</strong> have updated.</p></li>
<li><p><code>unbind</code>: called only once, when the directive is unbound from the element.</p></li>
</ul>
<p>We'll explore the arguments passed into these hooks (i.e. <code>el</code>, <code>binding</code>, <code>vnode</code>, and <code>oldVnode</code>) in the next section.</p>
<h2 id="directive-hook-arguments">Directive Hook Arguments</h2>
<p>Directive hooks are passed these arguments:</p>
<ul>
<li><code>el</code>: The element the directive is bound to. This can be used to directly manipulate the DOM.</li>
<li><code>binding</code>: An object containing the following properties.</li>
<li><code>name</code>: The name of the directive, without the <code>v-</code> prefix.</li>
<li><code>value</code>: The value passed to the directive. For example in <code>v-my-directive=&quot;1 + 1&quot;</code>, the value would be <code>2</code>.</li>
<li><code>oldValue</code>: The previous value, only available in <code>update</code> and <code>componentUpdated</code>. It is available whether or not the value has changed.</li>
<li><code>expression</code>: The expression of the binding as a string. For example in <code>v-my-directive=&quot;1 + 1&quot;</code>, the expression would be <code>&quot;1 + 1&quot;</code>.</li>
<li><code>arg</code>: The argument passed to the directive, if any. For example in <code>v-my-directive:foo</code>, the arg would be <code>&quot;foo&quot;</code>.</li>
<li><code>modifiers</code>: An object containing modifiers, if any. For example in <code>v-my-directive.foo.bar</code>, the modifiers object would be <code>{ foo: true, bar: true }</code>.</li>
<li><code>vnode</code>: The virtual node produced by Vue's compiler. See the <a href="../api/#VNode-Interface">VNode API</a> for full details.</li>
<li><code>oldVnode</code>: The previous virtual node, only available in the <code>update</code> and <code>componentUpdated</code> hooks.</li>
</ul>
<p class="tip">
Apart from <code>el</code>, you should treat these arguments as read-only and never modify them. If you need to share information across hooks, it is recommended to do so through element's <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset">dataset</a>.
</p>
<p>An example of a custom directive using some of these properties:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;hook-arguments-example&quot;</span><span class="ot"> v-demo:foo.a.b=</span><span class="st">&quot;message&quot;</span><span class="kw">&gt;&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">directive</span>(<span class="st">&#39;demo&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">bind</span><span class="op">:</span> <span class="kw">function</span> (el<span class="op">,</span> binding<span class="op">,</span> vnode) <span class="op">{</span>
    <span class="kw">var</span> s <span class="op">=</span> <span class="va">JSON</span>.<span class="at">stringify</span>
    <span class="va">el</span>.<span class="at">innerHTML</span> <span class="op">=</span>
      <span class="st">&#39;name: &#39;</span>       <span class="op">+</span> <span class="at">s</span>(<span class="va">binding</span>.<span class="at">name</span>) <span class="op">+</span> <span class="st">&#39;&lt;br&gt;&#39;</span> <span class="op">+</span>
      <span class="st">&#39;value: &#39;</span>      <span class="op">+</span> <span class="at">s</span>(<span class="va">binding</span>.<span class="at">value</span>) <span class="op">+</span> <span class="st">&#39;&lt;br&gt;&#39;</span> <span class="op">+</span>
      <span class="st">&#39;expression: &#39;</span> <span class="op">+</span> <span class="at">s</span>(<span class="va">binding</span>.<span class="at">expression</span>) <span class="op">+</span> <span class="st">&#39;&lt;br&gt;&#39;</span> <span class="op">+</span>
      <span class="st">&#39;argument: &#39;</span>   <span class="op">+</span> <span class="at">s</span>(<span class="va">binding</span>.<span class="at">arg</span>) <span class="op">+</span> <span class="st">&#39;&lt;br&gt;&#39;</span> <span class="op">+</span>
      <span class="st">&#39;modifiers: &#39;</span>  <span class="op">+</span> <span class="at">s</span>(<span class="va">binding</span>.<span class="at">modifiers</span>) <span class="op">+</span> <span class="st">&#39;&lt;br&gt;&#39;</span> <span class="op">+</span>
      <span class="st">&#39;vnode keys: &#39;</span> <span class="op">+</span> <span class="va">Object</span>.<span class="at">keys</span>(vnode).<span class="at">join</span>(<span class="st">&#39;, &#39;</span>)
  <span class="op">}</span>
<span class="op">}</span>)

<span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#hook-arguments-example&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">message</span><span class="op">:</span> <span class="st">&#39;hello!&#39;</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<h3 id="dynamic-directive-arguments">Dynamic Directive Arguments</h3>
<p>Directive arguments can be dynamic. For example, in <code>v-mydirective:[argument]=&quot;value&quot;</code>, the <code>argument</code> can be updated based on data properties in our component instance! This makes our custom directives flexible for use throughout our application.</p>
<p>Let's say you want to make a custom directive that allows you to pin elements to your page using fixed positioning. We could create a custom directive where the value updates the vertical positioning in pixels, like this:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;baseexample&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;p&gt;</span>Scroll down the page<span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;p</span><span class="ot"> v-pin=</span><span class="st">&quot;200&quot;</span><span class="kw">&gt;</span>Stick me 200px from the top of the page<span class="kw">&lt;/p&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">directive</span>(<span class="st">&#39;pin&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">bind</span><span class="op">:</span> <span class="kw">function</span> (el<span class="op">,</span> binding<span class="op">,</span> vnode) <span class="op">{</span>
    <span class="va">el</span>.<span class="va">style</span>.<span class="at">position</span> <span class="op">=</span> <span class="st">&#39;fixed&#39;</span>
    <span class="va">el</span>.<span class="va">style</span>.<span class="at">top</span> <span class="op">=</span> <span class="va">binding</span>.<span class="at">value</span> <span class="op">+</span> <span class="st">&#39;px&#39;</span>
  <span class="op">}</span>
<span class="op">}</span>)

<span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#baseexample&#39;</span>
<span class="op">}</span>)</code></pre></div>
<p>This would pin the element 200px from the top of the page. But what happens if we run into a scenario when we need to pin the element from the left, instead of the top? Here's where a dynamic argument that can be updated per component instance comes in very handy:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;dynamicexample&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;h3&gt;</span>Scroll down inside this section ↓<span class="kw">&lt;/h3&gt;</span>
  <span class="kw">&lt;p</span><span class="ot"> v-pin:</span><span class="er">[direction]</span><span class="ot">=</span><span class="st">&quot;200&quot;</span><span class="kw">&gt;</span>I am pinned onto the page at 200px to the left.<span class="kw">&lt;/p&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">directive</span>(<span class="st">&#39;pin&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">bind</span><span class="op">:</span> <span class="kw">function</span> (el<span class="op">,</span> binding<span class="op">,</span> vnode) <span class="op">{</span>
    <span class="va">el</span>.<span class="va">style</span>.<span class="at">position</span> <span class="op">=</span> <span class="st">&#39;fixed&#39;</span>
    <span class="kw">var</span> s <span class="op">=</span> (<span class="va">binding</span>.<span class="at">arg</span> <span class="op">==</span> <span class="st">&#39;left&#39;</span> <span class="op">?</span> <span class="st">&#39;left&#39;</span> : <span class="st">&#39;top&#39;</span>)
    <span class="va">el</span>.<span class="at">style</span>[s] <span class="op">=</span> <span class="va">binding</span>.<span class="at">value</span> <span class="op">+</span> <span class="st">&#39;px&#39;</span>
  <span class="op">}</span>
<span class="op">}</span>)

<span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#dynamicexample&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="cf">return</span> <span class="op">{</span>
      <span class="dt">direction</span><span class="op">:</span> <span class="st">&#39;left&#39;</span>
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>Result:</p>
<p>Our custom directive is now flexible enough to support a few different use cases.</p>
<h2 id="function-shorthand">Function Shorthand</h2>
<p>In many cases, you may want the same behavior on <code>bind</code> and <code>update</code>, but don't care about the other hooks. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">directive</span>(<span class="st">&#39;color-swatch&#39;</span><span class="op">,</span> <span class="kw">function</span> (el<span class="op">,</span> binding) <span class="op">{</span>
  <span class="va">el</span>.<span class="va">style</span>.<span class="at">backgroundColor</span> <span class="op">=</span> <span class="va">binding</span>.<span class="at">value</span>
<span class="op">}</span>)</code></pre></div>
<h2 id="object-literals">Object Literals</h2>
<p>If your directive needs multiple values, you can also pass in a JavaScript object literal. Remember, directives can take any valid JavaScript expression.</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> v-demo=</span><span class="st">&quot;{ color: &#39;white&#39;, text: &#39;hello!&#39; }&quot;</span><span class="kw">&gt;&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">directive</span>(<span class="st">&#39;demo&#39;</span><span class="op">,</span> <span class="kw">function</span> (el<span class="op">,</span> binding) <span class="op">{</span>
  <span class="va">console</span>.<span class="at">log</span>(<span class="va">binding</span>.<span class="va">value</span>.<span class="at">color</span>) <span class="co">// =&gt; &quot;white&quot;</span>
  <span class="va">console</span>.<span class="at">log</span>(<span class="va">binding</span>.<span class="va">value</span>.<span class="at">text</span>)  <span class="co">// =&gt; &quot;hello!&quot;</span>
<span class="op">}</span>)</code></pre></div>
<h1 id="render-functions-jsx"><a name=#guide/render-function.md></a>Render Functions &amp; JSX</h1>
<h2 id="basics-1">Basics</h2>
<p>Vue recommends using templates to build your HTML in the vast majority of cases. There are situations however, where you really need the full programmatic power of JavaScript. That's where you can use the <strong>render function</strong>, a closer-to-the-compiler alternative to templates.</p>
<p>Let's dive into a simple example where a <code>render</code> function would be practical. Say you want to generate anchored headings:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;h1&gt;</span>
  <span class="kw">&lt;a</span><span class="ot"> name=</span><span class="st">&quot;hello-world&quot;</span><span class="ot"> href=</span><span class="st">&quot;#hello-world&quot;</span><span class="kw">&gt;</span>
    Hello world!
  <span class="kw">&lt;/a&gt;</span>
<span class="kw">&lt;/h1&gt;</span></code></pre></div>
<p>For the HTML above, you decide you want this component interface:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;anchored-heading</span><span class="ot"> :level=</span><span class="st">&quot;1&quot;</span><span class="kw">&gt;</span>Hello world!<span class="kw">&lt;/anchored-heading&gt;</span></code></pre></div>
<p>When you get started with a component that only generates a heading based on the <code>level</code> prop, you quickly arrive at this:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;script</span><span class="ot"> type=</span><span class="st">&quot;text/x-template&quot;</span><span class="ot"> id=</span><span class="st">&quot;anchored-heading-template&quot;</span><span class="kw">&gt;</span>
  <span class="op">&lt;</span>h1 v<span class="op">-</span><span class="cf">if</span><span class="op">=</span><span class="st">&quot;level === 1&quot;</span><span class="op">&gt;</span>
    <span class="op">&lt;</span>slot<span class="op">&gt;&lt;</span><span class="ss">/slot&gt;</span>
<span class="ss">  &lt;/h1</span><span class="op">&gt;</span>
  <span class="op">&lt;</span>h2 v<span class="op">-</span><span class="cf">else</span><span class="op">-</span><span class="cf">if</span><span class="op">=</span><span class="st">&quot;level === 2&quot;</span><span class="op">&gt;</span>
    <span class="op">&lt;</span>slot<span class="op">&gt;&lt;</span><span class="ss">/slot&gt;</span>
<span class="ss">  &lt;/h2</span><span class="op">&gt;</span>
  <span class="op">&lt;</span>h3 v<span class="op">-</span><span class="cf">else</span><span class="op">-</span><span class="cf">if</span><span class="op">=</span><span class="st">&quot;level === 3&quot;</span><span class="op">&gt;</span>
    <span class="op">&lt;</span>slot<span class="op">&gt;&lt;</span><span class="ss">/slot&gt;</span>
<span class="ss">  &lt;/h3</span><span class="op">&gt;</span>
  <span class="op">&lt;</span>h4 v<span class="op">-</span><span class="cf">else</span><span class="op">-</span><span class="cf">if</span><span class="op">=</span><span class="st">&quot;level === 4&quot;</span><span class="op">&gt;</span>
    <span class="op">&lt;</span>slot<span class="op">&gt;&lt;</span><span class="ss">/slot&gt;</span>
<span class="ss">  &lt;/h4</span><span class="op">&gt;</span>
  <span class="op">&lt;</span>h5 v<span class="op">-</span><span class="cf">else</span><span class="op">-</span><span class="cf">if</span><span class="op">=</span><span class="st">&quot;level === 5&quot;</span><span class="op">&gt;</span>
    <span class="op">&lt;</span>slot<span class="op">&gt;&lt;</span><span class="ss">/slot&gt;</span>
<span class="ss">  &lt;/h5</span><span class="op">&gt;</span>
  <span class="op">&lt;</span>h6 v<span class="op">-</span><span class="cf">else</span><span class="op">-</span><span class="cf">if</span><span class="op">=</span><span class="st">&quot;level === 6&quot;</span><span class="op">&gt;</span>
    <span class="op">&lt;</span>slot<span class="op">&gt;&lt;</span><span class="ss">/slot&gt;</span>
<span class="ss">  &lt;/h6</span><span class="op">&gt;</span>
<span class="kw">&lt;/script&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;anchored-heading&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">template</span><span class="op">:</span> <span class="st">&#39;#anchored-heading-template&#39;</span><span class="op">,</span>
  <span class="dt">props</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">level</span><span class="op">:</span> <span class="op">{</span>
      <span class="dt">type</span><span class="op">:</span> Number<span class="op">,</span>
      <span class="dt">required</span><span class="op">:</span> <span class="kw">true</span>
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>That template doesn't feel great. It's not only verbose, but we're duplicating <code>&lt;slot&gt;&lt;/slot&gt;</code> for every heading level and will have to do the same when we add the anchor element.</p>
<p>While templates work great for most components, it's clear that this isn't one of them. So let's try rewriting it with a <code>render</code> function:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;anchored-heading&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">render</span><span class="op">:</span> <span class="kw">function</span> (createElement) <span class="op">{</span>
    <span class="cf">return</span> <span class="at">createElement</span>(
      <span class="st">&#39;h&#39;</span> <span class="op">+</span> <span class="kw">this</span>.<span class="at">level</span><span class="op">,</span>   <span class="co">// tag name</span>
      <span class="kw">this</span>.<span class="va">$slots</span>.<span class="at">default</span> <span class="co">// array of children</span>
    )
  <span class="op">},</span>
  <span class="dt">props</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">level</span><span class="op">:</span> <span class="op">{</span>
      <span class="dt">type</span><span class="op">:</span> Number<span class="op">,</span>
      <span class="dt">required</span><span class="op">:</span> <span class="kw">true</span>
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>Much simpler! Sort of. The code is shorter, but also requires greater familiarity with Vue instance properties. In this case, you have to know that when you pass children without a <code>v-slot</code> directive into a component, like the <code>Hello world!</code> inside of <code>anchored-heading</code>, those children are stored on the component instance at <code>$slots.default</code>. If you haven't already, <strong>it's recommended to read through the <a href="../api/#Instance-Properties">instance properties API</a> before diving into render functions.</strong></p>
<h2 id="nodes-trees-and-the-virtual-dom">Nodes, Trees, and the Virtual DOM</h2>
<p>Before we dive into render functions, it’s important to know a little about how browsers work. Take this HTML for example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div&gt;</span>
  <span class="kw">&lt;h1&gt;</span>My title<span class="kw">&lt;/h1&gt;</span>
  Some text content
  <span class="co">&lt;!-- </span><span class="al">TODO</span><span class="co">: Add tagline  --&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<p>When a browser reads this code, it builds a <a href="https://javascript.info/dom-nodes">tree of &quot;DOM nodes&quot;</a> to help it keep track of everything, just as you might build a family tree to keep track of your extended family.</p>
<p>The tree of DOM nodes for the HTML above looks like this:</p>
<div class="figure">
<img src="../images/dom-tree.png" alt="DOM Tree Visualization" />
<p class="caption">DOM Tree Visualization</p>
</div>
<p>Every element is a node. Every piece of text is a node. Even comments are nodes! A node is just a piece of the page. And as in a family tree, each node can have children (i.e. each piece can contain other pieces).</p>
<p>Updating all these nodes efficiently can be difficult, but thankfully, you never have to do it manually. Instead, you tell Vue what HTML you want on the page, in a template:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;h1&gt;</span>{{ blogTitle }}<span class="kw">&lt;/h1&gt;</span></code></pre></div>
<p>Or a render function:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">render<span class="op">:</span> <span class="kw">function</span> (createElement) <span class="op">{</span>
  <span class="cf">return</span> <span class="at">createElement</span>(<span class="st">&#39;h1&#39;</span><span class="op">,</span> <span class="kw">this</span>.<span class="at">blogTitle</span>)
<span class="op">}</span></code></pre></div>
<p>And in both cases, Vue automatically keeps the page updated, even when <code>blogTitle</code> changes.</p>
<h3 id="the-virtual-dom">The Virtual DOM</h3>
<p>Vue accomplishes this by building a <strong>virtual DOM</strong> to keep track of the changes it needs to make to the real DOM. Taking a closer look at this line:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">return</span> <span class="at">createElement</span>(<span class="st">&#39;h1&#39;</span><span class="op">,</span> <span class="kw">this</span>.<span class="at">blogTitle</span>)</code></pre></div>
<p>What is <code>createElement</code> actually returning? It's not <em>exactly</em> a real DOM element. It could perhaps more accurately be named <code>createNodeDescription</code>, as it contains information describing to Vue what kind of node it should render on the page, including descriptions of any child nodes. We call this node description a &quot;virtual node&quot;, usually abbreviated to <strong>VNode</strong>. &quot;Virtual DOM&quot; is what we call the entire tree of VNodes, built by a tree of Vue components.</p>
<h2 id="createelement-arguments"><code>createElement</code> Arguments</h2>
<p>The next thing you'll have to become familiar with is how to use template features in the <code>createElement</code> function. Here are the arguments that <code>createElement</code> accepts:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// @returns {VNode}</span>
<span class="at">createElement</span>(
  <span class="co">// {String | Object | Function}</span>
  <span class="co">// An HTML tag name, component options, or async</span>
  <span class="co">// function resolving to one of these. Required.</span>
  <span class="st">&#39;div&#39;</span><span class="op">,</span>

  <span class="co">// {Object}</span>
  <span class="co">// A data object corresponding to the attributes</span>
  <span class="co">// you would use in a template. Optional.</span>
  <span class="op">{</span>
    <span class="co">// (see details in the next section below)</span>
  <span class="op">},</span>

  <span class="co">// {String | Array}</span>
  <span class="co">// Children VNodes, built using `createElement()`,</span>
  <span class="co">// or using strings to get &#39;text VNodes&#39;. Optional.</span>
  [
    <span class="st">&#39;Some text comes first.&#39;</span><span class="op">,</span>
    <span class="at">createElement</span>(<span class="st">&#39;h1&#39;</span><span class="op">,</span> <span class="st">&#39;A headline&#39;</span>)<span class="op">,</span>
    <span class="at">createElement</span>(MyComponent<span class="op">,</span> <span class="op">{</span>
      <span class="dt">props</span><span class="op">:</span> <span class="op">{</span>
        <span class="dt">someProp</span><span class="op">:</span> <span class="st">&#39;foobar&#39;</span>
      <span class="op">}</span>
    <span class="op">}</span>)
  ]
)</code></pre></div>
<h3 id="the-data-object-in-depth">The Data Object In-Depth</h3>
<p>One thing to note: similar to how <code>v-bind:class</code> and <code>v-bind:style</code> have special treatment in templates, they have their own top-level fields in VNode data objects. This object also allows you to bind normal HTML attributes as well as DOM properties such as <code>innerHTML</code> (this would replace the <code>v-html</code> directive):</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="op">{</span>
  <span class="co">// Same API as `v-bind:class`, accepting either</span>
  <span class="co">// a string, object, or array of strings and objects.</span>
  <span class="dt">class</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">foo</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
    <span class="dt">bar</span><span class="op">:</span> <span class="kw">false</span>
  <span class="op">},</span>
  <span class="co">// Same API as `v-bind:style`, accepting either</span>
  <span class="co">// a string, object, or array of objects.</span>
  <span class="dt">style</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">color</span><span class="op">:</span> <span class="st">&#39;red&#39;</span><span class="op">,</span>
    <span class="dt">fontSize</span><span class="op">:</span> <span class="st">&#39;14px&#39;</span>
  <span class="op">},</span>
  <span class="co">// Normal HTML attributes</span>
  <span class="dt">attrs</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">id</span><span class="op">:</span> <span class="st">&#39;foo&#39;</span>
  <span class="op">},</span>
  <span class="co">// Component props</span>
  <span class="dt">props</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">myProp</span><span class="op">:</span> <span class="st">&#39;bar&#39;</span>
  <span class="op">},</span>
  <span class="co">// DOM properties</span>
  <span class="dt">domProps</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">innerHTML</span><span class="op">:</span> <span class="st">&#39;baz&#39;</span>
  <span class="op">},</span>
  <span class="co">// Event handlers are nested under `on`, though</span>
  <span class="co">// modifiers such as in `v-on:keyup.enter` are not</span>
  <span class="co">// supported. You&#39;ll have to manually check the</span>
  <span class="co">// keyCode in the handler instead.</span>
  <span class="dt">on</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">click</span><span class="op">:</span> <span class="kw">this</span>.<span class="at">clickHandler</span>
  <span class="op">},</span>
  <span class="co">// For components only. Allows you to listen to</span>
  <span class="co">// native events, rather than events emitted from</span>
  <span class="co">// the component using `vm.$emit`.</span>
  <span class="dt">nativeOn</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">click</span><span class="op">:</span> <span class="kw">this</span>.<span class="at">nativeClickHandler</span>
  <span class="op">},</span>
  <span class="co">// Custom directives. Note that the `binding`&#39;s</span>
  <span class="co">// `oldValue` cannot be set, as Vue keeps track</span>
  <span class="co">// of it for you.</span>
  <span class="dt">directives</span><span class="op">:</span> [
    <span class="op">{</span>
      <span class="dt">name</span><span class="op">:</span> <span class="st">&#39;my-custom-directive&#39;</span><span class="op">,</span>
      <span class="dt">value</span><span class="op">:</span> <span class="st">&#39;2&#39;</span><span class="op">,</span>
      <span class="dt">expression</span><span class="op">:</span> <span class="st">&#39;1 + 1&#39;</span><span class="op">,</span>
      <span class="dt">arg</span><span class="op">:</span> <span class="st">&#39;foo&#39;</span><span class="op">,</span>
      <span class="dt">modifiers</span><span class="op">:</span> <span class="op">{</span>
        <span class="dt">bar</span><span class="op">:</span> <span class="kw">true</span>
      <span class="op">}</span>
    <span class="op">}</span>
  ]<span class="op">,</span>
  <span class="co">// Scoped slots in the form of</span>
  <span class="co">// { name: props =&gt; VNode | Array&lt;VNode&gt; }</span>
  <span class="dt">scopedSlots</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">default</span><span class="op">:</span> props <span class="op">=&gt;</span> <span class="at">createElement</span>(<span class="st">&#39;span&#39;</span><span class="op">,</span> <span class="va">props</span>.<span class="at">text</span>)
  <span class="op">},</span>
  <span class="co">// The name of the slot, if this component is the</span>
  <span class="co">// child of another component</span>
  <span class="dt">slot</span><span class="op">:</span> <span class="st">&#39;name-of-slot&#39;</span><span class="op">,</span>
  <span class="co">// Other special top-level properties</span>
  <span class="dt">key</span><span class="op">:</span> <span class="st">&#39;myKey&#39;</span><span class="op">,</span>
  <span class="dt">ref</span><span class="op">:</span> <span class="st">&#39;myRef&#39;</span><span class="op">,</span>
  <span class="co">// If you are applying the same ref name to multiple</span>
  <span class="co">// elements in the render function. This will make `$refs.myRef` become an</span>
  <span class="co">// array</span>
  <span class="dt">refInFor</span><span class="op">:</span> <span class="kw">true</span>
<span class="op">}</span></code></pre></div>
<h3 id="complete-example">Complete Example</h3>
<p>With this knowledge, we can now finish the component we started:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> getChildrenTextContent <span class="op">=</span> <span class="kw">function</span> (children) <span class="op">{</span>
  <span class="cf">return</span> <span class="va">children</span>.<span class="at">map</span>(<span class="kw">function</span> (node) <span class="op">{</span>
    <span class="cf">return</span> <span class="va">node</span>.<span class="at">children</span>
      <span class="op">?</span> <span class="at">getChildrenTextContent</span>(<span class="va">node</span>.<span class="at">children</span>)
      : <span class="va">node</span>.<span class="at">text</span>
  <span class="op">}</span>).<span class="at">join</span>(<span class="st">&#39;&#39;</span>)
<span class="op">}</span>

<span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;anchored-heading&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">render</span><span class="op">:</span> <span class="kw">function</span> (createElement) <span class="op">{</span>
    <span class="co">// create kebab-case id</span>
    <span class="kw">var</span> headingId <span class="op">=</span> <span class="at">getChildrenTextContent</span>(<span class="kw">this</span>.<span class="va">$slots</span>.<span class="at">default</span>)
      .<span class="at">toLowerCase</span>()
      .<span class="at">replace</span>(<span class="ss">/</span><span class="sc">\W+</span><span class="ss">/g</span><span class="op">,</span> <span class="st">&#39;-&#39;</span>)
      .<span class="at">replace</span>(<span class="ss">/</span><span class="sc">(</span><span class="ss">^-</span><span class="sc">|</span><span class="ss">-$</span><span class="sc">)</span><span class="ss">/g</span><span class="op">,</span> <span class="st">&#39;&#39;</span>)

    <span class="cf">return</span> <span class="at">createElement</span>(
      <span class="st">&#39;h&#39;</span> <span class="op">+</span> <span class="kw">this</span>.<span class="at">level</span><span class="op">,</span>
      [
        <span class="at">createElement</span>(<span class="st">&#39;a&#39;</span><span class="op">,</span> <span class="op">{</span>
          <span class="dt">attrs</span><span class="op">:</span> <span class="op">{</span>
            <span class="dt">name</span><span class="op">:</span> headingId<span class="op">,</span>
            <span class="dt">href</span><span class="op">:</span> <span class="st">&#39;#&#39;</span> <span class="op">+</span> headingId
          <span class="op">}</span>
        <span class="op">},</span> <span class="kw">this</span>.<span class="va">$slots</span>.<span class="at">default</span>)
      ]
    )
  <span class="op">},</span>
  <span class="dt">props</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">level</span><span class="op">:</span> <span class="op">{</span>
      <span class="dt">type</span><span class="op">:</span> Number<span class="op">,</span>
      <span class="dt">required</span><span class="op">:</span> <span class="kw">true</span>
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<h3 id="constraints">Constraints</h3>
<h4 id="vnodes-must-be-unique">VNodes Must Be Unique</h4>
<p>All VNodes in the component tree must be unique. That means the following render function is invalid:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">render<span class="op">:</span> <span class="kw">function</span> (createElement) <span class="op">{</span>
  <span class="kw">var</span> myParagraphVNode <span class="op">=</span> <span class="at">createElement</span>(<span class="st">&#39;p&#39;</span><span class="op">,</span> <span class="st">&#39;hi&#39;</span>)
  <span class="cf">return</span> <span class="at">createElement</span>(<span class="st">&#39;div&#39;</span><span class="op">,</span> [
    <span class="co">// Yikes - duplicate VNodes!</span>
    myParagraphVNode<span class="op">,</span> myParagraphVNode
  ])
<span class="op">}</span></code></pre></div>
<p>If you really want to duplicate the same element/component many times, you can do so with a factory function. For example, the following render function is a perfectly valid way of rendering 20 identical paragraphs:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">render<span class="op">:</span> <span class="kw">function</span> (createElement) <span class="op">{</span>
  <span class="cf">return</span> <span class="at">createElement</span>(<span class="st">&#39;div&#39;</span><span class="op">,</span>
    <span class="va">Array</span>.<span class="at">apply</span>(<span class="kw">null</span><span class="op">,</span> <span class="op">{</span> <span class="dt">length</span><span class="op">:</span> <span class="dv">20</span> <span class="op">}</span>).<span class="at">map</span>(<span class="kw">function</span> () <span class="op">{</span>
      <span class="cf">return</span> <span class="at">createElement</span>(<span class="st">&#39;p&#39;</span><span class="op">,</span> <span class="st">&#39;hi&#39;</span>)
    <span class="op">}</span>)
  )
<span class="op">}</span></code></pre></div>
<h2 id="replacing-template-features-with-plain-javascript">Replacing Template Features with Plain JavaScript</h2>
<h3 id="v-if-and-v-for"><code>v-if</code> and <code>v-for</code></h3>
<p>Wherever something can be easily accomplished in plain JavaScript, Vue render functions do not provide a proprietary alternative. For example, in a template using <code>v-if</code> and <code>v-for</code>:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;ul</span><span class="ot"> v-if=</span><span class="st">&quot;items.length&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;li</span><span class="ot"> v-for=</span><span class="st">&quot;item in items&quot;</span><span class="kw">&gt;</span>{{ item.name }}<span class="kw">&lt;/li&gt;</span>
<span class="kw">&lt;/ul&gt;</span>
<span class="kw">&lt;p</span><span class="ot"> v-else</span><span class="kw">&gt;</span>No items found.<span class="kw">&lt;/p&gt;</span></code></pre></div>
<p>This could be rewritten with JavaScript's <code>if</code>/<code>else</code> and <code>map</code> in a render function:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">props<span class="op">:</span> [<span class="st">&#39;items&#39;</span>]<span class="op">,</span>
render<span class="op">:</span> <span class="kw">function</span> (createElement) <span class="op">{</span>
  <span class="cf">if</span> (<span class="kw">this</span>.<span class="va">items</span>.<span class="at">length</span>) <span class="op">{</span>
    <span class="cf">return</span> <span class="at">createElement</span>(<span class="st">&#39;ul&#39;</span><span class="op">,</span> <span class="kw">this</span>.<span class="va">items</span>.<span class="at">map</span>(<span class="kw">function</span> (item) <span class="op">{</span>
      <span class="cf">return</span> <span class="at">createElement</span>(<span class="st">&#39;li&#39;</span><span class="op">,</span> <span class="va">item</span>.<span class="at">name</span>)
    <span class="op">}</span>))
  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
    <span class="cf">return</span> <span class="at">createElement</span>(<span class="st">&#39;p&#39;</span><span class="op">,</span> <span class="st">&#39;No items found.&#39;</span>)
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<h3 id="v-model"><code>v-model</code></h3>
<p>There is no direct <code>v-model</code> counterpart in render functions - you will have to implement the logic yourself:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">props<span class="op">:</span> [<span class="st">&#39;value&#39;</span>]<span class="op">,</span>
render<span class="op">:</span> <span class="kw">function</span> (createElement) <span class="op">{</span>
  <span class="kw">var</span> self <span class="op">=</span> <span class="kw">this</span>
  <span class="cf">return</span> <span class="at">createElement</span>(<span class="st">&#39;input&#39;</span><span class="op">,</span> <span class="op">{</span>
    <span class="dt">domProps</span><span class="op">:</span> <span class="op">{</span>
      <span class="dt">value</span><span class="op">:</span> <span class="va">self</span>.<span class="at">value</span>
    <span class="op">},</span>
    <span class="dt">on</span><span class="op">:</span> <span class="op">{</span>
      <span class="dt">input</span><span class="op">:</span> <span class="kw">function</span> (event) <span class="op">{</span>
        <span class="va">self</span>.<span class="at">$emit</span>(<span class="st">&#39;input&#39;</span><span class="op">,</span> <span class="va">event</span>.<span class="va">target</span>.<span class="at">value</span>)
      <span class="op">}</span>
    <span class="op">}</span>
  <span class="op">}</span>)
<span class="op">}</span></code></pre></div>
<p>This is the cost of going lower-level, but it also gives you much more control over the interaction details compared to <code>v-model</code>.</p>
<h3 id="event-key-modifiers">Event &amp; Key Modifiers</h3>
<p>For the <code>.passive</code>, <code>.capture</code> and <code>.once</code> event modifiers, Vue offers prefixes that can be used with <code>on</code>:</p>
<table>
<thead>
<tr class="header">
<th>Modifier(s)</th>
<th>Prefix</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>.passive</code></td>
<td><code>&amp;</code></td>
</tr>
<tr class="even">
<td><code>.capture</code></td>
<td><code>!</code></td>
</tr>
<tr class="odd">
<td><code>.once</code></td>
<td><code>~</code></td>
</tr>
<tr class="even">
<td><code>.capture.once</code> or<br><code>.once.capture</code></td>
<td><code>~!</code></td>
</tr>
</tbody>
</table>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">on<span class="op">:</span> <span class="op">{</span>
  <span class="st">&#39;!click&#39;</span><span class="op">:</span> <span class="kw">this</span>.<span class="at">doThisInCapturingMode</span><span class="op">,</span>
  <span class="st">&#39;~keyup&#39;</span><span class="op">:</span> <span class="kw">this</span>.<span class="at">doThisOnce</span><span class="op">,</span>
  <span class="st">&#39;~!mouseover&#39;</span><span class="op">:</span> <span class="kw">this</span>.<span class="at">doThisOnceInCapturingMode</span>
<span class="op">}</span></code></pre></div>
<p>For all other event and key modifiers, no proprietary prefix is necessary, because you can use event methods in the handler:</p>
<table style="width:19%;">
<colgroup>
<col width="9%" />
<col width="9%" />
</colgroup>
<thead>
<tr class="header">
<th>Modifier(s)</th>
<th>Equivalent in Handler</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>.stop</code></td>
<td><code>event.stopPropagation()</code></td>
</tr>
<tr class="even">
<td><code>.prevent</code></td>
<td><code>event.preventDefault()</code></td>
</tr>
<tr class="odd">
<td><code>.self</code></td>
<td><code>if (event.target !== event.currentTarget) return</code></td>
</tr>
<tr class="even">
<td>Keys:<br><code>.enter</code>, <code>.13</code></td>
<td><code>if (event.keyCode !== 13) return</code> (change <code>13</code> to <a href="http://keycode.info/">another key code</a> for other key modifiers)</td>
</tr>
<tr class="odd">
<td>Modifiers Keys:<br><code>.ctrl</code>, <code>.alt</code>, <code>.shift</code>, <code>.meta</code></td>
<td><code>if (!event.ctrlKey) return</code> (change <code>ctrlKey</code> to <code>altKey</code>, <code>shiftKey</code>, or <code>metaKey</code>, respectively)</td>
</tr>
</tbody>
</table>
<p>Here's an example with all of these modifiers used together:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">on<span class="op">:</span> <span class="op">{</span>
  <span class="dt">keyup</span><span class="op">:</span> <span class="kw">function</span> (event) <span class="op">{</span>
    <span class="co">// Abort if the element emitting the event is not</span>
    <span class="co">// the element the event is bound to</span>
    <span class="cf">if</span> (<span class="va">event</span>.<span class="at">target</span> <span class="op">!==</span> <span class="va">event</span>.<span class="at">currentTarget</span>) <span class="cf">return</span>
    <span class="co">// Abort if the key that went up is not the enter</span>
    <span class="co">// key (13) and the shift key was not held down</span>
    <span class="co">// at the same time</span>
    <span class="cf">if</span> (<span class="op">!</span><span class="va">event</span>.<span class="at">shiftKey</span> <span class="op">||</span> <span class="va">event</span>.<span class="at">keyCode</span> <span class="op">!==</span> <span class="dv">13</span>) <span class="cf">return</span>
    <span class="co">// Stop event propagation</span>
    <span class="va">event</span>.<span class="at">stopPropagation</span>()
    <span class="co">// Prevent the default keyup handler for this element</span>
    <span class="va">event</span>.<span class="at">preventDefault</span>()
    <span class="co">// ...</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<h3 id="slots-1">Slots</h3>
<p>You can access static slot contents as Arrays of VNodes from <a href="../api/#vm-slots"><code>this.$slots</code></a>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">render<span class="op">:</span> <span class="kw">function</span> (createElement) <span class="op">{</span>
  <span class="co">// `&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;`</span>
  <span class="cf">return</span> <span class="at">createElement</span>(<span class="st">&#39;div&#39;</span><span class="op">,</span> <span class="kw">this</span>.<span class="va">$slots</span>.<span class="at">default</span>)
<span class="op">}</span></code></pre></div>
<p>And access scoped slots as functions that return VNodes from <a href="../api/#vm-scopedSlots"><code>this.$scopedSlots</code></a>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">props<span class="op">:</span> [<span class="st">&#39;message&#39;</span>]<span class="op">,</span>
render<span class="op">:</span> <span class="kw">function</span> (createElement) <span class="op">{</span>
  <span class="co">// `&lt;div&gt;&lt;slot :text=&quot;message&quot;&gt;&lt;/slot&gt;&lt;/div&gt;`</span>
  <span class="cf">return</span> <span class="at">createElement</span>(<span class="st">&#39;div&#39;</span><span class="op">,</span> [
    <span class="kw">this</span>.<span class="va">$scopedSlots</span>.<span class="at">default</span>(<span class="op">{</span>
      <span class="dt">text</span><span class="op">:</span> <span class="kw">this</span>.<span class="at">message</span>
    <span class="op">}</span>)
  ])
<span class="op">}</span></code></pre></div>
<p>To pass scoped slots to a child component using render functions, use the <code>scopedSlots</code> field in VNode data:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">render<span class="op">:</span> <span class="kw">function</span> (createElement) <span class="op">{</span>
  <span class="co">// `&lt;div&gt;&lt;child v-slot=&quot;props&quot;&gt;&lt;span&gt;{{ props.text }}&lt;/span&gt;&lt;/child&gt;&lt;/div&gt;`</span>
  <span class="cf">return</span> <span class="at">createElement</span>(<span class="st">&#39;div&#39;</span><span class="op">,</span> [
    <span class="at">createElement</span>(<span class="st">&#39;child&#39;</span><span class="op">,</span> <span class="op">{</span>
      <span class="co">// pass `scopedSlots` in the data object</span>
      <span class="co">// in the form of { name: props =&gt; VNode | Array&lt;VNode&gt; }</span>
      <span class="dt">scopedSlots</span><span class="op">:</span> <span class="op">{</span>
        <span class="dt">default</span><span class="op">:</span> <span class="kw">function</span> (props) <span class="op">{</span>
          <span class="cf">return</span> <span class="at">createElement</span>(<span class="st">&#39;span&#39;</span><span class="op">,</span> <span class="va">props</span>.<span class="at">text</span>)
        <span class="op">}</span>
      <span class="op">}</span>
    <span class="op">}</span>)
  ])
<span class="op">}</span></code></pre></div>
<h2 id="jsx">JSX</h2>
<p>If you're writing a lot of <code>render</code> functions, it might feel painful to write something like this:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="at">createElement</span>(
  <span class="st">&#39;anchored-heading&#39;</span><span class="op">,</span> <span class="op">{</span>
    <span class="dt">props</span><span class="op">:</span> <span class="op">{</span>
      <span class="dt">level</span><span class="op">:</span> <span class="dv">1</span>
    <span class="op">}</span>
  <span class="op">},</span> [
    <span class="at">createElement</span>(<span class="st">&#39;span&#39;</span><span class="op">,</span> <span class="st">&#39;Hello&#39;</span>)<span class="op">,</span>
    <span class="st">&#39; world!&#39;</span>
  ]
)</code></pre></div>
<p>Especially when the template version is so simple in comparison:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;anchored-heading</span><span class="ot"> :level=</span><span class="st">&quot;1&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;span&gt;</span>Hello<span class="kw">&lt;/span&gt;</span> world!
<span class="kw">&lt;/anchored-heading&gt;</span></code></pre></div>
<p>That's why there's a <a href="https://github.com/vuejs/jsx">Babel plugin</a> to use JSX with Vue, getting us back to a syntax that's closer to templates:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="im">import</span> AnchoredHeading <span class="im">from</span> <span class="st">&#39;./AnchoredHeading.vue&#39;</span>

<span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#demo&#39;</span><span class="op">,</span>
  <span class="dt">render</span><span class="op">:</span> <span class="kw">function</span> (h) <span class="op">{</span>
    <span class="cf">return</span> (
      <span class="op">&lt;</span>AnchoredHeading level<span class="op">={</span><span class="dv">1</span><span class="op">}&gt;</span>
        <span class="op">&lt;</span>span<span class="op">&gt;</span>Hello<span class="op">&lt;</span><span class="ss">/span&gt; world!</span>
<span class="ss">      &lt;/AnchoredHeading</span><span class="op">&gt;</span>
    )
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p class="tip">
Aliasing <code>createElement</code> to <code>h</code> is a common convention you'll see in the Vue ecosystem and is actually required for JSX. Starting with <a href="https://github.com/vuejs/babel-plugin-transform-vue-jsx#h-auto-injection">version 3.4.0</a> of the Babel plugin for Vue, we automatically inject <code>const h = this.$createElement</code> in any method and getter (not functions or arrow functions), declared in ES2015 syntax that has JSX, so you can drop the <code>(h)</code> parameter. With prior versions of the plugin, your app would throw an error if <code>h</code> was not available in the scope.
</p>
<p>For more on how JSX maps to JavaScript, see the <a href="https://github.com/vuejs/jsx#installation">usage docs</a>.</p>
<h2 id="functional-components">Functional Components</h2>
<p>The anchored heading component we created earlier is relatively simple. It doesn't manage any state, watch any state passed to it, and it has no lifecycle methods. Really, it's only a function with some props.</p>
<p>In cases like this, we can mark components as <code>functional</code>, which means that they're stateless (no <a href="../api/#Options-Data">reactive data</a>) and instanceless (no <code>this</code> context). A <strong>functional component</strong> looks like this:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;my-component&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">functional</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
  <span class="co">// Props are optional</span>
  <span class="dt">props</span><span class="op">:</span> <span class="op">{</span>
    <span class="co">// ...</span>
  <span class="op">},</span>
  <span class="co">// To compensate for the lack of an instance,</span>
  <span class="co">// we are now provided a 2nd context argument.</span>
  <span class="dt">render</span><span class="op">:</span> <span class="kw">function</span> (createElement<span class="op">,</span> context) <span class="op">{</span>
    <span class="co">// ...</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<blockquote>
<p>Note: in versions before 2.3.0, the <code>props</code> option is required if you wish to accept props in a functional component. In 2.3.0+ you can omit the <code>props</code> option and all attributes found on the component node will be implicitly extracted as props.</p>
<p>The reference will be HTMLElement when used with functional components because they’re stateless and instanceless.</p>
</blockquote>
<p>In 2.5.0+, if you are using <a href="single-file-components.html">single-file components</a>, template-based functional components can be declared with:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;template</span><span class="ot"> functional</span><span class="kw">&gt;</span>
<span class="kw">&lt;/template&gt;</span></code></pre></div>
<p>Everything the component needs is passed through <code>context</code>, which is an object containing:</p>
<ul>
<li><code>props</code>: An object of the provided props</li>
<li><code>children</code>: An array of the VNode children</li>
<li><code>slots</code>: A function returning a slots object</li>
<li><code>scopedSlots</code>: (2.6.0+) An object that exposes passed-in scoped slots. Also exposes normal slots as functions.</li>
<li><code>data</code>: The entire <a href="#The-Data-Object-In-Depth">data object</a>, passed to the component as the 2nd argument of <code>createElement</code></li>
<li><code>parent</code>: A reference to the parent component</li>
<li><code>listeners</code>: (2.3.0+) An object containing parent-registered event listeners. This is an alias to <code>data.on</code></li>
<li><code>injections</code>: (2.3.0+) if using the <a href="../api/#provide-inject"><code>inject</code></a> option, this will contain resolved injections.</li>
</ul>
<p>After adding <code>functional: true</code>, updating the render function of our anchored heading component would require adding the <code>context</code> argument, updating <code>this.$slots.default</code> to <code>context.children</code>, then updating <code>this.level</code> to <code>context.props.level</code>.</p>
<p>Since functional components are just functions, they're much cheaper to render.</p>
<p>They're also very useful as wrapper components. For example, when you need to:</p>
<ul>
<li>Programmatically choose one of several other components to delegate to</li>
<li>Manipulate children, props, or data before passing them on to a child component</li>
</ul>
<p>Here's an example of a <code>smart-list</code> component that delegates to more specific components, depending on the props passed to it:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> EmptyList <span class="op">=</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span>
<span class="kw">var</span> TableList <span class="op">=</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span>
<span class="kw">var</span> OrderedList <span class="op">=</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span>
<span class="kw">var</span> UnorderedList <span class="op">=</span> <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span>

<span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;smart-list&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">functional</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
  <span class="dt">props</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">items</span><span class="op">:</span> <span class="op">{</span>
      <span class="dt">type</span><span class="op">:</span> Array<span class="op">,</span>
      <span class="dt">required</span><span class="op">:</span> <span class="kw">true</span>
    <span class="op">},</span>
    <span class="dt">isOrdered</span><span class="op">:</span> Boolean
  <span class="op">},</span>
  <span class="dt">render</span><span class="op">:</span> <span class="kw">function</span> (createElement<span class="op">,</span> context) <span class="op">{</span>
    <span class="kw">function</span> <span class="at">appropriateListComponent</span> () <span class="op">{</span>
      <span class="kw">var</span> items <span class="op">=</span> <span class="va">context</span>.<span class="va">props</span>.<span class="at">items</span>

      <span class="cf">if</span> (<span class="va">items</span>.<span class="at">length</span> <span class="op">===</span> <span class="dv">0</span>)           <span class="cf">return</span> EmptyList
      <span class="cf">if</span> (<span class="kw">typeof</span> items[<span class="dv">0</span>] <span class="op">===</span> <span class="st">&#39;object&#39;</span>) <span class="cf">return</span> TableList
      <span class="cf">if</span> (<span class="va">context</span>.<span class="va">props</span>.<span class="at">isOrdered</span>)      <span class="cf">return</span> OrderedList

      <span class="cf">return</span> UnorderedList
    <span class="op">}</span>

    <span class="cf">return</span> <span class="at">createElement</span>(
      <span class="at">appropriateListComponent</span>()<span class="op">,</span>
      <span class="va">context</span>.<span class="at">data</span><span class="op">,</span>
      <span class="va">context</span>.<span class="at">children</span>
    )
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<h3 id="passing-attributes-and-events-to-child-elementscomponents">Passing Attributes and Events to Child Elements/Components</h3>
<p>On normal components, attributes not defined as props are automatically added to the root element of the component, replacing or <a href="class-and-style.html">intelligently merging with</a> any existing attributes of the same name.</p>
<p>Functional components, however, require you to explicitly define this behavior:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;my-functional-button&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">functional</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
  <span class="dt">render</span><span class="op">:</span> <span class="kw">function</span> (createElement<span class="op">,</span> context) <span class="op">{</span>
    <span class="co">// Transparently pass any attributes, event listeners, children, etc.</span>
    <span class="cf">return</span> <span class="at">createElement</span>(<span class="st">&#39;button&#39;</span><span class="op">,</span> <span class="va">context</span>.<span class="at">data</span><span class="op">,</span> <span class="va">context</span>.<span class="at">children</span>)
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>By passing <code>context.data</code> as the second argument to <code>createElement</code>, we are passing down any attributes or event listeners used on <code>my-functional-button</code>. It's so transparent, in fact, that events don't even require the <code>.native</code> modifier.</p>
<p>If you are using template-based functional components, you will also have to manually add attributes and listeners. Since we have access to the individual context contents, we can use <code>data.attrs</code> to pass along any HTML attributes and <code>listeners</code> <em>(the alias for <code>data.on</code>)</em> to pass along any event listeners.</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;template</span><span class="ot"> functional</span><span class="kw">&gt;</span>
  <span class="kw">&lt;button</span>
<span class="ot">    class=</span><span class="st">&quot;btn btn-primary&quot;</span>
<span class="ot">    v-bind=</span><span class="st">&quot;data.attrs&quot;</span>
<span class="ot">    v-on=</span><span class="st">&quot;listeners&quot;</span>
  <span class="kw">&gt;</span>
    <span class="kw">&lt;slot/&gt;</span>
  <span class="kw">&lt;/button&gt;</span>
<span class="kw">&lt;/template&gt;</span></code></pre></div>
<h3 id="slots-vs-children"><code>slots()</code> vs <code>children</code></h3>
<p>You may wonder why we need both <code>slots()</code> and <code>children</code>. Wouldn't <code>slots().default</code> be the same as <code>children</code>? In some cases, yes - but what if you have a functional component with the following children?</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;my-functional-component&gt;</span>
  <span class="kw">&lt;p</span><span class="ot"> v-slot:foo</span><span class="kw">&gt;</span>
    first
  <span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;p&gt;</span>second<span class="kw">&lt;/p&gt;</span>
<span class="kw">&lt;/my-functional-component&gt;</span></code></pre></div>
<p>For this component, <code>children</code> will give you both paragraphs, <code>slots().default</code> will give you only the second, and <code>slots().foo</code> will give you only the first. Having both <code>children</code> and <code>slots()</code> therefore allows you to choose whether this component knows about a slot system or perhaps delegates that responsibility to another component by passing along <code>children</code>.</p>
<h2 id="template-compilation">Template Compilation</h2>
<p>You may be interested to know that Vue's templates actually compile to render functions. This is an implementation detail you usually don't need to know about, but if you'd like to see how specific template features are compiled, you may find it interesting. Below is a little demo using <code>Vue.compile</code> to live-compile a template string:</p>
<iframe src="https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-template-compilation?codemirror=1&amp;hidedevtools=1&amp;hidenavigation=1&amp;theme=light&amp;view=preview" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" title="vue-20-template-compilation" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<h1 id="plugins"><a name=#guide/plugins.md></a>Plugins</h1>
<p>Plugins usually add global-level functionality to Vue. There is no strictly defined scope for a plugin - there are typically several types of plugins:</p>
<ol style="list-style-type: decimal">
<li><p>Add some global methods or properties. e.g. <a href="https://github.com/karol-f/vue-custom-element">vue-custom-element</a></p></li>
<li><p>Add one or more global assets: directives/filters/transitions etc. e.g. <a href="https://github.com/vuejs/vue-touch">vue-touch</a></p></li>
<li><p>Add some component options by global mixin. e.g. <a href="https://github.com/vuejs/vue-router">vue-router</a></p></li>
<li><p>Add some Vue instance methods by attaching them to Vue.prototype.</p></li>
<li><p>A library that provides an API of its own, while at the same time injecting some combination of the above. e.g. <a href="https://github.com/vuejs/vue-router">vue-router</a></p></li>
</ol>
<h2 id="using-a-plugin">Using a Plugin</h2>
<p>Use plugins by calling the <code>Vue.use()</code> global method. This has to be done before you start your app by calling <code>new Vue()</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// calls `MyPlugin.install(Vue)`</span>
<span class="va">Vue</span>.<span class="at">use</span>(MyPlugin)

<span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="co">//... options</span>
<span class="op">}</span>)</code></pre></div>
<p>You can optionally pass in some options:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">use</span>(MyPlugin<span class="op">,</span> <span class="op">{</span> <span class="dt">someOption</span><span class="op">:</span> <span class="kw">true</span> <span class="op">}</span>)</code></pre></div>
<p><code>Vue.use</code> automatically prevents you from using the same plugin more than once, so calling it multiple times on the same plugin will install the plugin only once.</p>
<p>Some plugins provided by Vue.js official plugins such as <code>vue-router</code> automatically calls <code>Vue.use()</code> if <code>Vue</code> is available as a global variable. However in a module environment such as CommonJS, you always need to call <code>Vue.use()</code> explicitly:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// When using CommonJS via Browserify or Webpack</span>
<span class="kw">var</span> Vue <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;vue&#39;</span>)
<span class="kw">var</span> VueRouter <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;vue-router&#39;</span>)

<span class="co">// Don&#39;t forget to call this</span>
<span class="va">Vue</span>.<span class="at">use</span>(VueRouter)</code></pre></div>
<p>Checkout <a href="https://github.com/vuejs/awesome-vue#components--libraries">awesome-vue</a> for a huge collection of community-contributed plugins and libraries.</p>
<h2 id="writing-a-plugin">Writing a Plugin</h2>
<p>A Vue.js plugin should expose an <code>install</code> method. The method will be called with the <code>Vue</code> constructor as the first argument, along with possible options:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">MyPlugin</span>.<span class="at">install</span> <span class="op">=</span> <span class="kw">function</span> (Vue<span class="op">,</span> options) <span class="op">{</span>
  <span class="co">// 1. add global method or property</span>
  <span class="va">Vue</span>.<span class="at">myGlobalMethod</span> <span class="op">=</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="co">// some logic ...</span>
  <span class="op">}</span>

  <span class="co">// 2. add a global asset</span>
  <span class="va">Vue</span>.<span class="at">directive</span>(<span class="st">&#39;my-directive&#39;</span><span class="op">,</span> <span class="op">{</span>
    <span class="at">bind</span> (el<span class="op">,</span> binding<span class="op">,</span> vnode<span class="op">,</span> oldVnode) <span class="op">{</span>
      <span class="co">// some logic ...</span>
    <span class="op">}</span>
    ...
  <span class="op">}</span>)

  <span class="co">// 3. inject some component options</span>
  <span class="va">Vue</span>.<span class="at">mixin</span>(<span class="op">{</span>
    <span class="dt">created</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="co">// some logic ...</span>
    <span class="op">}</span>
    ...
  <span class="op">}</span>)

  <span class="co">// 4. add an instance method</span>
  <span class="va">Vue</span>.<span class="va">prototype</span>.<span class="at">$myMethod</span> <span class="op">=</span> <span class="kw">function</span> (methodOptions) <span class="op">{</span>
    <span class="co">// some logic ...</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<h1 id="filters"><a name=#guide/filters.md></a>Filters</h1>
<p>Vue.js allows you to define filters that can be used to apply common text formatting. Filters are usable in two places: <strong>mustache interpolations and <code>v-bind</code> expressions</strong> (the latter supported in 2.1.0+). Filters should be appended to the end of the JavaScript expression, denoted by the &quot;pipe&quot; symbol:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- in mustaches --&gt;</span>
{{ message | capitalize }}

<span class="co">&lt;!-- in v-bind --&gt;</span>
<span class="kw">&lt;div</span><span class="ot"> v-bind:id=</span><span class="st">&quot;rawId | formatId&quot;</span><span class="kw">&gt;&lt;/div&gt;</span></code></pre></div>
<p>You can define local filters in a component's options:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">filters<span class="op">:</span> <span class="op">{</span>
  <span class="dt">capitalize</span><span class="op">:</span> <span class="kw">function</span> (value) <span class="op">{</span>
    <span class="cf">if</span> (<span class="op">!</span>value) <span class="cf">return</span> <span class="st">&#39;&#39;</span>
    value <span class="op">=</span> <span class="va">value</span>.<span class="at">toString</span>()
    <span class="cf">return</span> <span class="va">value</span>.<span class="at">charAt</span>(<span class="dv">0</span>).<span class="at">toUpperCase</span>() <span class="op">+</span> <span class="va">value</span>.<span class="at">slice</span>(<span class="dv">1</span>)
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>or define a filter globally before creating the Vue instance:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">filter</span>(<span class="st">&#39;capitalize&#39;</span><span class="op">,</span> <span class="kw">function</span> (value) <span class="op">{</span>
  <span class="cf">if</span> (<span class="op">!</span>value) <span class="cf">return</span> <span class="st">&#39;&#39;</span>
  value <span class="op">=</span> <span class="va">value</span>.<span class="at">toString</span>()
  <span class="cf">return</span> <span class="va">value</span>.<span class="at">charAt</span>(<span class="dv">0</span>).<span class="at">toUpperCase</span>() <span class="op">+</span> <span class="va">value</span>.<span class="at">slice</span>(<span class="dv">1</span>)
<span class="op">}</span>)

<span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="co">// ...</span>
<span class="op">}</span>)</code></pre></div>
<p>When the global filter has the same name as the local filter, the local filter will be preferred.</p>
<p>Below is an example of our <code>capitalize</code> filter being used:</p>
<p>The filter's function always receives the expression's value (the result of the former chain) as its first argument. In the above example, the <code>capitalize</code> filter function will receive the value of <code>message</code> as its argument.</p>
<p>Filters can be chained:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">{{ message | filterA | filterB }}</code></pre></div>
<p>In this case, <code>filterA</code>, defined with a single argument, will receive the value of <code>message</code>, and then the <code>filterB</code> function will be called with the result of <code>filterA</code> passed into <code>filterB</code>'s single argument.</p>
<p>Filters are JavaScript functions, therefore they can take arguments:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">{{ message | filterA(&#39;arg1&#39;, arg2) }}</code></pre></div>
<p>Here <code>filterA</code> is defined as a function taking three arguments. The value of <code>message</code> will be passed into the first argument. The plain string <code>'arg1'</code> will be passed into the <code>filterA</code> as its second argument, and the value of expression <code>arg2</code> will be evaluated and passed in as the third argument.</p>
<h1 id="single-file-components"><a name=#guide/single-file-components.md></a>Single File Components</h1>
<h2 id="introduction-1">Introduction</h2>
<div class="vueschool">
<a href="https://vueschool.io/lessons/introduction-to-single-file-components?friend=vuejs" target="_blank" rel="sponsored noopener" title="Free Vue.js Single File Components lesson">Watch a free video lesson on Vue School</a>
</div>
<p>In many Vue projects, global components will be defined using <code>Vue.component</code>, followed by <code>new Vue({ el: '#container' })</code> to target a container element in the body of every page.</p>
<p>This can work very well for small to medium-sized projects, where JavaScript is only used to enhance certain views. In more complex projects however, or when your frontend is entirely driven by JavaScript, these disadvantages become apparent:</p>
<ul>
<li><strong>Global definitions</strong> force unique names for every component</li>
<li><strong>String templates</strong> lack syntax highlighting and require ugly slashes for multiline HTML</li>
<li><strong>No CSS support</strong> means that while HTML and JavaScript are modularized into components, CSS is conspicuously left out</li>
<li><strong>No build step</strong> restricts us to HTML and ES5 JavaScript, rather than preprocessors like Pug (formerly Jade) and Babel</li>
</ul>
<p>All of these are solved by <strong>single-file components</strong> with a <code>.vue</code> extension, made possible with build tools such as Webpack or Browserify.</p>
<p>Here's an example of a file we'll call <code>Hello.vue</code>:</p>
<p><a href="https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-single-file-components" target="_blank" rel="noopener noreferrer"><img src="../images/vue-component.png" alt="Single-file component example (click for code as text)" style="display: block; margin: 30px auto;"></a></p>
<p>Now we get:</p>
<ul>
<li><a href="https://github.com/vuejs/awesome-vue#source-code-editing">Complete syntax highlighting</a></li>
<li><a href="https://webpack.js.org/concepts/modules/#what-is-a-webpack-module">CommonJS modules</a></li>
<li><a href="https://vue-loader.vuejs.org/en/features/scoped-css.html">Component-scoped CSS</a></li>
</ul>
<p>As promised, we can also use preprocessors such as Pug, Babel (with ES2015 modules), and Stylus for cleaner and more feature-rich components.</p>
<p><a href="https://gist.github.com/chrisvfritz/1c9f2daea9bc078dcb47e9a82e5f7587" target="_blank" rel="noopener noreferrer"><img src="../images/vue-component-with-preprocessors.png" alt="Single-file component example with preprocessors (click for code as text)" style="display: block; margin: 30px auto;"></a></p>
<p>These specific languages are only examples. You could as easily use Bublé, TypeScript, SCSS, PostCSS - or whatever other preprocessors that help you be productive. If using Webpack with <code>vue-loader</code>, it also has first-class support for CSS Modules.</p>
<h3 id="what-about-separation-of-concerns">What About Separation of Concerns?</h3>
<p>One important thing to note is that <strong>separation of concerns is not equal to separation of file types.</strong> In modern UI development, we have found that instead of dividing the codebase into three huge layers that interweave with one another, it makes much more sense to divide them into loosely-coupled components and compose them. Inside a component, its template, logic and styles are inherently coupled, and collocating them actually makes the component more cohesive and maintainable.</p>
<p>Even if you don't like the idea of Single-File Components, you can still leverage its hot-reloading and pre-compilation features by separating your JavaScript and CSS into separate files:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!-- my-component.vue --&gt;</span>
<span class="kw">&lt;template&gt;</span>
  <span class="kw">&lt;div&gt;</span>This will be pre-compiled<span class="kw">&lt;/div&gt;</span>
<span class="kw">&lt;/template&gt;</span>
<span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;./my-component.js&quot;</span><span class="kw">&gt;&lt;/script&gt;</span>
<span class="kw">&lt;style</span><span class="ot"> src=</span><span class="st">&quot;./my-component.css&quot;</span><span class="kw">&gt;&lt;/style&gt;</span></code></pre></div>
<h2 id="getting-started-1">Getting Started</h2>
<h3 id="example-sandbox">Example Sandbox</h3>
<p>If you want to dive right in and start playing with single-file components, check out <a href="https://codesandbox.io/s/o29j95wx9">this simple todo app</a> on CodeSandbox.</p>
<h3 id="for-users-new-to-module-build-systems-in-javascript">For Users New to Module Build Systems in JavaScript</h3>
<p>With <code>.vue</code> components, we're entering the realm of advanced JavaScript applications. That means learning to use a few additional tools if you haven't already:</p>
<ul>
<li><p><strong>Node Package Manager (NPM)</strong>: Read the <a href="https://docs.npmjs.com/packages-and-modules/getting-packages-from-the-registry">Getting Started guide</a> section about how to get packages from the registry.</p></li>
<li><p><strong>Modern JavaScript with ES2015/16</strong>: Read through Babel's <a href="https://babeljs.io/docs/learn-es2015/">Learn ES2015 guide</a>. You don't have to memorize every feature right now, but keep this page as a reference you can come back to.</p></li>
</ul>
<p>After you've taken a day to dive into these resources, we recommend checking out <a href="https://cli.vuejs.org/">Vue CLI 3</a>. Follow the instructions and you should have a Vue project with <code>.vue</code> components, ES2015, Webpack and hot-reloading in no time!</p>
<h3 id="for-advanced-users">For Advanced Users</h3>
<p>The CLI takes care of most of the tooling configurations for you, but also allows fine-grained customization through its own <a href="https://cli.vuejs.org/config/">config options</a>.</p>
<p>In case you prefer setting up your own build setup from scratch, you will need to manually configure webpack with <a href="https://vue-loader.vuejs.org">vue-loader</a>. To learn more about webpack itself, check out <a href="https://webpack.js.org/configuration/">their official docs</a> and <a href="https://webpack.academy/p/the-core-concepts">Webpack Academy</a>.</p>
<h1 id="unit-testing"><a name=#guide/unit-testing.md></a>Unit Testing</h1>
<blockquote>
<p><a href="https://cli.vuejs.org/">Vue CLI</a> has built-in options for unit testing with <a href="https://github.com/facebook/jest">Jest</a> or <a href="https://mochajs.org/">Mocha</a> that works out of the box. We also have the official <a href="https://vue-test-utils.vuejs.org/">Vue Test Utils</a> which provides more detailed guidance for custom setups.</p>
</blockquote>
<h2 id="simple-assertions">Simple Assertions</h2>
<p>You don't have to do anything special in your components to make them testable. Export the raw options:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;template&gt;</span>
  <span class="kw">&lt;span&gt;</span>{{ message }}<span class="kw">&lt;/span&gt;</span>
<span class="kw">&lt;/template&gt;</span>

<span class="kw">&lt;script&gt;</span>
  <span class="im">export</span> <span class="im">default</span> <span class="op">{</span>
    <span class="at">data</span> () <span class="op">{</span>
      <span class="cf">return</span> <span class="op">{</span>
        <span class="dt">message</span><span class="op">:</span> <span class="st">&#39;hello!&#39;</span>
      <span class="op">}</span>
    <span class="op">},</span>
    <span class="at">created</span> () <span class="op">{</span>
      <span class="kw">this</span>.<span class="at">message</span> <span class="op">=</span> <span class="st">&#39;bye!&#39;</span>
    <span class="op">}</span>
  <span class="op">}</span>
<span class="kw">&lt;/script&gt;</span></code></pre></div>
<p>Then import the component along with <a href="https://vue-test-utils.vuejs.org/">Vue Test Utils</a>, and you can make many common assertions (here we are using Jest-style <code>expect</code> assertions just as an example):</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// Import `shallowMount` from Vue Test Utils and the component being tested</span>
<span class="im">import</span> <span class="op">{</span> shallowMount <span class="op">}</span> <span class="im">from</span> <span class="st">&#39;@vue/test-utils&#39;</span>
<span class="im">import</span> MyComponent <span class="im">from</span> <span class="st">&#39;./MyComponent.vue&#39;</span>

<span class="co">// Mount the component</span>
<span class="kw">const</span> wrapper <span class="op">=</span> <span class="at">shallowMount</span>(MyComponent)

<span class="co">// Here are some Jest tests, though you can</span>
<span class="co">// use any test runner/assertion library combo you prefer</span>
<span class="at">describe</span>(<span class="st">&#39;MyComponent&#39;</span><span class="op">,</span> () <span class="op">=&gt;</span> <span class="op">{</span>
  <span class="co">// Inspect the raw component options</span>
  <span class="at">it</span>(<span class="st">&#39;has a created hook&#39;</span><span class="op">,</span> () <span class="op">=&gt;</span> <span class="op">{</span>
    <span class="at">expect</span>(<span class="kw">typeof</span> <span class="va">MyComponent</span>.<span class="at">created</span>).<span class="at">toBe</span>(<span class="st">&#39;function&#39;</span>)
  <span class="op">}</span>)

  <span class="co">// Evaluate the results of functions in</span>
  <span class="co">// the raw component options</span>
  <span class="at">it</span>(<span class="st">&#39;sets the correct default data&#39;</span><span class="op">,</span> () <span class="op">=&gt;</span> <span class="op">{</span>
    <span class="at">expect</span>(<span class="kw">typeof</span> <span class="va">MyComponent</span>.<span class="at">data</span>).<span class="at">toBe</span>(<span class="st">&#39;function&#39;</span>)
    <span class="kw">const</span> defaultData <span class="op">=</span> <span class="va">MyComponent</span>.<span class="at">data</span>()
    <span class="at">expect</span>(<span class="va">defaultData</span>.<span class="at">message</span>).<span class="at">toBe</span>(<span class="st">&#39;hello!&#39;</span>)
  <span class="op">}</span>)

  <span class="co">// Inspect the component instance on mount</span>
  <span class="at">it</span>(<span class="st">&#39;correctly sets the message when created&#39;</span><span class="op">,</span> () <span class="op">=&gt;</span> <span class="op">{</span>
    <span class="at">expect</span>(<span class="va">wrapper</span>.<span class="va">vm</span>.<span class="va">$data</span>.<span class="at">message</span>).<span class="at">toBe</span>(<span class="st">&#39;bye!&#39;</span>)
  <span class="op">}</span>)

  <span class="co">// Mount an instance and inspect the render output</span>
  <span class="at">it</span>(<span class="st">&#39;renders the correct message&#39;</span><span class="op">,</span> () <span class="op">=&gt;</span> <span class="op">{</span>
    <span class="at">expect</span>(<span class="va">wrapper</span>.<span class="at">text</span>()).<span class="at">toBe</span>(<span class="st">&#39;bye!&#39;</span>)
  <span class="op">}</span>)
<span class="op">}</span>)</code></pre></div>
<h2 id="writing-testable-components">Writing Testable Components</h2>
<p>A component's render output is primarily determined by the props it receives. If a component's render output solely depends on its props it becomes straightforward to test, similar to asserting the return value of a pure function with different arguments. Take a simplified example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;template&gt;</span>
  <span class="kw">&lt;p&gt;</span>{{ msg }}<span class="kw">&lt;/p&gt;</span>
<span class="kw">&lt;/template&gt;</span>

<span class="kw">&lt;script&gt;</span>
  <span class="im">export</span> <span class="im">default</span> <span class="op">{</span>
    <span class="dt">props</span><span class="op">:</span> [<span class="st">&#39;msg&#39;</span>]
  <span class="op">}</span>
<span class="kw">&lt;/script&gt;</span></code></pre></div>
<p>You can assert its render output with different props using <a href="https://vue-test-utils.vuejs.org/">Vue Test Utils</a>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="im">import</span> <span class="op">{</span> shallowMount <span class="op">}</span> <span class="im">from</span> <span class="st">&#39;@vue/test-utils&#39;</span>
<span class="im">import</span> MyComponent <span class="im">from</span> <span class="st">&#39;./MyComponent.vue&#39;</span>

<span class="co">// helper function that mounts and returns the rendered component</span>
<span class="kw">function</span> <span class="at">getMountedComponent</span>(Component<span class="op">,</span> propsData) <span class="op">{</span>
  <span class="cf">return</span> <span class="at">shallowMount</span>(Component<span class="op">,</span> <span class="op">{</span>
    propsData
  <span class="op">}</span>)
<span class="op">}</span>

<span class="at">describe</span>(<span class="st">&#39;MyComponent&#39;</span><span class="op">,</span> () <span class="op">=&gt;</span> <span class="op">{</span>
  <span class="at">it</span>(<span class="st">&#39;renders correctly with different props&#39;</span><span class="op">,</span> () <span class="op">=&gt;</span> <span class="op">{</span>
    <span class="at">expect</span>(
      <span class="at">getMountedComponent</span>(MyComponent<span class="op">,</span> <span class="op">{</span>
        <span class="dt">msg</span><span class="op">:</span> <span class="st">&#39;Hello&#39;</span>
      <span class="op">}</span>).<span class="at">text</span>()
    ).<span class="at">toBe</span>(<span class="st">&#39;Hello&#39;</span>)

    <span class="at">expect</span>(
      <span class="at">getMountedComponent</span>(MyComponent<span class="op">,</span> <span class="op">{</span>
        <span class="dt">msg</span><span class="op">:</span> <span class="st">&#39;Bye&#39;</span>
      <span class="op">}</span>).<span class="at">text</span>()
    ).<span class="at">toBe</span>(<span class="st">&#39;Bye&#39;</span>)
  <span class="op">}</span>)
<span class="op">}</span>)</code></pre></div>
<h2 id="asserting-asynchronous-updates">Asserting Asynchronous Updates</h2>
<p>Since Vue <a href="reactivity.html#Async-Update-Queue">performs DOM updates asynchronously</a>, assertions on DOM updates resulting from state change will have to be made after <code>vm.$nextTick()</code> has resolved:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// Inspect the generated HTML after a state update</span>
<span class="at">it</span>(<span class="st">&#39;updates the rendered message when wrapper.message updates&#39;</span><span class="op">,</span> <span class="at">async</span> () <span class="op">=&gt;</span> <span class="op">{</span>
  <span class="kw">const</span> wrapper <span class="op">=</span> <span class="at">shallowMount</span>(MyComponent)
  <span class="va">wrapper</span>.<span class="at">setData</span>(<span class="op">{</span> <span class="dt">message</span><span class="op">:</span> <span class="st">&#39;foo&#39;</span> <span class="op">}</span>)

  <span class="co">// Wait a &quot;tick&quot; after state change before asserting DOM updates</span>
  await <span class="va">wrapper</span>.<span class="va">vm</span>.<span class="at">$nextTick</span>()
  <span class="at">expect</span>(<span class="va">wrapper</span>.<span class="at">text</span>()).<span class="at">toBe</span>(<span class="st">&#39;foo&#39;</span>)
<span class="op">}</span>)</code></pre></div>
<p>For more in-depth information on unit testing in Vue, check out <a href="https://vue-test-utils.vuejs.org/">Vue Test Utils</a> and our cookbook entry about <a href="https://vuejs.org/v2/cookbook/unit-testing-vue-components.html">unit testing vue components</a>.</p>
<h1 id="typescript-support"><a name=#guide/typescript.md></a>TypeScript Support</h1>
<blockquote>
<p><a href="https://cli.vuejs.org">Vue CLI</a> provides built-in TypeScript tooling support.</p>
</blockquote>
<h2 id="official-declaration-in-npm-packages">Official Declaration in NPM Packages</h2>
<p>A static type system can help prevent many potential runtime errors, especially as applications grow. That's why Vue ships with <a href="https://github.com/vuejs/vue/tree/dev/types">official type declarations</a> for <a href="https://www.typescriptlang.org/">TypeScript</a> - not only in Vue core, but also for <a href="https://github.com/vuejs/vue-router/tree/dev/types">vue-router</a> and <a href="https://github.com/vuejs/vuex/tree/dev/types">vuex</a> as well.</p>
<p>Since these are <a href="https://cdn.jsdelivr.net/npm/vue/types/">published on NPM</a>, and the latest TypeScript knows how to resolve type declarations in NPM packages, this means when installed via NPM, you don't need any additional tooling to use TypeScript with Vue.</p>
<h2 id="recommended-configuration">Recommended Configuration</h2>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// tsconfig.json</span>
<span class="op">{</span>
  <span class="st">&quot;compilerOptions&quot;</span><span class="op">:</span> <span class="op">{</span>
    <span class="co">// this aligns with Vue&#39;s browser support</span>
    <span class="st">&quot;target&quot;</span><span class="op">:</span> <span class="st">&quot;es5&quot;</span><span class="op">,</span>
    <span class="co">// this enables stricter inference for data properties on `this`</span>
    <span class="st">&quot;strict&quot;</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
    <span class="co">// if using webpack 2+ or rollup, to leverage tree shaking:</span>
    <span class="st">&quot;module&quot;</span><span class="op">:</span> <span class="st">&quot;es2015&quot;</span><span class="op">,</span>
    <span class="st">&quot;moduleResolution&quot;</span><span class="op">:</span> <span class="st">&quot;node&quot;</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>Note that you have to include <code>strict: true</code> (or at least <code>noImplicitThis: true</code> which is a part of <code>strict</code> flag) to leverage type checking of <code>this</code> in component methods otherwise it is always treated as <code>any</code> type.</p>
<p>See <a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html">TypeScript compiler options docs</a> for more details.</p>
<h2 id="development-tooling">Development Tooling</h2>
<h3 id="project-creation">Project Creation</h3>
<p><a href="https://github.com/vuejs/vue-cli">Vue CLI 3</a> can generate new projects that use TypeScript. To get started:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># 1. Install Vue CLI, if it&#39;s not already installed</span>
<span class="ex">npm</span> install --global @vue/cli

<span class="co"># 2. Create a new project, then choose the &quot;Manually select features&quot; option</span>
<span class="ex">vue</span> create my-project-name</code></pre></div>
<h3 id="editor-support">Editor Support</h3>
<p>For developing Vue applications with TypeScript, we strongly recommend using <a href="https://code.visualstudio.com/">Visual Studio Code</a>, which provides great out-of-the-box support for TypeScript. If you are using <a href="./single-file-components.html">single-file components</a> (SFCs), get the awesome <a href="https://github.com/vuejs/vetur">Vetur extension</a>, which provides TypeScript inference inside SFCs and many other great features.</p>
<p><a href="https://www.jetbrains.com/webstorm/">WebStorm</a> also provides out-of-the-box support for both TypeScript and Vue.</p>
<h2 id="basic-usage-1">Basic Usage</h2>
<p>To let TypeScript properly infer types inside Vue component options, you need to define components with <code>Vue.component</code> or <code>Vue.extend</code>:</p>
<pre class="ts"><code>import Vue from &#39;vue&#39;

const Component = Vue.extend({
  // type inference enabled
})

const Component = {
  // this will NOT have type inference,
  // because TypeScript can&#39;t tell this is options for a Vue component.
}</code></pre>
<h2 id="class-style-vue-components">Class-Style Vue Components</h2>
<p>If you prefer a class-based API when declaring components, you can use the officially maintained <a href="https://github.com/vuejs/vue-class-component">vue-class-component</a> decorator:</p>
<pre class="ts"><code>import Vue from &#39;vue&#39;
import Component from &#39;vue-class-component&#39;

// The @Component decorator indicates the class is a Vue component
@Component({
  // All component options are allowed in here
  template: &#39;&lt;button @click=&quot;onClick&quot;&gt;Click!&lt;/button&gt;&#39;
})
export default class MyComponent extends Vue {
  // Initial data can be declared as instance properties
  message: string = &#39;Hello!&#39;

  // Component methods can be declared as instance methods
  onClick (): void {
    window.alert(this.message)
  }
}</code></pre>
<h2 id="augmenting-types-for-use-with-plugins">Augmenting Types for Use with Plugins</h2>
<p>Plugins may add to Vue's global/instance properties and component options. In these cases, type declarations are needed to make plugins compile in TypeScript. Fortunately, there's a TypeScript feature to augment existing types called <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation">module augmentation</a>.</p>
<p>For example, to declare an instance property <code>$myProperty</code> with type <code>string</code>:</p>
<pre class="ts"><code>// 1. Make sure to import &#39;vue&#39; before declaring augmented types
import Vue from &#39;vue&#39;

// 2. Specify a file with the types you want to augment
//    Vue has the constructor type in types/vue.d.ts
declare module &#39;vue/types/vue&#39; {
  // 3. Declare augmentation for Vue
  interface Vue {
    $myProperty: string
  }
}</code></pre>
<p>After including the above code as a declaration file (like <code>my-property.d.ts</code>) in your project, you can use <code>$myProperty</code> on a Vue instance.</p>
<pre class="ts"><code>var vm = new Vue()
console.log(vm.$myProperty) // This should compile successfully</code></pre>
<p>You can also declare additional global properties and component options:</p>
<pre class="ts"><code>import Vue from &#39;vue&#39;

declare module &#39;vue/types/vue&#39; {
  // Global properties can be declared
  // on the `VueConstructor` interface
  interface VueConstructor {
    $myGlobal: string
  }
}

// ComponentOptions is declared in types/options.d.ts
declare module &#39;vue/types/options&#39; {
  interface ComponentOptions&lt;V extends Vue&gt; {
    myOption?: string
  }
}</code></pre>
<p>The above declarations allow the following code to be compiled:</p>
<pre class="ts"><code>// Global property
console.log(Vue.$myGlobal)

// Additional component option
var vm = new Vue({
  myOption: &#39;Hello&#39;
})</code></pre>
<h2 id="annotating-return-types">Annotating Return Types</h2>
<p>Because of the circular nature of Vue's declaration files, TypeScript may have difficulties inferring the types of certain methods. For this reason, you may need to annotate the return type on methods like <code>render</code> and those in <code>computed</code>.</p>
<pre class="ts"><code>import Vue, { VNode } from &#39;vue&#39;

const Component = Vue.extend({
  data () {
    return {
      msg: &#39;Hello&#39;
    }
  },
  methods: {
    // need annotation due to `this` in return type
    greet (): string {
      return this.msg + &#39; world&#39;
    }
  },
  computed: {
    // need annotation
    greeting(): string {
      return this.greet() + &#39;!&#39;
    }
  },
  // `createElement` is inferred, but `render` needs return type
  render (createElement): VNode {
    return createElement(&#39;div&#39;, this.greeting)
  }
})</code></pre>
<p>If you find type inference or member completion isn't working, annotating certain methods may help address these problems. Using the <code>--noImplicitAny</code> option will help find many of these unannotated methods.</p>
<h2 id="annotating-props">Annotating Props</h2>
<pre class="ts"><code>import Vue, { PropType } from &#39;vue&#39;

interface ComplexMessage { 
  title: string,
  okMessage: string,
  cancelMessage: string
}
const Component = Vue.extend({
  props: {
    name: String,
    success: { type: String },
    callback: { 
      type: Function as PropType&lt;() =&gt; void&gt;
    },
    message: {
      type: Object as PropType&lt;ComplexMessage&gt;,
      required: true,
      validator (message: ComplexMessage) {
        return !!message.title;
      }
    }
  }
})</code></pre>
<p>If you find validator not getting type inference or member completion isn't working, annotating the argument with the expected type may help address these problems.</p>
<h1 id="production-deployment"><a name=#guide/deployment.md></a>Production Deployment</h1>
<blockquote>
<p>Most of the tips below are enabled by default if you are using <a href="https://cli.vuejs.org">Vue CLI</a>. This section is only relevant if you are using a custom build setup.</p>
</blockquote>
<h2 id="turn-on-production-mode">Turn on Production Mode</h2>
<p>During development, Vue provides a lot of warnings to help you with common errors and pitfalls. However, these warning strings become useless in production and bloat your app's payload size. In addition, some of these warning checks have small runtime costs that can be avoided in production mode.</p>
<h3 id="without-build-tools">Without Build Tools</h3>
<p>If you are using the full build, i.e. directly including Vue via a script tag without a build tool, make sure to use the minified version (<code>vue.min.js</code>) for production. Both versions can be found in the <a href="installation.html#Direct-lt-script-gt-Include">Installation guide</a>.</p>
<h3 id="with-build-tools">With Build Tools</h3>
<p>When using a build tool like Webpack or Browserify, the production mode will be determined by <code>process.env.NODE_ENV</code> inside Vue's source code, and it will be in development mode by default. Both build tools provide ways to overwrite this variable to enable Vue's production mode, and warnings will be stripped by minifiers during the build. All <code>vue-cli</code> templates have these pre-configured for you, but it would be beneficial to know how it is done:</p>
<h4 id="webpack-2">Webpack</h4>
<p>In Webpack 4+, you can use the <code>mode</code> option:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">module</span>.<span class="at">exports</span> <span class="op">=</span> <span class="op">{</span>
  <span class="dt">mode</span><span class="op">:</span> <span class="st">&#39;production&#39;</span>
<span class="op">}</span></code></pre></div>
<p>But in Webpack 3 and earlier, you'll need to use <a href="https://webpack.js.org/plugins/define-plugin/">DefinePlugin</a>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> webpack <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;webpack&#39;</span>)

<span class="va">module</span>.<span class="at">exports</span> <span class="op">=</span> <span class="op">{</span>
  <span class="co">// ...</span>
  <span class="dt">plugins</span><span class="op">:</span> [
    <span class="co">// ...</span>
    <span class="kw">new</span> <span class="va">webpack</span>.<span class="at">DefinePlugin</span>(<span class="op">{</span>
      <span class="st">&#39;process.env.NODE_ENV&#39;</span><span class="op">:</span> <span class="va">JSON</span>.<span class="at">stringify</span>(<span class="st">&#39;production&#39;</span>)
    <span class="op">}</span>)
  ]
<span class="op">}</span></code></pre></div>
<h4 id="browserify-2">Browserify</h4>
<ul>
<li><p>Run your bundling command with the actual <code>NODE_ENV</code> environment variable set to <code>&quot;production&quot;</code>. This tells <code>vueify</code> to avoid including hot-reload and development related code.</p></li>
<li><p>Apply a global <a href="https://github.com/hughsk/envify">envify</a> transform to your bundle. This allows the minifier to strip out all the warnings in Vue's source code wrapped in env variable conditional blocks. For example:</p></li>
</ul>
<p><code>bash   NODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m &gt; build.js</code></p>
<ul>
<li>Or, using <a href="https://github.com/hughsk/envify">envify</a> with Gulp:</li>
</ul>
<p>``` js // Use the envify custom module to specify environment variables var envify = require('envify/custom')</p>
<p>browserify(browserifyOptions) .transform(vueify) .transform( // Required in order to process node_modules files { global: true }, envify({ NODE_ENV: 'production' }) ) .bundle() ```</p>
<ul>
<li>Or, using <a href="https://github.com/hughsk/envify">envify</a> with Grunt and <a href="https://github.com/jmreidy/grunt-browserify">grunt-browserify</a>:</li>
</ul>
<p>``` js // Use the envify custom module to specify environment variables var envify = require('envify/custom')</p>
<p>browserify: { dist: { options: { // Function to deviate from grunt-browserify's default order configure: b =&gt; b .transform('vueify') .transform( // Required in order to process node_modules files { global: true }, envify({ NODE_ENV: 'production' }) ) .bundle() } } } ```</p>
<h4 id="rollup-2">Rollup</h4>
<p>Use <span class="citation">[@rollup/plugin-replace]</span>(https://github.com/rollup/plugins/tree/master/packages/replace):</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">const</span> replace <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;@rollup/plugin-replace&#39;</span>)

<span class="at">rollup</span>(<span class="op">{</span>
  <span class="co">// ...</span>
  <span class="dt">plugins</span><span class="op">:</span> [
    <span class="at">replace</span>(<span class="op">{</span>
      <span class="st">&#39;process.env.NODE_ENV&#39;</span><span class="op">:</span> <span class="va">JSON</span>.<span class="at">stringify</span>( <span class="st">&#39;production&#39;</span> )
    <span class="op">}</span>)
  ]
<span class="op">}</span>).<span class="at">then</span>(...)</code></pre></div>
<h2 id="pre-compiling-templates">Pre-Compiling Templates</h2>
<p>When using in-DOM templates or in-JavaScript template strings, the template-to-render-function compilation is performed on the fly. This is usually fast enough in most cases, but is best avoided if your application is performance-sensitive.</p>
<p>The easiest way to pre-compile templates is using <a href="single-file-components.html">Single-File Components</a> - the associated build setups automatically performs pre-compilation for you, so the built code contains the already compiled render functions instead of raw template strings.</p>
<p>If you are using Webpack, and prefer separating JavaScript and template files, you can use <a href="https://github.com/ktsn/vue-template-loader">vue-template-loader</a>, which also transforms the template files into JavaScript render functions during the build step.</p>
<h2 id="extracting-component-css">Extracting Component CSS</h2>
<p>When using Single-File Components, the CSS inside components are injected dynamically as <code>&lt;style&gt;</code> tags via JavaScript. This has a small runtime cost, and if you are using server-side rendering it will cause a &quot;flash of unstyled content&quot;. Extracting the CSS across all components into the same file will avoid these issues, and also result in better CSS minification and caching.</p>
<p>Refer to the respective build tool documentations to see how it's done:</p>
<ul>
<li><a href="https://vue-loader.vuejs.org/en/configurations/extract-css.html">Webpack + vue-loader</a> (the <code>vue-cli</code> webpack template has this pre-configured)</li>
<li><a href="https://github.com/vuejs/vueify#css-extraction">Browserify + vueify</a></li>
<li><a href="https://vuejs.github.io/rollup-plugin-vue/#/en/2.3/?id=custom-handler">Rollup + rollup-plugin-vue</a></li>
</ul>
<h2 id="tracking-runtime-errors">Tracking Runtime Errors</h2>
<p>If a runtime error occurs during a component's render, it will be passed to the global <code>Vue.config.errorHandler</code> config function if it has been set. It might be a good idea to leverage this hook together with an error-tracking service like <a href="https://sentry.io">Sentry</a>, which provides <a href="https://sentry.io/for/vue/">an official integration</a> for Vue.</p>
<h1 id="routing"><a name=#guide/routing.md></a>Routing</h1>
<h2 id="official-router">Official Router</h2>
<p>For most Single Page Applications, it's recommended to use the officially-supported <a href="https://github.com/vuejs/vue-router">vue-router library</a>. For more details, see vue-router's <a href="https://router.vuejs.org/">documentation</a>.</p>
<h2 id="simple-routing-from-scratch">Simple Routing From Scratch</h2>
<p>If you only need very simple routing and do not wish to involve a full-featured router library, you can do so by dynamically rendering a page-level component like this:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">const</span> NotFound <span class="op">=</span> <span class="op">{</span> <span class="dt">template</span><span class="op">:</span> <span class="st">&#39;&lt;p&gt;Page not found&lt;/p&gt;&#39;</span> <span class="op">}</span>
<span class="kw">const</span> Home <span class="op">=</span> <span class="op">{</span> <span class="dt">template</span><span class="op">:</span> <span class="st">&#39;&lt;p&gt;home page&lt;/p&gt;&#39;</span> <span class="op">}</span>
<span class="kw">const</span> About <span class="op">=</span> <span class="op">{</span> <span class="dt">template</span><span class="op">:</span> <span class="st">&#39;&lt;p&gt;about page&lt;/p&gt;&#39;</span> <span class="op">}</span>

<span class="kw">const</span> routes <span class="op">=</span> <span class="op">{</span>
  <span class="st">&#39;/&#39;</span><span class="op">:</span> Home<span class="op">,</span>
  <span class="st">&#39;/about&#39;</span><span class="op">:</span> About
<span class="op">}</span>

<span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#app&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">currentRoute</span><span class="op">:</span> <span class="va">window</span>.<span class="va">location</span>.<span class="at">pathname</span>
  <span class="op">},</span>
  <span class="dt">computed</span><span class="op">:</span> <span class="op">{</span>
    <span class="at">ViewComponent</span> () <span class="op">{</span>
      <span class="cf">return</span> routes[<span class="kw">this</span>.<span class="at">currentRoute</span>] <span class="op">||</span> NotFound
    <span class="op">}</span>
  <span class="op">},</span>
  <span class="at">render</span> (h) <span class="op">{</span> <span class="cf">return</span> <span class="at">h</span>(<span class="kw">this</span>.<span class="at">ViewComponent</span>) <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>Combined with the HTML5 History API, you can build a very basic but fully-functional client-side router. To see that in practice, check out <a href="https://github.com/chrisvfritz/vue-2.0-simple-routing-example">this example app</a>.</p>
<h2 id="integrating-3rd-party-routers">Integrating 3rd-Party Routers</h2>
<p>If there's a 3rd-party router you prefer to use, such as <a href="https://github.com/visionmedia/page.js">Page.js</a> or <a href="https://github.com/flatiron/director">Director</a>, integration is <a href="https://github.com/chrisvfritz/vue-2.0-simple-routing-example/compare/master...pagejs">similarly easy</a>. Here's a <a href="https://github.com/chrisvfritz/vue-2.0-simple-routing-example/tree/pagejs">complete example</a> using Page.js.</p>
<h1 id="state-management"><a name=#guide/state-management.md></a>State Management</h1>
<h2 id="official-flux-like-implementation">Official Flux-Like Implementation</h2>
<p>Large applications can often grow in complexity, due to multiple pieces of state scattered across many components and the interactions between them. To solve this problem, Vue offers <a href="https://github.com/vuejs/vuex">vuex</a>: our own Elm-inspired state management library. It even integrates into <a href="https://github.com/vuejs/vue-devtools">vue-devtools</a>, providing zero-setup access to <a href="https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif">time travel debugging</a>.</p>
<div class="vue-mastery">
<a href="https://www.vuemastery.com/courses/mastering-vuex/intro-to-vuex/" target="_blank" rel="sponsored noopener" title="Vuex Tutorial">Watch a video explanation on Vue Mastery</a>
</div>
<h3 id="information-for-react-developers">Information for React Developers</h3>
<p>If you're coming from React, you may be wondering how vuex compares to <a href="https://github.com/reactjs/redux">redux</a>, the most popular Flux implementation in that ecosystem. Redux is actually view-layer agnostic, so it can easily be used with Vue via <a href="https://classic.yarnpkg.com/en/packages?q=redux%20vue&amp;p=1">simple bindings</a>. Vuex is different in that it <em>knows</em> it's in a Vue app. This allows it to better integrate with Vue, offering a more intuitive API and improved development experience.</p>
<h2 id="simple-state-management-from-scratch">Simple State Management from Scratch</h2>
<p>It is often overlooked that the source of truth in Vue applications is the raw <code>data</code> object - a Vue instance only proxies access to it. Therefore, if you have a piece of state that should be shared by multiple instances, you can share it by identity:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> sourceOfTruth <span class="op">=</span> <span class="op">{}</span>

<span class="kw">var</span> vmA <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">data</span><span class="op">:</span> sourceOfTruth
<span class="op">}</span>)

<span class="kw">var</span> vmB <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">data</span><span class="op">:</span> sourceOfTruth
<span class="op">}</span>)</code></pre></div>
<p>Now whenever <code>sourceOfTruth</code> is mutated, both <code>vmA</code> and <code>vmB</code> will update their views automatically. Subcomponents within each of these instances would also have access via <code>this.$root.$data</code>. We have a single source of truth now, but debugging would be a nightmare. Any piece of data could be changed by any part of our app at any time, without leaving a trace.</p>
<p>To help solve this problem, we can adopt a <strong>store pattern</strong>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> store <span class="op">=</span> <span class="op">{</span>
  <span class="dt">debug</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span>
  <span class="dt">state</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">message</span><span class="op">:</span> <span class="st">&#39;Hello!&#39;</span>
  <span class="op">},</span>
  <span class="at">setMessageAction</span> (newValue) <span class="op">{</span>
    <span class="cf">if</span> (<span class="kw">this</span>.<span class="at">debug</span>) <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;setMessageAction triggered with&#39;</span><span class="op">,</span> newValue)
    <span class="kw">this</span>.<span class="va">state</span>.<span class="at">message</span> <span class="op">=</span> newValue
  <span class="op">},</span>
  <span class="at">clearMessageAction</span> () <span class="op">{</span>
    <span class="cf">if</span> (<span class="kw">this</span>.<span class="at">debug</span>) <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;clearMessageAction triggered&#39;</span>)
    <span class="kw">this</span>.<span class="va">state</span>.<span class="at">message</span> <span class="op">=</span> <span class="st">&#39;&#39;</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>Notice all actions that mutate the store's state are put inside the store itself. This type of centralized state management makes it easier to understand what type of mutations could happen and how they are triggered. Now when something goes wrong, we'll also have a log of what happened leading up to the bug.</p>
<p>In addition, each instance/component can still own and manage its own private state:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> vmA <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">privateState</span><span class="op">:</span> <span class="op">{},</span>
    <span class="dt">sharedState</span><span class="op">:</span> <span class="va">store</span>.<span class="at">state</span>
  <span class="op">}</span>
<span class="op">}</span>)

<span class="kw">var</span> vmB <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">privateState</span><span class="op">:</span> <span class="op">{},</span>
    <span class="dt">sharedState</span><span class="op">:</span> <span class="va">store</span>.<span class="at">state</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<div class="figure">
<img src="../images/state.png" alt="State Management" />
<p class="caption">State Management</p>
</div>
<p class="tip">
It's important to note that you should never replace the original state object in your actions - the components and the store need to share reference to the same object in order for mutations to be observed.
</p>
<p>As we continue developing the convention where components are never allowed to directly mutate state that belongs to a store, but should instead dispatch events that notify the store to perform actions, we eventually arrive at the <a href="https://facebook.github.io/flux/">Flux</a> architecture. The benefit of this convention is we can record all state mutations happening to the store and implement advanced debugging helpers such as mutation logs, snapshots, and history re-rolls / time travel.</p>
<p>This brings us full circle back to <a href="https://github.com/vuejs/vuex">vuex</a>, so if you've read this far it's probably time to try it out!</p>
<h1 id="server-side-rendering"><a name=#guide/ssr.md></a>Server-Side Rendering</h1>
<h2 id="the-complete-ssr-guide">The Complete SSR Guide</h2>
<p>We have created a standalone guide for creating server-rendered Vue applications. This is a very in-depth guide for those who are already familiar with client-side Vue development, server-side Node.js development and webpack. Check it out at <a href="https://ssr.vuejs.org/">ssr.vuejs.org</a>.</p>
<h2 id="nuxt.js">Nuxt.js</h2>
<p>Properly configuring all the discussed aspects of a production-ready server-rendered app can be a daunting task. Luckily, there is an excellent community project that aims to make all of this easier: <a href="https://nuxtjs.org/">Nuxt.js</a>. Nuxt.js is a higher-level framework built on top of the Vue ecosystem which provides an extremely streamlined development experience for writing universal Vue applications. Better yet, you can even use it as a static site generator (with pages authored as single-file Vue components)! We highly recommend giving it a try.</p>
<h2 id="quasar-framework-ssr-pwa">Quasar Framework SSR + PWA</h2>
<p><a href="https://quasar.dev">Quasar Framework</a> will generate an SSR app (with optional PWA handoff) that leverages its best-in-class build system, sensible configuration and developer extensibility to make designing and building your idea a breeze. With over one hundred specific &quot;Material Design 2.0&quot;-compliant components, you can decide which ones to execute on the server, which are available in the browser - and even manage the <code>&lt;meta&gt;</code> tags of your site. Quasar is a node.js and webpack based development environment that supercharges and streamlines rapid development of SPA, PWA, SSR, Electron, Capacitor and Cordova apps - all from one codebase.</p>
<h1 id="security"><a name=#guide/security.md></a>Security</h1>
<h2 id="reporting-vulnerabilities">Reporting Vulnerabilities</h2>
<p>When a vulnerability is reported, it immediately becomes our top concern, with a full-time contributor dropping everything to work on it. To report a vulnerability, please email <a href="mailto:security@vuejs.org">security@vuejs.org</a>.</p>
<p>While the discovery of new vulnerabilities is rare, we also recommend always using the latest versions of Vue and its official companion libraries to ensure your application remains as secure as possible.</p>
<h2 id="rule-no.1-never-use-non-trusted-templates">Rule No.1: Never Use Non-trusted Templates</h2>
<p>The most fundamental security rule when using Vue is <strong>never use non-trusted content as your component template</strong>. Doing so is equivalent to allowing arbitrary JavaScript execution in your application - and worse, could lead to server breaches if the code is executed during server-side rendering. An example of such usage:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#app&#39;</span><span class="op">,</span>
  <span class="dt">template</span><span class="op">:</span> <span class="vs">`&lt;div&gt;`</span> <span class="op">+</span> userProvidedString <span class="op">+</span> <span class="vs">`&lt;/div&gt;`</span> <span class="co">// NEVER DO THIS</span>
<span class="op">}</span>)</code></pre></div>
<p>Vue templates are compiled into JavaScript, and expressions inside templates will be executed as part of the rendering process. Although the expressions are evaluated against a specific rendering context, due to the complexity of potential global execution environments, it is impractical for a framework like Vue to completely shield you from potential malicious code execution without incurring unrealistic performance overhead. The most straightforward way to avoid this category of problems altogether is to make sure the contents of your Vue templates are always trusted and entirely controlled by you.</p>
<h2 id="what-vue-does-to-protect-you">What Vue Does to Protect You</h2>
<h3 id="html-content">HTML content</h3>
<p>Whether using templates or render functions, content is automatically escaped. That means in this template:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;h1&gt;</span>{{ userProvidedString }}<span class="kw">&lt;/h1&gt;</span></code></pre></div>
<p>if <code>userProvidedString</code> contained:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="st">&#39;&lt;script&gt;alert(&quot;hi&quot;)&lt;/script&gt;&#39;</span></code></pre></div>
<p>then it would be escaped to the following HTML:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="dv">&amp;lt;</span>script<span class="dv">&amp;gt;</span>alert(<span class="dv">&amp;quot;</span>hi<span class="dv">&amp;quot;</span>)<span class="dv">&amp;lt;</span>/script<span class="dv">&amp;gt;</span></code></pre></div>
<p>thus preventing the script injection. This escaping is done using native browser APIs, like <code>textContent</code>, so a vulnerability can only exist if the browser itself is vulnerable.</p>
<h3 id="attribute-bindings">Attribute bindings</h3>
<p>Similarly, dynamic attribute bindings are also automatically escaped. That means in this template:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;h1</span><span class="ot"> v-bind:title=</span><span class="st">&quot;userProvidedString&quot;</span><span class="kw">&gt;</span>
  hello
<span class="kw">&lt;/h1&gt;</span></code></pre></div>
<p>if <code>userProvidedString</code> contained:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="st">&#39;&quot; onclick=&quot;alert(</span><span class="sc">\&#39;</span><span class="st">hi</span><span class="sc">\&#39;</span><span class="st">)&#39;</span></code></pre></div>
<p>then it would be escaped to the following HTML:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="dv">&amp;quot;</span> onclick=<span class="dv">&amp;quot;</span>alert(&#39;hi&#39;)</code></pre></div>
<p>thus preventing the close of the <code>title</code> attribute to inject new, arbitrary HTML. This escaping is done using native browser APIs, like <code>setAttribute</code>, so a vulnerability can only exist if the browser itself is vulnerable.</p>
<h2 id="potential-dangers">Potential Dangers</h2>
<p>In any web application, allowing unsanitized, user-provided content to be executed as HTML, CSS, or JavaScript is potentially dangerous, so should be avoided wherever possible. There are times when some risk be acceptable though.</p>
<p>For example, services like CodePen and JSFiddle allow user-provided content to be executed, but it's in a context where this is expected and sandboxed to some extent inside iframes. In the cases when an important feature inherently requires some level of vulnerability, it's up to your team to weigh the importance of the feature against the worst-case scenarios the vulnerability enables.</p>
<h3 id="injecting-html">Injecting HTML</h3>
<p>As you learned earlier, Vue automatically escapes HTML content, preventing you from accidentally injecting executable HTML into your application. However, in cases where you know the HTML is safe, you can explicitly render HTML content:</p>
<ul>
<li><p>Using a template: <code>html   &lt;div v-html=&quot;userProvidedHtml&quot;&gt;&lt;/div&gt;</code></p></li>
<li><p>Using a render function: <code>js   h('div', { domProps: {   innerHTML: this.userProvidedHtml }   })</code></p></li>
<li><p>Using a render function with JSX: <code>jsx   &lt;div domPropsInnerHTML={this.userProvidedHtml}&gt;&lt;/div&gt;</code></p></li>
</ul>
<p class="tip">
Note that user-provided HTML can never be considered 100% safe unless it's in a sandboxed iframe or in a part of the app where only the user who wrote that HTML can ever be exposed to it. Additionally, allowing users to write their own Vue templates brings similar dangers.
</p>
<h3 id="injecting-urls">Injecting URLs</h3>
<p>In a URL like this:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;a</span><span class="ot"> v-bind:href=</span><span class="st">&quot;userProvidedUrl&quot;</span><span class="kw">&gt;</span>
  click me
<span class="kw">&lt;/a&gt;</span></code></pre></div>
<p>There's a potential security issue if the URL has not been &quot;sanitized&quot; to prevent JavaScript execution using <code>javascript:</code>. There are libraries such as <a href="https://www.npmjs.com/package/@braintree/sanitize-url">sanitize-url</a> to help with this, but note:</p>
<p class="tip">
If you're ever doing URL sanitization on the frontend, you already have a security issue. User-provided URLs should always be sanitized by your backend before even being saved to a database. Then the problem is avoided for <em>every</em> client connecting to your API, including native mobile apps. Also note that even with sanitized URLs, Vue cannot help you guarantee that they lead to safe destinations.
</p>
<h3 id="injecting-styles">Injecting Styles</h3>
<p>Looking at this example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;a</span>
<span class="ot">  v-bind:href=</span><span class="st">&quot;sanitizedUrl&quot;</span>
<span class="ot">  v-bind:style=</span><span class="st">&quot;userProvidedStyles&quot;</span>
<span class="kw">&gt;</span>
  click me
<span class="kw">&lt;/a&gt;</span></code></pre></div>
<p>let's assume that <code>sanitizedUrl</code> has been sanitized, so that it's definitely a real URL and not JavaScript. With the <code>userProvidedStyles</code>, malicious users could still provide CSS to &quot;click jack&quot;, e.g. styling the link into a transparent box over the &quot;Log in&quot; button. Then if <code>https://user-controlled-website.com/</code> is built to resemble the login page of your application, they might have just captured a user's real login information.</p>
<p>You may be able to imagine how allowing user-provided content for a <code>&lt;style&gt;</code> element would create an even greater vulnerability, giving that user full control over how to style the entire page. That's why Vue prevents rendering of style tags inside templates, such as:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;style&gt;</span>{{ userProvidedStyles }}<span class="kw">&lt;/style&gt;</span></code></pre></div>
<p>To keep your users fully safe from click jacking, we recommend only allowing full control over CSS inside a sandboxed iframe. Alternatively, when providing user control through a style binding, we recommend using its <a href="class-and-style.html#Object-Syntax-1">object syntax</a> and only allowing users to provide values for specific properties it's safe for them to control, like this:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;a</span>
<span class="ot">  v-bind:href=</span><span class="st">&quot;sanitizedUrl&quot;</span>
<span class="ot">  v-bind:style=</span><span class="st">&quot;{</span>
<span class="st">    color: userProvidedColor,</span>
<span class="st">    background: userProvidedBackground</span>
<span class="st">  }&quot;</span>
<span class="kw">&gt;</span>
  click me
<span class="kw">&lt;/a&gt;</span></code></pre></div>
<h3 id="injecting-javascript">Injecting JavaScript</h3>
<p>We strongly discourage ever rendering a <code>&lt;script&gt;</code> element with Vue, since templates and render functions should never have side effects. However, this isn't the only way to include strings that would be evaluated as JavaScript at runtime.</p>
<p>Every HTML element has attributes with values accepting strings of JavaScript, such as <code>onclick</code>, <code>onfocus</code>, and <code>onmouseenter</code>. Binding user-provided JavaScript to any of these event attributes is a potential security risk, so should be avoided.</p>
<p class="tip">
Note that user-provided JavaScript can never be considered 100% safe unless it's in a sandboxed iframe or in a part of the app where only the user who wrote that JavaScript can ever be exposed to it.
</p>
<p>Sometimes we receive vulnerability reports on how it's possible to do cross-site scripting (XSS) in Vue templates. In general, we do not consider such cases to be actual vulnerabilities, because there's no practical way to protect developers from the two scenarios that would allow XSS:</p>
<ol style="list-style-type: decimal">
<li><p>The developer is explicitly asking Vue to render user-provided, unsanitized content as Vue templates. This is inherently unsafe and there's no way for Vue to know the origin.</p></li>
<li><p>The developer is mounting Vue to an entire HTML page which happens to contain server-rendered and user-provided content. This is fundamentally the same problem as #1, but sometimes devs may do it without realizing. This can lead to possible vulnerabilities where the attacker provides HTML which is safe as plain HTML but unsafe as a Vue template. The best practice is to never mount Vue on nodes that may contain server-rendered and user-provided content.</p></li>
</ol>
<h2 id="best-practices">Best Practices</h2>
<p>The general rule is that if you allow unsanitized, user-provided content to be executed (as either HTML, JavaScript, or even CSS), you might be opening yourself up to attacks. This advice actually holds true whether using Vue, another framework, or even no framework.</p>
<p>Beyond the recommendations made above for <a href="#Potential-Dangers">Potential Dangers</a>, we also recommend familiarizing yourself with these resources:</p>
<ul>
<li><a href="https://html5sec.org/">HTML5 Security Cheat Sheet</a></li>
<li><a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html">OWASP's Cross Site Scripting (XSS) Prevention Cheat Sheet</a></li>
</ul>
<p>Then use what you learn to also review the source code of your dependencies for potentially dangerous patterns, if any of them include 3rd-party components or otherwise influence what's rendered to the DOM.</p>
<h2 id="backend-coordination">Backend Coordination</h2>
<p>HTTP security vulnerabilities, such as cross-site request forgery (CSRF/XSRF) and cross-site script inclusion (XSSI), are primarily addressed on the backend, so aren't a concern of Vue's. However, it's still a good idea to communicate with your backend team to learn how to best interact with their API, e.g. by submitting CSRF tokens with form submissions.</p>
<h2 id="server-side-rendering-ssr">Server-Side Rendering (SSR)</h2>
<p>There are some additional security concerns when using SSR, so make sure to follow the best practices outlined throughout <a href="https://ssr.vuejs.org/">our SSR documentation</a> to avoid vulnerabilities.</p>
<h1 id="reactivity-in-depth"><a name=#guide/reactivity.md></a>Reactivity in Depth</h1>
<p>Now it's time to take a deep dive! One of Vue's most distinct features is the unobtrusive reactivity system. Models are just plain JavaScript objects. When you modify them, the view updates. It makes state management simple and intuitive, but it's also important to understand how it works to avoid some common gotchas. In this section, we are going to dig into some of the lower-level details of Vue's reactivity system.</p>
<div class="vue-mastery">
<a href="https://www.vuemastery.com/courses/advanced-components/build-a-reactivity-system" target="_blank" rel="sponsored noopener" title="Vue Reactivity">Watch a video explanation on Vue Mastery</a>
</div>
<h2 id="how-changes-are-tracked">How Changes Are Tracked</h2>
<p>When you pass a plain JavaScript object to a Vue instance as its <code>data</code> option, Vue will walk through all of its properties and convert them to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters">getter/setters</a> using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty</code></a>. This is an ES5-only and un-shimmable feature, which is why Vue doesn't support IE8 and below.</p>
<p>The getter/setters are invisible to the user, but under the hood they enable Vue to perform dependency-tracking and change-notification when properties are accessed or modified. One caveat is that browser consoles format getter/setters differently when converted data objects are logged, so you may want to install <a href="https://github.com/vuejs/vue-devtools">vue-devtools</a> for a more inspection-friendly interface.</p>
<p>Every component instance has a corresponding <strong>watcher</strong> instance, which records any properties &quot;touched&quot; during the component's render as dependencies. Later on when a dependency's setter is triggered, it notifies the watcher, which in turn causes the component to re-render.</p>
<div class="figure">
<img src="../images/data.png" alt="Reactivity Cycle" />
<p class="caption">Reactivity Cycle</p>
</div>
<h2 id="change-detection-caveats">Change Detection Caveats</h2>
<p>Due to limitations in JavaScript, there are types of changes that Vue <strong>cannot detect</strong>. However, there are ways to circumvent them to preserve reactivity.</p>
<h3 id="for-objects">For Objects</h3>
<p>Vue cannot detect property addition or deletion. Since Vue performs the getter/setter conversion process during instance initialization, a property must be present in the <code>data</code> object in order for Vue to convert it and make it reactive. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> vm <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">a</span><span class="op">:</span> <span class="dv">1</span>
  <span class="op">}</span>
<span class="op">}</span>)
<span class="co">// `vm.a` is now reactive</span>

<span class="va">vm</span>.<span class="at">b</span> <span class="op">=</span> <span class="dv">2</span>
<span class="co">// `vm.b` is NOT reactive</span></code></pre></div>
<p>Vue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it's possible to add reactive properties to a nested object using the <code>Vue.set(object, propertyName, value)</code> method:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">set</span>(<span class="va">vm</span>.<span class="at">someObject</span><span class="op">,</span> <span class="st">&#39;b&#39;</span><span class="op">,</span> <span class="dv">2</span>)</code></pre></div>
<p>You can also use the <code>vm.$set</code> instance method, which is an alias to the global <code>Vue.set</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">this</span>.<span class="at">$set</span>(<span class="kw">this</span>.<span class="at">someObject</span><span class="op">,</span> <span class="st">&#39;b&#39;</span><span class="op">,</span> <span class="dv">2</span>)</code></pre></div>
<p>Sometimes you may want to assign a number of properties to an existing object, for example using <code>Object.assign()</code> or <code>_.extend()</code>. However, new properties added to the object will not trigger changes. In such cases, create a fresh object with properties from both the original object and the mixin object:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// instead of `Object.assign(this.someObject, { a: 1, b: 2 })`</span>
<span class="kw">this</span>.<span class="at">someObject</span> <span class="op">=</span> <span class="va">Object</span>.<span class="at">assign</span>(<span class="op">{},</span> <span class="kw">this</span>.<span class="at">someObject</span><span class="op">,</span> <span class="op">{</span> <span class="dt">a</span><span class="op">:</span> <span class="dv">1</span><span class="op">,</span> <span class="dt">b</span><span class="op">:</span> <span class="dv">2</span> <span class="op">}</span>)</code></pre></div>
<h3 id="for-arrays">For Arrays</h3>
<p>Vue cannot detect the following changes to an array:</p>
<ol style="list-style-type: decimal">
<li>When you directly set an item with the index, e.g. <code>vm.items[indexOfItem] = newValue</code></li>
<li>When you modify the length of the array, e.g. <code>vm.items.length = newLength</code></li>
</ol>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> vm <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">items</span><span class="op">:</span> [<span class="st">&#39;a&#39;</span><span class="op">,</span> <span class="st">&#39;b&#39;</span><span class="op">,</span> <span class="st">&#39;c&#39;</span>]
  <span class="op">}</span>
<span class="op">}</span>)
<span class="va">vm</span>.<span class="at">items</span>[<span class="dv">1</span>] <span class="op">=</span> <span class="st">&#39;x&#39;</span> <span class="co">// is NOT reactive</span>
<span class="va">vm</span>.<span class="va">items</span>.<span class="at">length</span> <span class="op">=</span> <span class="dv">2</span> <span class="co">// is NOT reactive</span></code></pre></div>
<p>To overcome caveat 1, both of the following will accomplish the same as <code>vm.items[indexOfItem] = newValue</code>, but will also trigger state updates in the reactivity system:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// Vue.set</span>
<span class="va">Vue</span>.<span class="at">set</span>(<span class="va">vm</span>.<span class="at">items</span><span class="op">,</span> indexOfItem<span class="op">,</span> newValue)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// Array.prototype.splice</span>
<span class="va">vm</span>.<span class="va">items</span>.<span class="at">splice</span>(indexOfItem<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> newValue)</code></pre></div>
<p>You can also use the <a href="https://vuejs.org/v2/api/#vm-set"><code>vm.$set</code></a> instance method, which is an alias for the global <code>Vue.set</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">vm</span>.<span class="at">$set</span>(<span class="va">vm</span>.<span class="at">items</span><span class="op">,</span> indexOfItem<span class="op">,</span> newValue)</code></pre></div>
<p>To deal with caveat 2, you can use <code>splice</code>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">vm</span>.<span class="va">items</span>.<span class="at">splice</span>(newLength)</code></pre></div>
<h2 id="declaring-reactive-properties">Declaring Reactive Properties</h2>
<p>Since Vue doesn't allow dynamically adding root-level reactive properties, you have to initialize Vue instances by declaring all root-level reactive data properties upfront, even with an empty value:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> vm <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="co">// declare message with an empty value</span>
    <span class="dt">message</span><span class="op">:</span> <span class="st">&#39;&#39;</span>
  <span class="op">},</span>
  <span class="dt">template</span><span class="op">:</span> <span class="st">&#39;&lt;div&gt;{{ message }}&lt;/div&gt;&#39;</span>
<span class="op">}</span>)
<span class="co">// set `message` later</span>
<span class="va">vm</span>.<span class="at">message</span> <span class="op">=</span> <span class="st">&#39;Hello!&#39;</span></code></pre></div>
<p>If you don't declare <code>message</code> in the data option, Vue will warn you that the render function is trying to access a property that doesn't exist.</p>
<p>There are technical reasons behind this restriction - it eliminates a class of edge cases in the dependency tracking system, and also makes Vue instances play nicer with type checking systems. But there is also an important consideration in terms of code maintainability: the <code>data</code> object is like the schema for your component's state. Declaring all reactive properties upfront makes the component code easier to understand when revisited later or read by another developer.</p>
<h2 id="async-update-queue">Async Update Queue</h2>
<p>In case you haven't noticed yet, Vue performs DOM updates <strong>asynchronously</strong>. Whenever a data change is observed, it will open a queue and buffer all the data changes that happen in the same event loop. If the same watcher is triggered multiple times, it will be pushed into the queue only once. This buffered de-duplication is important in avoiding unnecessary calculations and DOM manipulations. Then, in the next event loop &quot;tick&quot;, Vue flushes the queue and performs the actual (already de-duped) work. Internally Vue tries native <code>Promise.then</code>, <code>MutationObserver</code>, and <code>setImmediate</code> for the asynchronous queuing and falls back to <code>setTimeout(fn, 0)</code>.</p>
<p>For example, when you set <code>vm.someData = 'new value'</code>, the component will not re-render immediately. It will update in the next &quot;tick&quot;, when the queue is flushed. Most of the time we don't need to care about this, but it can be tricky when you want to do something that depends on the post-update DOM state. Although Vue.js generally encourages developers to think in a &quot;data-driven&quot; fashion and avoid touching the DOM directly, sometimes it might be necessary to get your hands dirty. In order to wait until Vue.js has finished updating the DOM after a data change, you can use <code>Vue.nextTick(callback)</code> immediately after the data is changed. The callback will be called after the DOM has been updated. For example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;example&quot;</span><span class="kw">&gt;</span>{{ message }}<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> vm <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#example&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">message</span><span class="op">:</span> <span class="st">&#39;123&#39;</span>
  <span class="op">}</span>
<span class="op">}</span>)
<span class="va">vm</span>.<span class="at">message</span> <span class="op">=</span> <span class="st">&#39;new message&#39;</span> <span class="co">// change data</span>
<span class="va">vm</span>.<span class="va">$el</span>.<span class="at">textContent</span> <span class="op">===</span> <span class="st">&#39;new message&#39;</span> <span class="co">// false</span>
<span class="va">Vue</span>.<span class="at">nextTick</span>(<span class="kw">function</span> () <span class="op">{</span>
  <span class="va">vm</span>.<span class="va">$el</span>.<span class="at">textContent</span> <span class="op">===</span> <span class="st">&#39;new message&#39;</span> <span class="co">// true</span>
<span class="op">}</span>)</code></pre></div>
<p>There is also the <code>vm.$nextTick()</code> instance method, which is especially handy inside components, because it doesn't need global <code>Vue</code> and its callback's <code>this</code> context will be automatically bound to the current Vue instance:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">Vue</span>.<span class="at">component</span>(<span class="st">&#39;example&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">template</span><span class="op">:</span> <span class="st">&#39;&lt;span&gt;{{ message }}&lt;/span&gt;&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="cf">return</span> <span class="op">{</span>
      <span class="dt">message</span><span class="op">:</span> <span class="st">&#39;not updated&#39;</span>
    <span class="op">}</span>
  <span class="op">},</span>
  <span class="dt">methods</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">updateMessage</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="kw">this</span>.<span class="at">message</span> <span class="op">=</span> <span class="st">&#39;updated&#39;</span>
      <span class="va">console</span>.<span class="at">log</span>(<span class="kw">this</span>.<span class="va">$el</span>.<span class="at">textContent</span>) <span class="co">// =&gt; &#39;not updated&#39;</span>
      <span class="kw">this</span>.<span class="at">$nextTick</span>(<span class="kw">function</span> () <span class="op">{</span>
        <span class="va">console</span>.<span class="at">log</span>(<span class="kw">this</span>.<span class="va">$el</span>.<span class="at">textContent</span>) <span class="co">// =&gt; &#39;updated&#39;</span>
      <span class="op">}</span>)
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>Since <code>$nextTick()</code> returns a promise, you can achieve the same as the above using the new <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">ES2017 async/await</a> syntax:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">  methods<span class="op">:</span> <span class="op">{</span>
    <span class="dt">updateMessage</span><span class="op">:</span> async <span class="kw">function</span> () <span class="op">{</span>
      <span class="kw">this</span>.<span class="at">message</span> <span class="op">=</span> <span class="st">&#39;updated&#39;</span>
      <span class="va">console</span>.<span class="at">log</span>(<span class="kw">this</span>.<span class="va">$el</span>.<span class="at">textContent</span>) <span class="co">// =&gt; &#39;not updated&#39;</span>
      await <span class="kw">this</span>.<span class="at">$nextTick</span>()
      <span class="va">console</span>.<span class="at">log</span>(<span class="kw">this</span>.<span class="va">$el</span>.<span class="at">textContent</span>) <span class="co">// =&gt; &#39;updated&#39;</span>
    <span class="op">}</span>
  <span class="op">}</span></code></pre></div>
<h1 id="migration-from-vue-1.x"><a name=#guide/migration.md></a>Migration from Vue 1.x</h1>
<h2 id="faq">FAQ</h2>
<blockquote>
<p>Woah - this is a super long page! Does that mean 2.0 is completely different, I'll have to learn the basics all over again, and migrating will be practically impossible?</p>
</blockquote>
<p>I'm glad you asked! The answer is no. About 90% of the API is the same and the core concepts haven't changed. It's long because we like to offer very detailed explanations and include a lot of examples. Rest assured, <strong>this is not something you have to read from top to bottom!</strong></p>
<blockquote>
<p>Where should I start in a migration?</p>
</blockquote>
<ol style="list-style-type: decimal">
<li><p>Start by running the <a href="https://github.com/vuejs/vue-migration-helper">migration helper</a> on a current project. We've carefully minified and compressed a senior Vue dev into a simple command line interface. Whenever they recognize an obsolete feature, they'll let you know, offer suggestions, and provide links to more info.</p></li>
<li><p>After that, browse through the table of contents for this page in the sidebar. If you see a topic you may be affected by, but the migration helper didn't catch, check it out.</p></li>
<li><p>If you have any tests, run them and see what still fails. If you don't have tests, just open the app in your browser and keep an eye out for warnings or errors as you navigate around.</p></li>
<li><p>By now, your app should be fully migrated. If you're still hungry for more though, you can read the rest of this page - or dive in to the new and improved guide from <a href="index.html">the beginning</a>. Many parts will be skimmable, since you're already familiar with the core concepts.</p></li>
</ol>
<blockquote>
<p>How long will it take to migrate a Vue 1.x app to 2.0?</p>
</blockquote>
<p>It depends on a few factors:</p>
<ul>
<li><p>The size of your app (small to medium-sized apps will probably be less than a day)</p></li>
<li><p>How many times you get distracted and start playing with a cool new feature. 😉  Not judging, it also happened to us while building 2.0!</p></li>
<li><p>Which obsolete features you're using. Most can be upgraded with find-and-replace, but others might take a few minutes. If you're not currently following best practices, Vue 2.0 will also try harder to force you to. This is a good thing in the long run, but could also mean a significant (though possibly overdue) refactor.</p></li>
</ul>
<blockquote>
<p>If I upgrade to Vue 2, will I also have to upgrade Vuex and Vue Router?</p>
</blockquote>
<p>Only Vue Router 2 is compatible with Vue 2, so yes, you'll have to follow the <a href="migration-vue-router.html">migration path for Vue Router</a> as well. Fortunately, most applications don't have a lot of router code, so this likely won't take more than an hour.</p>
<p>As for Vuex, even version 0.8 is compatible with Vue 2, so you're not forced to upgrade. The only reason you may want to upgrade immediately is to take advantage of the new features in Vuex 2, such as modules and reduced boilerplate.</p>
<h2 id="templates">Templates</h2>
<h3 id="fragment-instances-removed">Fragment Instances <sup>removed</sup></h3>
<p>Every component must have exactly one root element. Fragment instances are no longer allowed. If you have a template like this:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;p&gt;</span>foo<span class="kw">&lt;/p&gt;</span>
<span class="kw">&lt;p&gt;</span>bar<span class="kw">&lt;/p&gt;</span></code></pre></div>
<p>It's recommended to wrap the entire contents in a new element, like this:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div&gt;</span>
  <span class="kw">&lt;p&gt;</span>foo<span class="kw">&lt;/p&gt;</span>
  <span class="kw">&lt;p&gt;</span>bar<span class="kw">&lt;/p&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<h2 id="lifecycle-hooks">Lifecycle Hooks</h2>
<h3 id="beforecompile-removed"><code>beforeCompile</code> <sup>removed</sup></h3>
<p>Use the <code>created</code> hook instead.</p>
<h3 id="compiled-replaced"><code>compiled</code> <sup>replaced</sup></h3>
<p>Use the new <code>mounted</code> hook instead.</p>
<h3 id="attached-removed"><code>attached</code> <sup>removed</sup></h3>
<p>Use a custom in-DOM check in other hooks. For example, to replace:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">attached<span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
  <span class="at">doSomething</span>()
<span class="op">}</span></code></pre></div>
<p>You could use:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">mounted<span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
  <span class="kw">this</span>.<span class="at">$nextTick</span>(<span class="kw">function</span> () <span class="op">{</span>
    <span class="at">doSomething</span>()
  <span class="op">}</span>)
<span class="op">}</span></code></pre></div>
<h3 id="detached-removed"><code>detached</code> <sup>removed</sup></h3>
<p>Use a custom in-DOM check in other hooks. For example, to replace:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">detached<span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
  <span class="at">doSomething</span>()
<span class="op">}</span></code></pre></div>
<p>You could use:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">destroyed<span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
  <span class="kw">this</span>.<span class="at">$nextTick</span>(<span class="kw">function</span> () <span class="op">{</span>
    <span class="at">doSomething</span>()
  <span class="op">}</span>)
<span class="op">}</span></code></pre></div>
<h3 id="init-renamed"><code>init</code> <sup>renamed</sup></h3>
<p>Use the new <code>beforeCreate</code> hook instead, which is essentially the same thing. It was renamed for consistency with other lifecycle methods.</p>
<h3 id="ready-replaced"><code>ready</code> <sup>replaced</sup></h3>
<p>Use the new <code>mounted</code> hook instead. It should be noted though that with <code>mounted</code>, there's no guarantee to be in-document. For that, also include <code>Vue.nextTick</code>/<code>vm.$nextTick</code>. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">mounted<span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
  <span class="kw">this</span>.<span class="at">$nextTick</span>(<span class="kw">function</span> () <span class="op">{</span>
    <span class="co">// code that assumes this.$el is in-document</span>
  <span class="op">}</span>)
<span class="op">}</span></code></pre></div>
<h2 id="v-for"><code>v-for</code></h2>
<h3 id="v-for-argument-order-for-arrays-changed"><code>v-for</code> Argument Order for Arrays <sup>changed</sup></h3>
<p>When including an <code>index</code>, the argument order for arrays used to be <code>(index, value)</code>. It is now <code>(value, index)</code> to be more consistent with JavaScript's native array methods such as <code>forEach</code> and <code>map</code>.</p>
<h3 id="v-for-argument-order-for-objects-changed"><code>v-for</code> Argument Order for Objects <sup>changed</sup></h3>
<p>When including a property name/key, the argument order for objects used to be <code>(name, value)</code>. It is now <code>(value, name)</code> to be more consistent with common object iterators such as lodash's.</p>
<h3 id="index-and-key-removed"><code>$index</code> and <code>$key</code> <sup>removed</sup></h3>
<p>The implicitly assigned <code>$index</code> and <code>$key</code> variables have been removed in favor of explicitly defining them in <code>v-for</code>. This makes the code easier to read for developers less experienced with Vue and also results in much clearer behavior when dealing with nested loops.</p>
<h3 id="track-by-replaced"><code>track-by</code> <sup>replaced</sup></h3>
<p><code>track-by</code> has been replaced with <code>key</code>, which works like any other attribute: without the <code>v-bind:</code> or <code>:</code> prefix, it is treated as a literal string. In most cases, you'd want to use a dynamic binding which expects a full expression instead of a key. For example, in place of:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> v-for=</span><span class="st">&quot;item in items&quot;</span><span class="ot"> track-by=</span><span class="st">&quot;id&quot;</span><span class="kw">&gt;</span></code></pre></div>
<p>You would now write:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> v-for=</span><span class="st">&quot;item in items&quot;</span><span class="ot"> v-bind:key=</span><span class="st">&quot;item.id&quot;</span><span class="kw">&gt;</span></code></pre></div>
<h3 id="v-for-range-values-changed"><code>v-for</code> Range Values <sup>changed</sup></h3>
<p>Previously, <code>v-for=&quot;number in 10&quot;</code> would have <code>number</code> starting at 0 and ending at 9. Now it starts at 1 and ends at 10.</p>
<h2 id="props-1">Props</h2>
<h3 id="coerce-prop-option-removed"><code>coerce</code> Prop Option <sup>removed</sup></h3>
<p>If you want to coerce a prop, setup a local computed value based on it instead. For example, instead of:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">props<span class="op">:</span> <span class="op">{</span>
  <span class="dt">username</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">type</span><span class="op">:</span> String<span class="op">,</span>
    <span class="dt">coerce</span><span class="op">:</span> <span class="kw">function</span> (value) <span class="op">{</span>
      <span class="cf">return</span> value
        .<span class="at">toLowerCase</span>()
        .<span class="at">replace</span>(<span class="ss">/</span><span class="sc">\s+</span><span class="ss">/</span><span class="op">,</span> <span class="st">&#39;-&#39;</span>)
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>You could write:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">props<span class="op">:</span> <span class="op">{</span>
  <span class="dt">username</span><span class="op">:</span> String<span class="op">,</span>
<span class="op">},</span>
computed<span class="op">:</span> <span class="op">{</span>
  <span class="dt">normalizedUsername</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="cf">return</span> <span class="kw">this</span>.<span class="at">username</span>
      .<span class="at">toLowerCase</span>()
      .<span class="at">replace</span>(<span class="ss">/</span><span class="sc">\s+</span><span class="ss">/</span><span class="op">,</span> <span class="st">&#39;-&#39;</span>)
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>There are a few advantages:</p>
<ul>
<li>You still have access to the original value of the prop.</li>
<li>You are forced to be more explicit, by giving your coerced value a name that differentiates it from the value passed in the prop.</li>
</ul>
<h3 id="twoway-prop-option-removed"><code>twoWay</code> Prop Option <sup>removed</sup></h3>
<p>Props are now always one-way down. To produce side effects in the parent scope, a component needs to explicitly emit an event instead of relying on implicit binding. For more information, see:</p>
<ul>
<li><a href="components.html#Custom-Events">Custom component events</a></li>
<li><a href="components.html#Form-Input-Components-using-Custom-Events">Custom input components</a> (using component events)</li>
<li><a href="state-management.html">Global state management</a></li>
</ul>
<h3 id="once-and-.sync-modifiers-on-v-bind-removed"><code>.once</code> and <code>.sync</code> Modifiers on <code>v-bind</code> <sup>removed</sup></h3>
<p>Props are now always one-way down. To produce side effects in the parent scope, a component needs to explicitly emit an event instead of relying on implicit binding. For more information, see:</p>
<ul>
<li><a href="components.html#Custom-Events">Custom component events</a></li>
<li><a href="components.html#Form-Input-Components-using-Custom-Events">Custom input components</a> (using component events)</li>
<li><a href="state-management.html">Global state management</a></li>
</ul>
<h3 id="prop-mutation-deprecated">Prop Mutation <sup>deprecated</sup></h3>
<p>Mutating a prop locally is now considered an anti-pattern, e.g. declaring a prop and then setting <code>this.myProp = 'someOtherValue'</code> in the component. Due to the new rendering mechanism, whenever the parent component re-renders, the child component's local changes will be overwritten.</p>
<p>Most use cases of mutating a prop can be replaced by one of these options:</p>
<ul>
<li>a data property, with the prop used to set its default value</li>
<li>a computed property</li>
</ul>
<h3 id="props-on-a-root-instance-replaced">Props on a Root Instance <sup>replaced</sup></h3>
<p>On root Vue instances (i.e. instances created with <code>new Vue({ ... })</code>), you must use <code>propsData</code> instead of <code>props</code>.</p>
<h2 id="computed-properties-1">Computed properties</h2>
<h3 id="cache-false-deprecated"><code>cache: false</code> <sup>deprecated</sup></h3>
<p>Caching invalidation of computed properties will be removed in future major versions of Vue. Replace any uncached computed properties with methods, which will have the same result.</p>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">template<span class="op">:</span> <span class="st">&#39;&lt;p&gt;message: {{ timeMessage }}&lt;/p&gt;&#39;</span><span class="op">,</span>
computed<span class="op">:</span> <span class="op">{</span>
  <span class="dt">timeMessage</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">cache</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span>
    <span class="dt">get</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="cf">return</span> <span class="va">Date</span>.<span class="at">now</span>() <span class="op">+</span> <span class="kw">this</span>.<span class="at">message</span>
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>Or with component methods:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">template<span class="op">:</span> <span class="st">&#39;&lt;p&gt;message: {{ getTimeMessage() }}&lt;/p&gt;&#39;</span><span class="op">,</span>
methods<span class="op">:</span> <span class="op">{</span>
  <span class="dt">getTimeMessage</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="cf">return</span> <span class="va">Date</span>.<span class="at">now</span>() <span class="op">+</span> <span class="kw">this</span>.<span class="at">message</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<h2 id="built-in-directives">Built-In Directives</h2>
<h3 id="truthinessfalsiness-with-v-bind-changed">Truthiness/Falsiness with <code>v-bind</code> <sup>changed</sup></h3>
<p>When used with <code>v-bind</code>, the only falsy values are now: <code>null</code>, <code>undefined</code>, and <code>false</code>. This means <code>0</code> and empty strings will render as truthy. So for example, <code>v-bind:draggable=&quot;''&quot;</code> will render as <code>draggable=&quot;true&quot;</code>.</p>
<p>For enumerated attributes, in addition to the falsy values above, the string <code>&quot;false&quot;</code> will also render as <code>attr=&quot;false&quot;</code>.</p>
<p class="tip">
Note that for other directives (e.g. <code>v-if</code> and <code>v-show</code>), JavaScript's normal truthiness still applies.
</p>
<h3 id="listening-for-native-events-on-components-with-v-on-changed">Listening for Native Events on Components with <code>v-on</code> <sup>changed</sup></h3>
<p>When used on a component, <code>v-on</code> now only listens to custom events <code>$emit</code>ted by that component. To listen for a native DOM event on the root element, you can use the <code>.native</code> modifier. For example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;my-component</span><span class="ot"> v-on:click.native=</span><span class="st">&quot;doSomething&quot;</span><span class="kw">&gt;&lt;/my-component&gt;</span></code></pre></div>
<h3 id="debounce-param-attribute-for-v-model-removed"><code>debounce</code> Param Attribute for <code>v-model</code> <sup>removed</sup></h3>
<p>Debouncing is used to limit how often we execute Ajax requests and other expensive operations. Vue's <code>debounce</code> attribute parameter for <code>v-model</code> made this easy for very simple cases, but it actually debounced <strong>state updates</strong> rather than the expensive operations themselves. It's a subtle difference, but it comes with limitations as an application grows.</p>
<p>These limitations become apparent when designing a search indicator, like this one for example:</p>
<p>Using the <code>debounce</code> attribute, there'd be no way to detect the &quot;Typing&quot; state, because we lose access to the input's real-time state. By decoupling the debounce function from Vue however, we're able to debounce only the operation we want to limit, removing the limits on features we can develop:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="co">&lt;!--</span>
<span class="co">By using the debounce function from lodash or another dedicated</span>
<span class="co">utility library, we know the specific debounce implementation we</span>
<span class="co">use will be best-in-class - and we can use it ANYWHERE. Not only</span>
<span class="co">in our template.</span>
<span class="co">--&gt;</span>
<span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;https://cdn.jsdelivr.net/lodash/4.13.1/lodash.js&quot;</span><span class="kw">&gt;&lt;/script&gt;</span>
<span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;debounce-search-demo&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;input</span><span class="ot"> v-model=</span><span class="st">&quot;searchQuery&quot;</span><span class="ot"> placeholder=</span><span class="st">&quot;Type something&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;strong&gt;</span>{{ searchIndicator }}<span class="kw">&lt;/strong&gt;</span>
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#debounce-search-demo&#39;</span><span class="op">,</span>
  <span class="dt">data</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">searchQuery</span><span class="op">:</span> <span class="st">&#39;&#39;</span><span class="op">,</span>
    <span class="dt">searchQueryIsDirty</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span>
    <span class="dt">isCalculating</span><span class="op">:</span> <span class="kw">false</span>
  <span class="op">},</span>
  <span class="dt">computed</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">searchIndicator</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="cf">if</span> (<span class="kw">this</span>.<span class="at">isCalculating</span>) <span class="op">{</span>
        <span class="cf">return</span> <span class="st">&#39;⟳ Fetching new results&#39;</span>
      <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (<span class="kw">this</span>.<span class="at">searchQueryIsDirty</span>) <span class="op">{</span>
        <span class="cf">return</span> <span class="st">&#39;... Typing&#39;</span>
      <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
        <span class="cf">return</span> <span class="st">&#39;✓ Done&#39;</span>
      <span class="op">}</span>
    <span class="op">}</span>
  <span class="op">},</span>
  <span class="dt">watch</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">searchQuery</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="kw">this</span>.<span class="at">searchQueryIsDirty</span> <span class="op">=</span> <span class="kw">true</span>
      <span class="kw">this</span>.<span class="at">expensiveOperation</span>()
    <span class="op">}</span>
  <span class="op">},</span>
  <span class="dt">methods</span><span class="op">:</span> <span class="op">{</span>
    <span class="co">// This is where the debounce actually belongs.</span>
    <span class="dt">expensiveOperation</span><span class="op">:</span> <span class="va">_</span>.<span class="at">debounce</span>(<span class="kw">function</span> () <span class="op">{</span>
      <span class="kw">this</span>.<span class="at">isCalculating</span> <span class="op">=</span> <span class="kw">true</span>
      <span class="at">setTimeout</span>(<span class="kw">function</span> () <span class="op">{</span>
        <span class="kw">this</span>.<span class="at">isCalculating</span> <span class="op">=</span> <span class="kw">false</span>
        <span class="kw">this</span>.<span class="at">searchQueryIsDirty</span> <span class="op">=</span> <span class="kw">false</span>
      <span class="op">}</span>.<span class="at">bind</span>(<span class="kw">this</span>)<span class="op">,</span> <span class="dv">1000</span>)
    <span class="op">},</span> <span class="dv">500</span>)
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>Another advantage of this approach is there will be times when debouncing isn't quite the right wrapper function. For example, when hitting an API for search suggestions, waiting to offer suggestions until after the user has stopped typing for a period of time isn't an ideal experience. What you probably want instead is a <strong>throttling</strong> function. Now since you're already using a utility library like lodash, refactoring to use its <code>throttle</code> function instead takes only a few seconds.</p>
<h3 id="lazy-or-number-param-attributes-for-v-model-replaced"><code>lazy</code> or <code>number</code> Param Attributes for <code>v-model</code> <sup>replaced</sup></h3>
<p>The <code>lazy</code> and <code>number</code> param attributes are now modifiers, to make it more clear what That means instead of:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;input</span><span class="ot"> v-model=</span><span class="st">&quot;name&quot;</span><span class="ot"> lazy</span><span class="kw">&gt;</span>
<span class="kw">&lt;input</span><span class="ot"> v-model=</span><span class="st">&quot;age&quot;</span><span class="ot"> type=</span><span class="st">&quot;number&quot;</span><span class="ot"> number</span><span class="kw">&gt;</span></code></pre></div>
<p>You would use:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;input</span><span class="ot"> v-model.lazy=</span><span class="st">&quot;name&quot;</span><span class="kw">&gt;</span>
<span class="kw">&lt;input</span><span class="ot"> v-model.number=</span><span class="st">&quot;age&quot;</span><span class="ot"> type=</span><span class="st">&quot;number&quot;</span><span class="kw">&gt;</span></code></pre></div>
<h3 id="value-attribute-with-v-model-removed"><code>value</code> Attribute with <code>v-model</code> <sup>removed</sup></h3>
<p><code>v-model</code> no longer cares about the initial value of an inline <code>value</code> attribute. For predictability, it will instead always treat the Vue instance data as the source of truth.</p>
<p>That means this element:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;input</span><span class="ot"> v-model=</span><span class="st">&quot;text&quot;</span><span class="ot"> value=</span><span class="st">&quot;foo&quot;</span><span class="kw">&gt;</span></code></pre></div>
<p>backed by this data:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">data<span class="op">:</span> <span class="op">{</span>
  <span class="dt">text</span><span class="op">:</span> <span class="st">&#39;bar&#39;</span>
<span class="op">}</span></code></pre></div>
<p>will render with a value of &quot;bar&quot; instead of &quot;foo&quot;. The same goes for a <code>&lt;textarea&gt;</code> with existing content. Instead of:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;textarea</span><span class="ot"> v-model=</span><span class="st">&quot;text&quot;</span><span class="kw">&gt;</span>
  hello world
<span class="kw">&lt;/textarea&gt;</span></code></pre></div>
<p>You should ensure your initial value for <code>text</code> is &quot;hello world&quot;.</p>
<h3 id="v-model-with-v-for-iterated-primitive-values-removed"><code>v-model</code> with <code>v-for</code> Iterated Primitive Values <sup>removed</sup></h3>
<p>Cases like this no longer work:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;input</span><span class="ot"> v-for=</span><span class="st">&quot;str in strings&quot;</span><span class="ot"> v-model=</span><span class="st">&quot;str&quot;</span><span class="kw">&gt;</span></code></pre></div>
<p>The reason is this is the equivalent JavaScript that the <code>&lt;input&gt;</code> would compile to:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">strings</span>.<span class="at">map</span>(<span class="kw">function</span> (str) <span class="op">{</span>
  <span class="cf">return</span> <span class="at">createElement</span>(<span class="st">&#39;input&#39;</span><span class="op">,</span> ...)
<span class="op">}</span>)</code></pre></div>
<p>As you can see, <code>v-model</code>'s two-way binding doesn't make sense here. Setting <code>str</code> to another value in the iterator function will do nothing because it's only a local variable in the function scope.</p>
<p>Instead, you should use an array of <strong>objects</strong> so that <code>v-model</code> can update the field on the object. For example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;input</span><span class="ot"> v-for=</span><span class="st">&quot;obj in objects&quot;</span><span class="ot"> v-model=</span><span class="st">&quot;obj.str&quot;</span><span class="kw">&gt;</span></code></pre></div>
<h3 id="v-bindstyle-with-object-syntax-and-important-removed"><code>v-bind:style</code> with Object Syntax and <code>!important</code> <sup>removed</sup></h3>
<p>This will no longer work:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;p</span><span class="ot"> v-bind:style=</span><span class="st">&quot;{ color: myColor + &#39; !important&#39; }&quot;</span><span class="kw">&gt;</span>hello<span class="kw">&lt;/p&gt;</span></code></pre></div>
<p>If you really need to override another <code>!important</code>, you must use the string syntax:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;p</span><span class="ot"> v-bind:style=</span><span class="st">&quot;&#39;color: &#39; + myColor + &#39; !important&#39;&quot;</span><span class="kw">&gt;</span>hello<span class="kw">&lt;/p&gt;</span></code></pre></div>
<h3 id="v-el-and-v-ref-replaced"><code>v-el</code> and <code>v-ref</code> <sup>replaced</sup></h3>
<p>For simplicity, <code>v-el</code> and <code>v-ref</code> have been merged into the <code>ref</code> attribute, accessible on a component instance via <code>$refs</code>. That means <code>v-el:my-element</code> would become <code>ref=&quot;myElement&quot;</code> and <code>v-ref:my-component</code> would become <code>ref=&quot;myComponent&quot;</code>. When used on a normal element, the <code>ref</code> will be the DOM element, and when used on a component, the <code>ref</code> will be the component instance.</p>
<p>Since <code>v-ref</code> is no longer a directive, but a special attribute, it can also be dynamically defined. This is especially useful in combination with <code>v-for</code>. For example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;p</span><span class="ot"> v-for=</span><span class="st">&quot;item in items&quot;</span><span class="ot"> v-bind:ref=</span><span class="st">&quot;&#39;item&#39; + item.id&quot;</span><span class="kw">&gt;&lt;/p&gt;</span></code></pre></div>
<p>Previously, <code>v-el</code>/<code>v-ref</code> combined with <code>v-for</code> would produce an array of elements/components, because there was no way to give each item a unique name. You can still achieve this behavior by giving each item the same <code>ref</code>:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;p</span><span class="ot"> v-for=</span><span class="st">&quot;item in items&quot;</span><span class="ot"> ref=</span><span class="st">&quot;items&quot;</span><span class="kw">&gt;&lt;/p&gt;</span></code></pre></div>
<p>Unlike in 1.x, these <code>$refs</code> are not reactive, because they're registered/updated during the render process itself. Making them reactive would require duplicate renders for every change.</p>
<p>On the other hand, <code>$refs</code> are designed primarily for programmatic access in JavaScript - it is not recommended to rely on them in templates, because that would mean referring to state that does not belong to the instance itself. This would violate Vue's data-driven view model.</p>
<h3 id="v-else-with-v-show-removed"><code>v-else</code> with <code>v-show</code> <sup>removed</sup></h3>
<p><code>v-else</code> no longer works with <code>v-show</code>. Use <code>v-if</code> with a negation expression instead. For example, instead of:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;p</span><span class="ot"> v-if=</span><span class="st">&quot;foo&quot;</span><span class="kw">&gt;</span>Foo<span class="kw">&lt;/p&gt;</span>
<span class="kw">&lt;p</span><span class="ot"> v-else v-show=</span><span class="st">&quot;bar&quot;</span><span class="kw">&gt;</span>Not foo, but bar<span class="kw">&lt;/p&gt;</span></code></pre></div>
<p>You can use:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;p</span><span class="ot"> v-if=</span><span class="st">&quot;foo&quot;</span><span class="kw">&gt;</span>Foo<span class="kw">&lt;/p&gt;</span>
<span class="kw">&lt;p</span><span class="ot"> v-if=</span><span class="st">&quot;!foo </span><span class="er">&amp;&amp;</span><span class="st"> bar&quot;</span><span class="kw">&gt;</span>Not foo, but bar<span class="kw">&lt;/p&gt;</span></code></pre></div>
<h2 id="custom-directives-simplified">Custom Directives <sup>simplified</sup></h2>
<p>Directives have a greatly reduced scope of responsibility: they are now only used for applying low-level direct DOM manipulations. In most cases, you should prefer using components as the main code-reuse abstraction.</p>
<p>Some of the most notable differences include:</p>
<ul>
<li>Directives no longer have instances. This means there's no more <code>this</code> inside directive hooks. Instead, they receive everything they might need as arguments. If you really must persist state across hooks, you can do so on <code>el</code>.</li>
<li>Options such as <code>acceptStatement</code>, <code>deep</code>, <code>priority</code>, etc have all been removed. To replace <code>twoWay</code> directives, see <a href="#Two-Way-Filters-replaced">this example</a>.</li>
<li>Some of the current hooks have different behavior and there are also a couple new hooks.</li>
</ul>
<p>Fortunately, since the new directives are much simpler, you can master them more easily. Read the new <a href="custom-directive.html">Custom Directives guide</a> to learn more.</p>
<h3 id="directive-.literal-modifier-removed">Directive <code>.literal</code> Modifier <sup>removed</sup></h3>
<p>The <code>.literal</code> modifier has been removed, as the same can be easily achieved by providing a string literal as the value.</p>
<p>For example, you can update:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;p</span><span class="ot"> v-my-directive.literal=</span><span class="st">&quot;foo bar baz&quot;</span><span class="kw">&gt;&lt;/p&gt;</span></code></pre></div>
<p>to:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;p</span><span class="ot"> v-my-directive=</span><span class="st">&quot;&#39;foo bar baz&#39;&quot;</span><span class="kw">&gt;&lt;/p&gt;</span></code></pre></div>
<h2 id="transitions">Transitions</h2>
<h3 id="transition-attribute-replaced"><code>transition</code> Attribute <sup>replaced</sup></h3>
<p>Vue's transition system has changed quite drastically and now uses <code>&lt;transition&gt;</code> and <code>&lt;transition-group&gt;</code> wrapper elements, rather than the <code>transition</code> attribute. It's recommended to read the new <a href="transitions.html">Transitions guide</a> to learn more.</p>
<h3 id="vue.transition-for-reusable-transitions-replaced"><code>Vue.transition</code> for Reusable Transitions <sup>replaced</sup></h3>
<p>With the new transition system, you can now <a href="transitions.html#Reusable-Transitions">use components for reusable transitions</a>.</p>
<h3 id="transition-stagger-attribute-removed">Transition <code>stagger</code> Attribute <sup>removed</sup></h3>
<p>If you need to stagger list transitions, you can control timing by setting and accessing a <code>data-index</code> (or similar attribute) on an element. See <a href="transitions.html#Staggering-List-Transitions">an example here</a>.</p>
<h2 id="events">Events</h2>
<h3 id="events-option-removed"><code>events</code> option <sup>removed</sup></h3>
<p>The <code>events</code> option has been removed. Event handlers should now be registered in the <code>created</code> hook instead. Check out the <a href="#dispatch-and-broadcast-replaced"><code>$dispatch</code> and <code>$broadcast</code> migration guide</a> for a detailed example.</p>
<h3 id="vue.directiveon.keycodes-replaced"><code>Vue.directive('on').keyCodes</code> <sup>replaced</sup></h3>
<p>The new, more concise way to configure <code>keyCodes</code> is through <code>Vue.config.keyCodes</code>. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// enable v-on:keyup.f1</span>
<span class="va">Vue</span>.<span class="va">config</span>.<span class="va">keyCodes</span>.<span class="at">f1</span> <span class="op">=</span> <span class="dv">112</span></code></pre></div>
<h3 id="dispatch-and-broadcast-replaced"><code>$dispatch</code> and <code>$broadcast</code> <sup>replaced</sup></h3>
<p><code>$dispatch</code> and <code>$broadcast</code> have been removed in favor of more explicitly cross-component communication and more maintainable state management solutions, such as <a href="https://github.com/vuejs/vuex">Vuex</a>.</p>
<p>The problem is event flows that depend on a component's tree structure can be hard to reason about and are very brittle when the tree becomes large. They don't scale well and only set you up for pain later. <code>$dispatch</code> and <code>$broadcast</code> also do not solve communication between sibling components.</p>
<p>One of the most common uses for these methods is to communicate between a parent and its direct children. In these cases, you can actually <a href="components.html#Form-Input-Components-using-Custom-Events">listen to an <code>$emit</code> from a child with <code>v-on</code></a>. This allows you to keep the convenience of events with added explicitness.</p>
<p>However, when communicating between distant descendants/ancestors, <code>$emit</code> won't help you. Instead, the simplest possible upgrade would be to use a centralized event hub. This has the added benefit of allowing you to communicate between components no matter where they are in the component tree - even between siblings! Because Vue instances implement an event emitter interface, you can actually use an empty Vue instance for this purpose.</p>
<p>For example, let's say we have a todo app structured like this:</p>
<pre><code>Todos
├─ NewTodoInput
└─ Todo
   └─ DeleteTodoButton</code></pre>
<p>We could manage communication between components with this single event hub:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// This is the event hub we&#39;ll use in every</span>
<span class="co">// component to communicate between them.</span>
<span class="kw">var</span> eventHub <span class="op">=</span> <span class="kw">new</span> <span class="at">Vue</span>()</code></pre></div>
<p>Then in our components, we can use <code>$emit</code>, <code>$on</code>, <code>$off</code> to emit events, listen for events, and clean up event listeners, respectively:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// NewTodoInput</span>
<span class="co">// ...</span>
methods<span class="op">:</span> <span class="op">{</span>
  <span class="dt">addTodo</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="va">eventHub</span>.<span class="at">$emit</span>(<span class="st">&#39;add-todo&#39;</span><span class="op">,</span> <span class="op">{</span> <span class="dt">text</span><span class="op">:</span> <span class="kw">this</span>.<span class="at">newTodoText</span> <span class="op">}</span>)
    <span class="kw">this</span>.<span class="at">newTodoText</span> <span class="op">=</span> <span class="st">&#39;&#39;</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// DeleteTodoButton</span>
<span class="co">// ...</span>
methods<span class="op">:</span> <span class="op">{</span>
  <span class="dt">deleteTodo</span><span class="op">:</span> <span class="kw">function</span> (id) <span class="op">{</span>
    <span class="va">eventHub</span>.<span class="at">$emit</span>(<span class="st">&#39;delete-todo&#39;</span><span class="op">,</span> id)
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// Todos</span>
<span class="co">// ...</span>
created<span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
  <span class="va">eventHub</span>.<span class="at">$on</span>(<span class="st">&#39;add-todo&#39;</span><span class="op">,</span> <span class="kw">this</span>.<span class="at">addTodo</span>)
  <span class="va">eventHub</span>.<span class="at">$on</span>(<span class="st">&#39;delete-todo&#39;</span><span class="op">,</span> <span class="kw">this</span>.<span class="at">deleteTodo</span>)
<span class="op">},</span>
<span class="co">// It&#39;s good to clean up event listeners before</span>
<span class="co">// a component is destroyed.</span>
beforeDestroy<span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
  <span class="va">eventHub</span>.<span class="at">$off</span>(<span class="st">&#39;add-todo&#39;</span><span class="op">,</span> <span class="kw">this</span>.<span class="at">addTodo</span>)
  <span class="va">eventHub</span>.<span class="at">$off</span>(<span class="st">&#39;delete-todo&#39;</span><span class="op">,</span> <span class="kw">this</span>.<span class="at">deleteTodo</span>)
<span class="op">},</span>
methods<span class="op">:</span> <span class="op">{</span>
  <span class="dt">addTodo</span><span class="op">:</span> <span class="kw">function</span> (newTodo) <span class="op">{</span>
    <span class="kw">this</span>.<span class="va">todos</span>.<span class="at">push</span>(newTodo)
  <span class="op">},</span>
  <span class="dt">deleteTodo</span><span class="op">:</span> <span class="kw">function</span> (todoId) <span class="op">{</span>
    <span class="kw">this</span>.<span class="at">todos</span> <span class="op">=</span> <span class="kw">this</span>.<span class="va">todos</span>.<span class="at">filter</span>(<span class="kw">function</span> (todo) <span class="op">{</span>
      <span class="cf">return</span> <span class="va">todo</span>.<span class="at">id</span> <span class="op">!==</span> todoId
    <span class="op">}</span>)
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>This pattern can serve as a replacement for <code>$dispatch</code> and <code>$broadcast</code> in simple scenarios, but for more complex cases, it's recommended to use a dedicated state management layer such as <a href="https://github.com/vuejs/vuex">Vuex</a>.</p>
<h2 id="filters-1">Filters</h2>
<h3 id="filters-outside-text-interpolations-removed">Filters Outside Text Interpolations <sup>removed</sup></h3>
<p>Filters can now only be used inside text interpolations (<code>{% raw %}{{ }}{% endraw %}</code> tags). In the past we've found using filters within directives such as <code>v-model</code>, <code>v-on</code>, etc led to more complexity than convenience. For list filtering on <code>v-for</code>, it's also better to move that logic into JavaScript as computed properties, so that it can be reused throughout your component.</p>
<p>In general, whenever something can be achieved in plain JavaScript, we want to avoid introducing a special syntax like filters to take care of the same concern. Here's how you can replace Vue's built-in directive filters:</p>
<h4 id="replacing-the-debounce-filter">Replacing the <code>debounce</code> Filter</h4>
<p>Instead of:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;input</span><span class="ot"> v-on:keyup=</span><span class="st">&quot;doStuff | debounce 500&quot;</span><span class="kw">&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">methods<span class="op">:</span> <span class="op">{</span>
  <span class="dt">doStuff</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="co">// ...</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>Use <a href="https://lodash.com/docs/4.15.0#debounce">lodash's <code>debounce</code></a> (or possibly <a href="https://lodash.com/docs/4.15.0#throttle"><code>throttle</code></a>) to directly limit calling the expensive method. You can achieve the same as above like this:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;input</span><span class="ot"> v-on:keyup=</span><span class="st">&quot;doStuff&quot;</span><span class="kw">&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">methods<span class="op">:</span> <span class="op">{</span>
  <span class="dt">doStuff</span><span class="op">:</span> <span class="va">_</span>.<span class="at">debounce</span>(<span class="kw">function</span> () <span class="op">{</span>
    <span class="co">// ...</span>
  <span class="op">},</span> <span class="dv">500</span>)
<span class="op">}</span></code></pre></div>
<p>For more on the advantages of this strategy, see <a href="#debounce-Param-Attribute-for-v-model-removed">the example here with <code>v-model</code></a>.</p>
<h4 id="replacing-the-limitby-filter">Replacing the <code>limitBy</code> Filter</h4>
<p>Instead of:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;p</span><span class="ot"> v-for=</span><span class="st">&quot;item in items | limitBy 10&quot;</span><span class="kw">&gt;</span>{{ item }}<span class="kw">&lt;/p&gt;</span></code></pre></div>
<p>Use JavaScript's built-in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Examples"><code>.slice</code> method</a> in a computed property:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;p</span><span class="ot"> v-for=</span><span class="st">&quot;item in filteredItems&quot;</span><span class="kw">&gt;</span>{{ item }}<span class="kw">&lt;/p&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">computed<span class="op">:</span> <span class="op">{</span>
  <span class="dt">filteredItems</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="cf">return</span> <span class="kw">this</span>.<span class="va">items</span>.<span class="at">slice</span>(<span class="dv">0</span><span class="op">,</span> <span class="dv">10</span>)
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<h4 id="replacing-the-filterby-filter">Replacing the <code>filterBy</code> Filter</h4>
<p>Instead of:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;p</span><span class="ot"> v-for=</span><span class="st">&quot;user in users | filterBy searchQuery in &#39;name&#39;&quot;</span><span class="kw">&gt;</span>{{ user.name }}<span class="kw">&lt;/p&gt;</span></code></pre></div>
<p>Use JavaScript's built-in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Examples"><code>.filter</code> method</a> in a computed property:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;p</span><span class="ot"> v-for=</span><span class="st">&quot;user in filteredUsers&quot;</span><span class="kw">&gt;</span>{{ user.name }}<span class="kw">&lt;/p&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">computed<span class="op">:</span> <span class="op">{</span>
  <span class="dt">filteredUsers</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="kw">var</span> self <span class="op">=</span> <span class="kw">this</span>
    <span class="cf">return</span> <span class="va">self</span>.<span class="va">users</span>.<span class="at">filter</span>(<span class="kw">function</span> (user) <span class="op">{</span>
      <span class="cf">return</span> <span class="va">user</span>.<span class="va">name</span>.<span class="at">indexOf</span>(<span class="va">self</span>.<span class="at">searchQuery</span>) <span class="op">!==</span> <span class="dv">-1</span>
    <span class="op">}</span>)
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>JavaScript's native <code>.filter</code> can also manage much more complex filtering operations, because you have access to the full power of JavaScript within computed properties. For example, if you wanted to find all active users and case-insensitively match against both their name and email:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> self <span class="op">=</span> <span class="kw">this</span>
<span class="va">self</span>.<span class="va">users</span>.<span class="at">filter</span>(<span class="kw">function</span> (user) <span class="op">{</span>
  <span class="kw">var</span> searchRegex <span class="op">=</span> <span class="kw">new</span> <span class="at">RegExp</span>(<span class="va">self</span>.<span class="at">searchQuery</span><span class="op">,</span> <span class="st">&#39;i&#39;</span>)
  <span class="cf">return</span> <span class="va">user</span>.<span class="at">isActive</span> <span class="op">&amp;&amp;</span> (
    <span class="va">searchRegex</span>.<span class="at">test</span>(<span class="va">user</span>.<span class="at">name</span>) <span class="op">||</span>
    <span class="va">searchRegex</span>.<span class="at">test</span>(<span class="va">user</span>.<span class="at">email</span>)
  )
<span class="op">}</span>)</code></pre></div>
<h4 id="replacing-the-orderby-filter">Replacing the <code>orderBy</code> Filter</h4>
<p>Instead of:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;p</span><span class="ot"> v-for=</span><span class="st">&quot;user in users | orderBy &#39;name&#39;&quot;</span><span class="kw">&gt;</span>{{ user.name }}<span class="kw">&lt;/p&gt;</span></code></pre></div>
<p>Use <a href="https://lodash.com/docs/4.15.0#orderBy">lodash's <code>orderBy</code></a> (or possibly <a href="https://lodash.com/docs/4.15.0#sortBy"><code>sortBy</code></a>) in a computed property:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;p</span><span class="ot"> v-for=</span><span class="st">&quot;user in orderedUsers&quot;</span><span class="kw">&gt;</span>{{ user.name }}<span class="kw">&lt;/p&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">computed<span class="op">:</span> <span class="op">{</span>
  <span class="dt">orderedUsers</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="cf">return</span> <span class="va">_</span>.<span class="at">orderBy</span>(<span class="kw">this</span>.<span class="at">users</span><span class="op">,</span> <span class="st">&#39;name&#39;</span>)
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>You can even order by multiple columns:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">_</span>.<span class="at">orderBy</span>(<span class="kw">this</span>.<span class="at">users</span><span class="op">,</span> [<span class="st">&#39;name&#39;</span><span class="op">,</span> <span class="st">&#39;last_login&#39;</span>]<span class="op">,</span> [<span class="st">&#39;asc&#39;</span><span class="op">,</span> <span class="st">&#39;desc&#39;</span>])</code></pre></div>
<h3 id="filter-argument-syntax-changed">Filter Argument Syntax <sup>changed</sup></h3>
<p>Filters' syntax for arguments now better aligns with JavaScript function invocation. So instead of taking space-delimited arguments:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;p&gt;</span>{{ date | formatDate &#39;YY-MM-DD&#39; timeZone }}<span class="kw">&lt;/p&gt;</span></code></pre></div>
<p>We surround the arguments with parentheses and delimit the arguments with commas:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;p&gt;</span>{{ date | formatDate(&#39;YY-MM-DD&#39;, timeZone) }}<span class="kw">&lt;/p&gt;</span></code></pre></div>
<h3 id="built-in-text-filters-removed">Built-In Text Filters <sup>removed</sup></h3>
<p>Although filters within text interpolations are still allowed, all of the filters have been removed. Instead, it's recommended to use more specialized libraries for solving problems in each domain (e.g. <a href="https://date-fns.org/"><code>date-fns</code></a> to format dates and <a href="http://openexchangerates.github.io/accounting.js/"><code>accounting</code></a> for currencies).</p>
<p>For each of Vue's built-in text filters, we go through how you can replace them below. The example code could exist in custom helper functions, methods, or computed properties.</p>
<h4 id="replacing-the-json-filter">Replacing the <code>json</code> Filter</h4>
<p>You actually don't need to for debugging anymore, as Vue will nicely format output for you automatically, whether it's a string, number, array, or plain object. If you want the exact same functionality as JavaScript's <code>JSON.stringify</code> though, then you can use that in a method or computed property.</p>
<h4 id="replacing-the-capitalize-filter">Replacing the <code>capitalize</code> Filter</h4>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">text[<span class="dv">0</span>].<span class="at">toUpperCase</span>() <span class="op">+</span> <span class="va">text</span>.<span class="at">slice</span>(<span class="dv">1</span>)</code></pre></div>
<h4 id="replacing-the-uppercase-filter">Replacing the <code>uppercase</code> Filter</h4>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">text</span>.<span class="at">toUpperCase</span>()</code></pre></div>
<h4 id="replacing-the-lowercase-filter">Replacing the <code>lowercase</code> Filter</h4>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">text</span>.<span class="at">toLowerCase</span>()</code></pre></div>
<h4 id="replacing-the-pluralize-filter">Replacing the <code>pluralize</code> Filter</h4>
<p>The <a href="https://www.npmjs.com/package/pluralize">pluralize</a> package on NPM serves this purpose nicely, but if you only want to pluralize a specific word or want to have special output for cases like <code>0</code>, then you can also easily define your own pluralize functions. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">pluralizeKnife</span> (count) <span class="op">{</span>
  <span class="cf">if</span> (count <span class="op">===</span> <span class="dv">0</span>) <span class="op">{</span>
    <span class="cf">return</span> <span class="st">&#39;no knives&#39;</span>
  <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (count <span class="op">===</span> <span class="dv">1</span>) <span class="op">{</span>
    <span class="cf">return</span> <span class="st">&#39;1 knife&#39;</span>
  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
    <span class="cf">return</span> count <span class="op">+</span> <span class="st">&#39;knives&#39;</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<h4 id="replacing-the-currency-filter">Replacing the <code>currency</code> Filter</h4>
<p>For a very naive implementation, you could do something like this:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="st">&#39;$&#39;</span> <span class="op">+</span> <span class="va">price</span>.<span class="at">toFixed</span>(<span class="dv">2</span>)</code></pre></div>
<p>In many cases though, you'll still run into strange behavior (e.g. <code>0.035.toFixed(2)</code> rounds up to <code>0.04</code>, but <code>0.045</code> rounds down to <code>0.04</code>). To work around these issues, you can use the <a href="http://openexchangerates.github.io/accounting.js/"><code>accounting</code></a> library to more reliably format currencies.</p>
<h3 id="two-way-filters-replaced">Two-Way Filters <sup>replaced</sup></h3>
<p>Some users have enjoyed using two-way filters with <code>v-model</code> to create interesting inputs with very little code. While <em>seemingly</em> simple however, two-way filters can also hide a great deal of complexity - and even encourage poor UX by delaying state updates. Instead, components wrapping an input are recommended as a more explicit and feature-rich way of creating custom inputs.</p>
<p>As an example, we'll now walk the migration of a two-way currency filter:</p>
<iframe src="https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-10-two-way-currency-filter?codemirror=1&amp;hidedevtools=1&amp;hidenavigation=1&amp;theme=light" style="width:100%; height:300px; border:0; border-radius: 4px; overflow:hidden;" title="vue-20-template-compilation" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>It mostly works well, but the delayed state updates can cause strange behavior. For example, try entering <code>9.999</code> into one of those inputs. When the input loses focus, its value will update to <code>$10.00</code>. When looking at the calculated total however, you'll see that <code>9.999</code> is what's stored in our data. The version of reality that the user sees is out of sync!</p>
<p>To start transitioning towards a more robust solution using Vue 2.0, let's first wrap this filter in a new <code>&lt;currency-input&gt;</code> component:</p>
<iframe src="https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-10-two-way-currency-filter-v2?codemirror=1&amp;hidedevtools=1&amp;hidenavigation=1&amp;theme=light" style="width:100%; height:300px; border:0; border-radius: 4px; overflow:hidden;" title="vue-20-template-compilation" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>This allows us add behavior that a filter alone couldn't encapsulate, such as selecting the content of an input on focus. Now the next step will be to extract the business logic from the filter. Below, we pull everything out into an external <a href="https://gist.github.com/chrisvfritz/5f0a639590d6e648933416f90ba7ae4e"><code>currencyValidator</code> object</a>:</p>
<iframe src="https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-10-two-way-currency-filter-v3?codemirror=1&amp;hidedevtools=1&amp;hidenavigation=1&amp;theme=light" style="width:100%; height:300px; border:0; border-radius: 4px; overflow:hidden;" title="vue-20-template-compilation" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>This increased modularity not only makes it easier to migrate to Vue 2, but also allows currency parsing and formatting to be:</p>
<ul>
<li>unit tested in isolation from your Vue code</li>
<li>used by other parts of your application, such as to validate the payload to an API endpoint</li>
</ul>
<p>Having this validator extracted out, we've also more comfortably built it up into a more robust solution. The state quirks have been eliminated and it's actually impossible for users to enter anything wrong, similar to what the browser's native number input tries to do.</p>
<p>We're still limited however, by filters and by Vue 1.0 in general, so let's complete the upgrade to Vue 2.0:</p>
<iframe src="https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-two-way-currency-filter?codemirror=1&amp;hidedevtools=1&amp;hidenavigation=1&amp;theme=light" style="width:100%; height:300px; border:0; border-radius: 4px; overflow:hidden;" title="vue-20-template-compilation" allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin">
</iframe>
<p>You may notice that:</p>
<ul>
<li>Every aspect of our input is more explicit, using lifecycle hooks and DOM events in place of the hidden behavior of two-way filters.</li>
<li>We can now use <code>v-model</code> directly on our custom inputs, which is not only more consistent with normal inputs, but also means our component is Vuex-friendly.</li>
<li>Since we're no longer using filter options that require a value to be returned, our currency work could actually be done asynchronously. That means if we had a lot of apps that had to work with currencies, we could easily refactor this logic into a shared microservice.</li>
</ul>
<h2 id="slots-2">Slots</h2>
<h3 id="duplicate-slots-removed">Duplicate Slots <sup>removed</sup></h3>
<p>It is no longer supported to have <code>&lt;slot&gt;</code>s with the same name in the same template. When a slot is rendered it is &quot;used up&quot; and cannot be rendered elsewhere in the same render tree. If you must render the same content in multiple places, pass that content as a prop.</p>
<h3 id="slot-attribute-styling-removed"><code>slot</code> Attribute Styling <sup>removed</sup></h3>
<p>Content inserted via named <code>&lt;slot&gt;</code> no longer preserves the <code>slot</code> attribute. Use a wrapper element to style them, or for advanced use cases, modify the inserted content programmatically using <a href="render-function.html">render functions</a>.</p>
<h2 id="special-attributes">Special Attributes</h2>
<h3 id="keep-alive-attribute-replaced"><code>keep-alive</code> Attribute <sup>replaced</sup></h3>
<p><code>keep-alive</code> is no longer a special attribute, but rather a wrapper component, similar to <code>&lt;transition&gt;</code>. For example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;keep-alive&gt;</span>
  <span class="kw">&lt;component</span><span class="ot"> v-bind:is=</span><span class="st">&quot;view&quot;</span><span class="kw">&gt;&lt;/component&gt;</span>
<span class="kw">&lt;/keep-alive&gt;</span></code></pre></div>
<p>This makes it possible to use <code>&lt;keep-alive&gt;</code> on multiple conditional children:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;keep-alive&gt;</span>
  <span class="kw">&lt;todo-list</span><span class="ot"> v-if=</span><span class="st">&quot;todos.length &gt; 0&quot;</span><span class="kw">&gt;&lt;/todo-list&gt;</span>
  <span class="kw">&lt;no-todos-gif</span><span class="ot"> v-else</span><span class="kw">&gt;&lt;/no-todos-gif&gt;</span>
<span class="kw">&lt;/keep-alive&gt;</span></code></pre></div>
<p class="tip">
When <code>&lt;keep-alive&gt;</code> has multiple children, they should eventually evaluate to a single child. Any child other than the first one will be ignored.
</p>
<p>When used together with <code>&lt;transition&gt;</code>, make sure to nest it inside:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;transition&gt;</span>
  <span class="kw">&lt;keep-alive&gt;</span>
    <span class="kw">&lt;component</span><span class="ot"> v-bind:is=</span><span class="st">&quot;view&quot;</span><span class="kw">&gt;&lt;/component&gt;</span>
  <span class="kw">&lt;/keep-alive&gt;</span>
<span class="kw">&lt;/transition&gt;</span></code></pre></div>
<h2 id="interpolation">Interpolation</h2>
<h3 id="interpolation-within-attributes-removed">Interpolation within Attributes <sup>removed</sup></h3>
<p>Interpolation within attributes is no longer valid. For example:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;button</span><span class="ot"> class=</span><span class="st">&quot;btn btn-{{ size }}&quot;</span><span class="kw">&gt;&lt;/button&gt;</span></code></pre></div>
<p>Should either be updated to use an inline expression:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;button</span><span class="ot"> v-bind:class=</span><span class="st">&quot;&#39;btn btn-&#39; + size&quot;</span><span class="kw">&gt;&lt;/button&gt;</span></code></pre></div>
<p>Or a data/computed property:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;button</span><span class="ot"> v-bind:class=</span><span class="st">&quot;buttonClasses&quot;</span><span class="kw">&gt;&lt;/button&gt;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">computed<span class="op">:</span> <span class="op">{</span>
  <span class="dt">buttonClasses</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="cf">return</span> <span class="st">&#39;btn btn-&#39;</span> <span class="op">+</span> size
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<h3 id="html-interpolation-removed">HTML Interpolation <sup>removed</sup></h3>
<p>HTML interpolations (<code>{% raw %}{{{ foo }}}{% endraw %}</code>) have been removed in favor of the <a href="../api/#v-html"><code>v-html</code> directive</a>.</p>
<h3 id="one-time-bindings-replaced">One-Time Bindings <sup>replaced</sup></h3>
<p>One time bindings (<code>{% raw %}{{* foo }}{% endraw %}</code>) have been replaced by the new <a href="../api/#v-once"><code>v-once</code> directive</a>.</p>
<h2 id="reactivity">Reactivity</h2>
<h3 id="vm.watch-changed"><code>vm.$watch</code> <sup>changed</sup></h3>
<p>Watchers created via <code>vm.$watch</code> are now fired before the associated component rerenders. This gives you the chance to further update state before the component rerender, thus avoiding unnecessary updates. For example, you can watch a component prop and update the component's own data when the prop changes.</p>
<p>If you were previously relying on <code>vm.$watch</code> to do something with the DOM after a component updates, you can instead do so in the <code>updated</code> lifecycle hook.</p>
<h3 id="vm.set-changed"><code>vm.$set</code> <sup>changed</sup></h3>
<p><code>vm.$set</code> is now an alias for <a href="../api/#Vue-set"><code>Vue.set</code></a>.</p>
<h3 id="vm.delete-changed"><code>vm.$delete</code> <sup>changed</sup></h3>
<p><code>vm.$delete</code> is now an alias for <a href="../api/#Vue-delete"><code>Vue.delete</code></a>.</p>
<h3 id="array.prototype.set-removed"><code>Array.prototype.$set</code> <sup>removed</sup></h3>
<p>Use <code>Vue.set</code> instead.</p>
<h3 id="array.prototype.remove-removed"><code>Array.prototype.$remove</code> <sup>removed</sup></h3>
<p>Use <code>Array.prototype.splice</code> instead. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">methods<span class="op">:</span> <span class="op">{</span>
  <span class="dt">removeTodo</span><span class="op">:</span> <span class="kw">function</span> (todo) <span class="op">{</span>
    <span class="kw">var</span> index <span class="op">=</span> <span class="kw">this</span>.<span class="va">todos</span>.<span class="at">indexOf</span>(todo)
    <span class="kw">this</span>.<span class="va">todos</span>.<span class="at">splice</span>(index<span class="op">,</span> <span class="dv">1</span>)
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>Or better yet, pass removal methods an index:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">methods<span class="op">:</span> <span class="op">{</span>
  <span class="dt">removeTodo</span><span class="op">:</span> <span class="kw">function</span> (index) <span class="op">{</span>
    <span class="kw">this</span>.<span class="va">todos</span>.<span class="at">splice</span>(index<span class="op">,</span> <span class="dv">1</span>)
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<h3 id="vue.set-and-vue.delete-on-vue-instances-removed"><code>Vue.set</code> and <code>Vue.delete</code> on Vue instances <sup>removed</sup></h3>
<p><code>Vue.set</code> and <code>Vue.delete</code> can no longer work on Vue instances. It is now mandatory to properly declare all top-level reactive properties in the data option. If you'd like to delete properties on a Vue instance or its <code>$data</code>, set it to null.</p>
<h3 id="replacing-vm.data-removed">Replacing <code>vm.$data</code> <sup>removed</sup></h3>
<p>It is now prohibited to replace a component instance's root $data. This prevents some edge cases in the reactivity system and makes the component state more predictable (especially with type-checking systems).</p>
<h3 id="vm.get-removed"><code>vm.$get</code> <sup>removed</sup></h3>
<p>Instead, retrieve reactive data directly.</p>
<h2 id="dom-focused-instance-methods">DOM-Focused Instance Methods</h2>
<h3 id="vm.appendto-removed"><code>vm.$appendTo</code> <sup>removed</sup></h3>
<p>Use the native DOM API:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">myElement</span>.<span class="at">appendChild</span>(<span class="va">vm</span>.<span class="at">$el</span>)</code></pre></div>
<h3 id="vm.before-removed"><code>vm.$before</code> <sup>removed</sup></h3>
<p>Use the native DOM API:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">myElement</span>.<span class="va">parentNode</span>.<span class="at">insertBefore</span>(<span class="va">vm</span>.<span class="at">$el</span><span class="op">,</span> myElement)</code></pre></div>
<h3 id="vm.after-removed"><code>vm.$after</code> <sup>removed</sup></h3>
<p>Use the native DOM API:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">myElement</span>.<span class="va">parentNode</span>.<span class="at">insertBefore</span>(<span class="va">vm</span>.<span class="at">$el</span><span class="op">,</span> <span class="va">myElement</span>.<span class="at">nextSibling</span>)</code></pre></div>
<p>Or if <code>myElement</code> is the last child:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">myElement</span>.<span class="va">parentNode</span>.<span class="at">appendChild</span>(<span class="va">vm</span>.<span class="at">$el</span>)</code></pre></div>
<h3 id="vm.remove-removed"><code>vm.$remove</code> <sup>removed</sup></h3>
<p>Use the native DOM API:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">vm</span>.<span class="va">$el</span>.<span class="at">remove</span>()</code></pre></div>
<h2 id="meta-instance-methods">Meta Instance Methods</h2>
<h3 id="vm.eval-removed"><code>vm.$eval</code> <sup>removed</sup></h3>
<p>No real use. If you do happen to rely on this feature somehow and aren't sure how to work around it, post on <a href="https://forum.vuejs.org/">the forum</a> for ideas.</p>
<h3 id="vm.interpolate-removed"><code>vm.$interpolate</code> <sup>removed</sup></h3>
<p>No real use. If you do happen to rely on this feature somehow and aren't sure how to work around it, post on <a href="https://forum.vuejs.org/">the forum</a> for ideas.</p>
<h3 id="vm.log-removed"><code>vm.$log</code> <sup>removed</sup></h3>
<p>Use the <a href="https://github.com/vuejs/vue-devtools">Vue Devtools</a> for the optimal debugging experience.</p>
<h2 id="instance-dom-options">Instance DOM Options</h2>
<h3 id="replace-false-removed"><code>replace: false</code> <sup>removed</sup></h3>
<p>Components now always replace the element they're bound to. To simulate the behavior of <code>replace: false</code>, you can wrap your root component with an element similar to the one you're replacing. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#app&#39;</span><span class="op">,</span>
  <span class="dt">template</span><span class="op">:</span> <span class="st">&#39;&lt;div id=&quot;app&quot;&gt; ... &lt;/div&gt;&#39;</span>
<span class="op">}</span>)</code></pre></div>
<p>Or with a render function:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#app&#39;</span><span class="op">,</span>
  <span class="dt">render</span><span class="op">:</span> <span class="kw">function</span> (h) <span class="op">{</span>
    <span class="at">h</span>(<span class="st">&#39;div&#39;</span><span class="op">,</span> <span class="op">{</span>
      <span class="dt">attrs</span><span class="op">:</span> <span class="op">{</span>
        <span class="dt">id</span><span class="op">:</span> <span class="st">&#39;app&#39;</span><span class="op">,</span>
      <span class="op">}</span>
    <span class="op">},</span> <span class="co">/* ... */</span>)
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<h2 id="global-config">Global Config</h2>
<h3 id="vue.config.debug-removed"><code>Vue.config.debug</code> <sup>removed</sup></h3>
<p>No longer necessary, since warnings come with stack traces by default now.</p>
<h3 id="vue.config.async-removed"><code>Vue.config.async</code> <sup>removed</sup></h3>
<p>Async is now required for rendering performance.</p>
<h3 id="vue.config.delimiters-replaced"><code>Vue.config.delimiters</code> <sup>replaced</sup></h3>
<p>This has been reworked as a <a href="../api/#delimiters">component-level option</a>. This allows you to use alternative delimiters within your app without breaking 3rd-party components.</p>
<h3 id="vue.config.unsafedelimiters-removed"><code>Vue.config.unsafeDelimiters</code> <sup>removed</sup></h3>
<p>HTML interpolation has been <a href="#HTML-Interpolation-removed">removed in favor of <code>v-html</code></a>.</p>
<h2 id="global-api">Global API</h2>
<h3 id="vue.extend-with-el-removed"><code>Vue.extend</code> with <code>el</code> <sup>removed</sup></h3>
<p>The el option can no longer be used in <code>Vue.extend</code>. It's only valid as an instance creation option.</p>
<h3 id="vue.elementdirective-removed"><code>Vue.elementDirective</code> <sup>removed</sup></h3>
<p>Use components instead.</p>
<h3 id="vue.partial-removed"><code>Vue.partial</code> <sup>removed</sup></h3>
<p>Partials have been removed in favor of more explicit data flow between components, using props. Unless you're using a partial in a performance-critical area, the recommendation is to use a <a href="components.html">normal component</a> instead. If you were dynamically binding the <code>name</code> of a partial, you can use a <a href="components.html#Dynamic-Components">dynamic component</a>.</p>
<p>If you happen to be using partials in a performance-critical part of your app, then you should upgrade to <a href="render-function.html#Functional-Components">functional components</a>. They must be in a plain JS/JSX file (rather than in a <code>.vue</code> file) and are stateless and instanceless, like partials. This makes rendering extremely fast.</p>
<p>A benefit of functional components over partials is that they can be much more dynamic, because they grant you access to the full power of JavaScript. There is a cost to this power however. If you've never used a component framework with render functions before, they may take a bit longer to learn.</p>
<h1 id="migration-from-vue-router-0.7.x"><a name=#guide/migration-vue-router.md></a>Migration from Vue Router 0.7.x</h1>
<blockquote>
<p>Only Vue Router 2 is compatible with Vue 2, so if you're updating Vue, you'll have to update Vue Router as well. That's why we've included details on the migration path here in the main docs. For a complete guide on using the new Vue Router, see the <a href="https://router.vuejs.org/en/">Vue Router docs</a>.</p>
</blockquote>
<h2 id="router-initialization">Router Initialization</h2>
<h3 id="router.start-replaced"><code>router.start</code> <sup>replaced</sup></h3>
<p>There is no longer a special API to initialize an app with Vue Router. That means instead of:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">router</span>.<span class="at">start</span>(<span class="op">{</span>
  <span class="dt">template</span><span class="op">:</span> <span class="st">&#39;&lt;router-view&gt;&lt;/router-view&gt;&#39;</span>
<span class="op">},</span> <span class="st">&#39;#app&#39;</span>)</code></pre></div>
<p>You pass a router property to a Vue instance:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#app&#39;</span><span class="op">,</span>
  <span class="dt">router</span><span class="op">:</span> router<span class="op">,</span>
  <span class="dt">template</span><span class="op">:</span> <span class="st">&#39;&lt;router-view&gt;&lt;/router-view&gt;&#39;</span>
<span class="op">}</span>)</code></pre></div>
<p>Or, if you're using the runtime-only build of Vue:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">new</span> <span class="at">Vue</span>(<span class="op">{</span>
  <span class="dt">el</span><span class="op">:</span> <span class="st">&#39;#app&#39;</span><span class="op">,</span>
  <span class="dt">router</span><span class="op">:</span> router<span class="op">,</span>
  <span class="dt">render</span><span class="op">:</span> h <span class="op">=&gt;</span> <span class="at">h</span>(<span class="st">&#39;router-view&#39;</span>)
<span class="op">}</span>)</code></pre></div>
<h2 id="route-definitions">Route Definitions</h2>
<h3 id="router.map-replaced"><code>router.map</code> <sup>replaced</sup></h3>
<p>Routes are now defined as an array on a <a href="https://router.vuejs.org/en/essentials/getting-started.html#javascript"><code>routes</code> option</a> at router instantiation. So these routes for example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">router</span>.<span class="at">map</span>(<span class="op">{</span>
  <span class="st">&#39;/foo&#39;</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">component</span><span class="op">:</span> Foo
  <span class="op">},</span>
  <span class="st">&#39;/bar&#39;</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">component</span><span class="op">:</span> Bar
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<p>Will instead be defined with:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> router <span class="op">=</span> <span class="kw">new</span> <span class="at">VueRouter</span>(<span class="op">{</span>
  <span class="dt">routes</span><span class="op">:</span> [
    <span class="op">{</span> <span class="dt">path</span><span class="op">:</span> <span class="st">&#39;/foo&#39;</span><span class="op">,</span> <span class="dt">component</span><span class="op">:</span> Foo <span class="op">},</span>
    <span class="op">{</span> <span class="dt">path</span><span class="op">:</span> <span class="st">&#39;/bar&#39;</span><span class="op">,</span> <span class="dt">component</span><span class="op">:</span> Bar <span class="op">}</span>
  ]
<span class="op">}</span>)</code></pre></div>
<p>The array syntax allows more predictable route matching, since iterating over an object is not guaranteed to use the same property order across browsers.</p>
<h3 id="router.on-removed"><code>router.on</code> <sup>removed</sup></h3>
<p>If you need to programmatically generate routes when starting up your app, you can do so by dynamically pushing definitions to a routes array. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="co">// Normal base routes</span>
<span class="kw">var</span> routes <span class="op">=</span> [
  <span class="co">// ...</span>
]

<span class="co">// Dynamically generated routes</span>
<span class="va">marketingPages</span>.<span class="at">forEach</span>(<span class="kw">function</span> (page) <span class="op">{</span>
  <span class="va">routes</span>.<span class="at">push</span>(<span class="op">{</span>
    <span class="dt">path</span><span class="op">:</span> <span class="st">&#39;/marketing/&#39;</span> <span class="op">+</span> <span class="va">page</span>.<span class="at">slug</span>
    <span class="dt">component</span><span class="op">:</span> <span class="op">{</span>
      <span class="dt">extends</span><span class="op">:</span> MarketingComponent
      <span class="dt">data</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
        <span class="cf">return</span> <span class="op">{</span> <span class="dt">page</span><span class="op">:</span> page <span class="op">}</span>
      <span class="op">}</span>
    <span class="op">}</span>
  <span class="op">}</span>)
<span class="op">}</span>)

<span class="kw">var</span> router <span class="op">=</span> <span class="kw">new</span> <span class="at">Router</span>(<span class="op">{</span>
  <span class="dt">routes</span><span class="op">:</span> routes
<span class="op">}</span>)</code></pre></div>
<p>If you need to add new routes after the router has been instantiated, you can replace the router's matcher with a new one that includes the route you'd like to add:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">router</span>.<span class="at">match</span> <span class="op">=</span> <span class="at">createMatcher</span>(
  [<span class="op">{</span>
    <span class="dt">path</span><span class="op">:</span> <span class="st">&#39;/my/new/path&#39;</span><span class="op">,</span>
    <span class="dt">component</span><span class="op">:</span> MyComponent
  <span class="op">}</span>].<span class="at">concat</span>(<span class="va">router</span>.<span class="va">options</span>.<span class="at">routes</span>)
)</code></pre></div>
<h3 id="router.beforeeach-changed"><code>router.beforeEach</code> <sup>changed</sup></h3>
<p><code>router.beforeEach</code> now works asynchronously and takes a <code>next</code> function as its third argument.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">router</span>.<span class="at">beforeEach</span>(<span class="kw">function</span> (transition) <span class="op">{</span>
  <span class="cf">if</span> (<span class="va">transition</span>.<span class="va">to</span>.<span class="at">path</span> <span class="op">===</span> <span class="st">&#39;/forbidden&#39;</span>) <span class="op">{</span>
    <span class="va">transition</span>.<span class="at">abort</span>()
  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
    <span class="va">transition</span>.<span class="at">next</span>()
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">router</span>.<span class="at">beforeEach</span>(<span class="kw">function</span> (to<span class="op">,</span> <span class="im">from</span><span class="op">,</span> next) <span class="op">{</span>
  <span class="cf">if</span> (<span class="va">to</span>.<span class="at">path</span> <span class="op">===</span> <span class="st">&#39;/forbidden&#39;</span>) <span class="op">{</span>
    <span class="at">next</span>(<span class="kw">false</span>)
  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
    <span class="at">next</span>()
  <span class="op">}</span>
<span class="op">}</span>)</code></pre></div>
<h3 id="subroutes-renamed"><code>subRoutes</code> <sup>renamed</sup></h3>
<p><a href="https://router.vuejs.org/en/essentials/nested-routes.html">Renamed to <code>children</code></a> for consistency within Vue and with other routing libraries.</p>
<h3 id="router.redirect-replaced"><code>router.redirect</code> <sup>replaced</sup></h3>
<p>This is now an <a href="https://router.vuejs.org/en/essentials/redirect-and-alias.html">option on route definitions</a>. So for example, you will update:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">router</span>.<span class="at">redirect</span>(<span class="op">{</span>
  <span class="st">&#39;/tos&#39;</span><span class="op">:</span> <span class="st">&#39;/terms-of-service&#39;</span>
<span class="op">}</span>)</code></pre></div>
<p>to a definition like below in your <code>routes</code> configuration:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="op">{</span>
  <span class="dt">path</span><span class="op">:</span> <span class="st">&#39;/tos&#39;</span><span class="op">,</span>
  <span class="dt">redirect</span><span class="op">:</span> <span class="st">&#39;/terms-of-service&#39;</span>
<span class="op">}</span></code></pre></div>
<h3 id="router.alias-replaced"><code>router.alias</code> <sup>replaced</sup></h3>
<p>This is now an <a href="https://router.vuejs.org/en/essentials/redirect-and-alias.html">option on the definition for the route</a> you'd like to alias to. So for example, you will update:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">router</span>.<span class="at">alias</span>(<span class="op">{</span>
  <span class="st">&#39;/manage&#39;</span><span class="op">:</span> <span class="st">&#39;/admin&#39;</span>
<span class="op">}</span>)</code></pre></div>
<p>to a definition like below in your <code>routes</code> configuration:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="op">{</span>
  <span class="dt">path</span><span class="op">:</span> <span class="st">&#39;/admin&#39;</span><span class="op">,</span>
  <span class="dt">component</span><span class="op">:</span> AdminPanel<span class="op">,</span>
  <span class="dt">alias</span><span class="op">:</span> <span class="st">&#39;/manage&#39;</span>
<span class="op">}</span></code></pre></div>
<p>If you need multiple aliases, you can also use an array syntax:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">alias<span class="op">:</span> [<span class="st">&#39;/manage&#39;</span><span class="op">,</span> <span class="st">&#39;/administer&#39;</span><span class="op">,</span> <span class="st">&#39;/administrate&#39;</span>]</code></pre></div>
<h3 id="arbitrary-route-properties-replaced">Arbitrary Route Properties <sup>replaced</sup></h3>
<p>Arbitrary route properties must now be scoped under the new meta property, to avoid conflicts with future features. So for example, if you had defined:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="st">&#39;/admin&#39;</span><span class="op">:</span> <span class="op">{</span>
  <span class="dt">component</span><span class="op">:</span> AdminPanel<span class="op">,</span>
  <span class="dt">requiresAuth</span><span class="op">:</span> <span class="kw">true</span>
<span class="op">}</span></code></pre></div>
<p>Then you would now update it to:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="op">{</span>
  <span class="dt">path</span><span class="op">:</span> <span class="st">&#39;/admin&#39;</span><span class="op">,</span>
  <span class="dt">component</span><span class="op">:</span> AdminPanel<span class="op">,</span>
  <span class="dt">meta</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">requiresAuth</span><span class="op">:</span> <span class="kw">true</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>Then when later accessing this property on a route, you will still go through meta. For example:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="cf">if</span> (<span class="va">route</span>.<span class="va">meta</span>.<span class="at">requiresAuth</span>) <span class="op">{</span>
  <span class="co">// ...</span>
<span class="op">}</span></code></pre></div>
<h3 id="syntax-for-arrays-in-queries-removed">[] Syntax for Arrays in Queries <sup>removed</sup></h3>
<p>When passing arrays to query parameters the QueryString syntax is no longer <code>/foo?users[]=Tom&amp;users[]=Jerry</code>, instead, the new syntax is <code>/foo?users=Tom&amp;users=Jerry</code>. Internally, <code>$route.query.users</code> will still be an Array, but if there's only one parameter in the query: <code>/foo?users=Tom</code>, when directly accessing this route, there's no way for the router to know if we were expecting <code>users</code> to be an Array. Because of this, consider adding a computed property and replacing every reference of <code>$route.query.users</code> with it:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="im">export</span> <span class="im">default</span> <span class="op">{</span>
  <span class="co">// ...</span>
  <span class="dt">computed</span><span class="op">:</span> <span class="op">{</span>
    <span class="co">// users will always be an array</span>
    <span class="at">users</span> () <span class="op">{</span>
      <span class="kw">const</span> users <span class="op">=</span> <span class="kw">this</span>.<span class="va">$route</span>.<span class="va">query</span>.<span class="at">users</span>
      <span class="cf">return</span> <span class="va">Array</span>.<span class="at">isArray</span>(users) <span class="op">?</span> users : [users]
    <span class="op">}</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<h2 id="route-matching">Route Matching</h2>
<p>Route matching now uses <a href="https://github.com/pillarjs/path-to-regexp">path-to-regexp</a> under the hood, making it much more flexible than previously.</p>
<h3 id="one-or-more-named-parameters-changed">One or More Named Parameters <sup>changed</sup></h3>
<p>The syntax has changed slightly, so <code>/category/*tags</code> for example, should be updated to <code>/category/:tags+</code>.</p>
<h2 id="links">Links</h2>
<h3 id="v-link-replaced"><code>v-link</code> <sup>replaced</sup></h3>
<p>The <code>v-link</code> directive has been replaced with a new <a href="https://router.vuejs.org/en/api/router-link.html"><code>&lt;router-link&gt;</code> component</a>, as this sort of job is now solely the responsibility of components in Vue 2. That means whenever wherever you have a link like this:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;a</span><span class="ot"> v-link=</span><span class="st">&quot;&#39;/about&#39;&quot;</span><span class="kw">&gt;</span>About<span class="kw">&lt;/a&gt;</span></code></pre></div>
<p>You'll need to update it like this:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;router-link</span><span class="ot"> to=</span><span class="st">&quot;/about&quot;</span><span class="kw">&gt;</span>About<span class="kw">&lt;/router-link&gt;</span></code></pre></div>
<p>Note that <code>target=&quot;_blank&quot;</code> is not supported on <code>&lt;router-link&gt;</code>, so if you need to open a link in a new tab, you have to use <code>&lt;a&gt;</code> instead.</p>
<h3 id="v-link-active-replaced"><code>v-link-active</code> <sup>replaced</sup></h3>
<p>The <code>v-link-active</code> directive has also been replaced by the <code>tag</code> attribute on <a href="https://router.vuejs.org/en/api/router-link.html">the <code>&lt;router-link&gt;</code> component</a>. So for example, you'll update this:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;li</span><span class="ot"> v-link-active</span><span class="kw">&gt;</span>
  <span class="kw">&lt;a</span><span class="ot"> v-link=</span><span class="st">&quot;&#39;/about&#39;&quot;</span><span class="kw">&gt;</span>About<span class="kw">&lt;/a&gt;</span>
<span class="kw">&lt;/li&gt;</span></code></pre></div>
<p>to this:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;router-link</span><span class="ot"> tag=</span><span class="st">&quot;li&quot;</span><span class="ot"> to=</span><span class="st">&quot;/about&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;a&gt;</span>About<span class="kw">&lt;/a&gt;</span>
<span class="kw">&lt;/router-link&gt;</span></code></pre></div>
<p>The <code>&lt;a&gt;</code> will be the actual link (and will get the correct href), but the active class will be applied to the outer <code>&lt;li&gt;</code>.</p>
<h2 id="programmatic-navigation">Programmatic Navigation</h2>
<h3 id="router.go-changed"><code>router.go</code> <sup>changed</sup></h3>
<p>For consistency with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API">HTML5 History API</a>, <code>router.go</code> is now only used for <a href="https://router.vuejs.org/en/essentials/navigation.html#routergon">back/forward navigation</a>, while <a href="https://router.vuejs.org/en/essentials/navigation.html#routerpushlocation"><code>router.push</code></a> is used to navigate to a specific page.</p>
<h2 id="router-options-modes">Router Options: Modes</h2>
<h3 id="hashbang-false-removed"><code>hashbang: false</code> <sup>removed</sup></h3>
<p>Hashbangs are no longer required for Google to crawl a URL, so they are no longer the default (or even an option) for the hash strategy.</p>
<h3 id="history-true-replaced"><code>history: true</code> <sup>replaced</sup></h3>
<p>All routing mode options have been condensed into a single <a href="https://router.vuejs.org/en/api/options.html#mode"><code>mode</code> option</a>. Update:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> router <span class="op">=</span> <span class="kw">new</span> <span class="at">VueRouter</span>(<span class="op">{</span>
  <span class="dt">history</span><span class="op">:</span> <span class="st">&#39;true&#39;</span>
<span class="op">}</span>)</code></pre></div>
<p>to:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> router <span class="op">=</span> <span class="kw">new</span> <span class="at">VueRouter</span>(<span class="op">{</span>
  <span class="dt">mode</span><span class="op">:</span> <span class="st">&#39;history&#39;</span>
<span class="op">}</span>)</code></pre></div>
<h3 id="abstract-true-replaced"><code>abstract: true</code> <sup>replaced</sup></h3>
<p>All routing mode options have been condensed into a single <a href="https://router.vuejs.org/en/api/options.html#mode"><code>mode</code> option</a>. Update:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> router <span class="op">=</span> <span class="kw">new</span> <span class="at">VueRouter</span>(<span class="op">{</span>
  <span class="dt">abstract</span><span class="op">:</span> <span class="st">&#39;true&#39;</span>
<span class="op">}</span>)</code></pre></div>
<p>to:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> router <span class="op">=</span> <span class="kw">new</span> <span class="at">VueRouter</span>(<span class="op">{</span>
  <span class="dt">mode</span><span class="op">:</span> <span class="st">&#39;abstract&#39;</span>
<span class="op">}</span>)</code></pre></div>
<h2 id="route-options-misc">Route Options: Misc</h2>
<h3 id="savescrollposition-replaced"><code>saveScrollPosition</code> <sup>replaced</sup></h3>
<p>This has been replaced with a <a href="https://router.vuejs.org/en/advanced/scroll-behavior.html"><code>scrollBehavior</code> option</a> that accepts a function, so that the scroll behavior is completely customizable - even per route. This opens many new possibilities, but to replicate the old behavior of:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">saveScrollPosition<span class="op">:</span> <span class="kw">true</span></code></pre></div>
<p>You can replace it with:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">scrollBehavior<span class="op">:</span> <span class="kw">function</span> (to<span class="op">,</span> <span class="im">from</span><span class="op">,</span> savedPosition) <span class="op">{</span>
  <span class="cf">return</span> savedPosition <span class="op">||</span> <span class="op">{</span> <span class="dt">x</span><span class="op">:</span> <span class="dv">0</span><span class="op">,</span> <span class="dt">y</span><span class="op">:</span> <span class="dv">0</span> <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<h3 id="root-renamed"><code>root</code> <sup>renamed</sup></h3>
<p>Renamed to <code>base</code> for consistency with <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base">the HTML <code>&lt;base&gt;</code> element</a>.</p>
<h3 id="transitiononload-removed"><code>transitionOnLoad</code> <sup>removed</sup></h3>
<p>This option is no longer necessary now that Vue's transition system has explicit <a href="transitions.html#Transitions-on-Initial-Render"><code>appear</code> transition control</a>.</p>
<h3 id="suppresstransitionerror-removed"><code>suppressTransitionError</code> <sup>removed</sup></h3>
<p>Removed due to hooks simplification. If you really must suppress transition errors, you can use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch"><code>try</code>...<code>catch</code></a> instead.</p>
<h2 id="route-hooks">Route Hooks</h2>
<h3 id="activate-replaced"><code>activate</code> <sup>replaced</sup></h3>
<p>Use <a href="https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards"><code>beforeRouteEnter</code></a> in the component instead.</p>
<h3 id="canactivate-replaced"><code>canActivate</code> <sup>replaced</sup></h3>
<p>Use <a href="https://router.vuejs.org/en/advanced/navigation-guards.html#perroute-guard"><code>beforeEnter</code></a> in the route instead.</p>
<h3 id="deactivate-removed"><code>deactivate</code> <sup>removed</sup></h3>
<p>Use the component's <a href="../api/#beforeDestroy"><code>beforeDestroy</code></a> or <a href="../api/#destroyed"><code>destroyed</code></a> hooks instead.</p>
<h3 id="candeactivate-replaced"><code>canDeactivate</code> <sup>replaced</sup></h3>
<p>Use <a href="https://router.vuejs.org/en/advanced/navigation-guards.html#incomponent-guards"><code>beforeRouteLeave</code></a> in the component instead.</p>
<h3 id="canreuse-false-removed"><code>canReuse: false</code> <sup>removed</sup></h3>
<p>There's no longer a use case for this in the new Vue Router.</p>
<h3 id="data-replaced"><code>data</code> <sup>replaced</sup></h3>
<p>The <code>$route</code> property is now reactive, so you can use a watcher to react to route changes, like this:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">watch<span class="op">:</span> <span class="op">{</span>
  <span class="st">&#39;$route&#39;</span><span class="op">:</span> <span class="st">&#39;fetchData&#39;</span>
<span class="op">},</span>
methods<span class="op">:</span> <span class="op">{</span>
  <span class="dt">fetchData</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="co">// ...</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<h3 id="loadingroutedata-removed"><code>$loadingRouteData</code> <sup>removed</sup></h3>
<p>Define your own property (e.g. <code>isLoading</code>), then update the loading state in a watcher on the route. For example, if fetching data with <a href="https://github.com/mzabriskie/axios">axios</a>:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript">data<span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
  <span class="cf">return</span> <span class="op">{</span>
    <span class="dt">posts</span><span class="op">:</span> []<span class="op">,</span>
    <span class="dt">isLoading</span><span class="op">:</span> <span class="kw">false</span><span class="op">,</span>
    <span class="dt">fetchError</span><span class="op">:</span> <span class="kw">null</span>
  <span class="op">}</span>
<span class="op">},</span>
watch<span class="op">:</span> <span class="op">{</span>
  <span class="st">&#39;$route&#39;</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="kw">var</span> self <span class="op">=</span> <span class="kw">this</span>
    <span class="va">self</span>.<span class="at">isLoading</span> <span class="op">=</span> <span class="kw">true</span>
    <span class="va">self</span>.<span class="at">fetchData</span>().<span class="at">then</span>(<span class="kw">function</span> () <span class="op">{</span>
      <span class="va">self</span>.<span class="at">isLoading</span> <span class="op">=</span> <span class="kw">false</span>
    <span class="op">}</span>)
  <span class="op">}</span>
<span class="op">},</span>
methods<span class="op">:</span> <span class="op">{</span>
  <span class="dt">fetchData</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
    <span class="kw">var</span> self <span class="op">=</span> <span class="kw">this</span>
    <span class="cf">return</span> <span class="va">axios</span>.<span class="at">get</span>(<span class="st">&#39;/api/posts&#39;</span>)
      .<span class="at">then</span>(<span class="kw">function</span> (response) <span class="op">{</span>
        <span class="va">self</span>.<span class="at">posts</span> <span class="op">=</span> <span class="va">response</span>.<span class="va">data</span>.<span class="at">posts</span>
      <span class="op">}</span>)
      .<span class="at">catch</span>(<span class="kw">function</span> (error) <span class="op">{</span>
        <span class="va">self</span>.<span class="at">fetchError</span> <span class="op">=</span> error
      <span class="op">}</span>)
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<h1 id="migration-from-vuex-0.6.x-to-1.0"><a name=#guide/migration-vuex.md></a>Migration from Vuex 0.6.x to 1.0</h1>
<blockquote>
<p>Vuex 2.0 is released, but this guide only covers the migration to 1.0? Is that a typo? Also, it looks like Vuex 1.0 and 2.0 were released simultaneously. What's going on? Which one should I use and what's compatible with Vue 2.0?</p>
</blockquote>
<p>Both Vuex 1.0 and 2.0:</p>
<ul>
<li>fully support both Vue 1.0 and 2.0</li>
<li>will be maintained for the foreseeable future</li>
</ul>
<p>They have slightly different target users however.</p>
<p><strong>Vuex 2.0</strong> is a radical redesign and simplification of the API, for those who are starting new projects or want to be on the cutting edge of client-side state management. <strong>It is not covered by this migration guide</strong>, so you should check out <a href="https://vuex.vuejs.org/en/index.html">the Vuex 2.0 docs</a> if you'd like to learn more about it.</p>
<p><strong>Vuex 1.0</strong> is mostly backwards-compatible, so requires very few changes to upgrade. It is recommended for those with large existing codebases or who want the smoothest possible upgrade path to Vue 2.0. This guide is dedicated to facilitating that process, but only includes migration notes. For the complete usage guide, see <a href="https://github.com/vuejs/vuex/tree/1.0/docs/en">the Vuex 1.0 docs</a>.</p>
<h2 id="store.watch-with-string-property-path-replaced"><code>store.watch</code> with String Property Path <sup>replaced</sup></h2>
<p><code>store.watch</code> now only accept functions. So for example, you would have to replace:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">store</span>.<span class="at">watch</span>(<span class="st">&#39;user.notifications&#39;</span><span class="op">,</span> callback)</code></pre></div>
<p>with:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="va">store</span>.<span class="at">watch</span>(
  <span class="co">// When the returned result changes...</span>
  <span class="kw">function</span> (state) <span class="op">{</span>
    <span class="cf">return</span> <span class="va">state</span>.<span class="va">user</span>.<span class="at">notifications</span>
  <span class="op">},</span>
  <span class="co">// Run this callback</span>
  callback
)</code></pre></div>
<p>This gives you more complete control over the reactive properties you'd like to watch.</p>
<h2 id="stores-event-emitter-removed">Store's Event Emitter <sup>removed</sup></h2>
<p>The store instance no longer exposes the event emitter interface (<code>on</code>, <code>off</code>, <code>emit</code>). If you were previously using the store as a global event bus, <a href="migration.html#dispatch-and-broadcast-removed">see this section</a> for migration instructions.</p>
<p>Instead of using this interface to watch events emitted by the store itself (e.g. <code>store.on('mutation', callback)</code>), a new method <code>store.subscribe</code> is introduced. Typical usage inside a plugin would be:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">var</span> myPlugin <span class="op">=</span> store <span class="op">=&gt;</span> <span class="op">{</span>
  <span class="va">store</span>.<span class="at">subscribe</span>(<span class="kw">function</span> (mutation<span class="op">,</span> state) <span class="op">{</span>
    <span class="co">// Do something...</span>
  <span class="op">}</span>)
<span class="op">}</span></code></pre></div>
<p>See example <a href="https://github.com/vuejs/vuex/blob/1.0/docs/en/plugins.md">the plugins docs</a> for more info.</p>
<h2 id="middlewares-replaced">Middlewares <sup>replaced</sup></h2>
<p>Middlewares are replaced by plugins. A plugin is a function that receives the store as the only argument, and can listen to the mutation event on the store:</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">const</span> myPlugins <span class="op">=</span> store <span class="op">=&gt;</span> <span class="op">{</span>
  <span class="va">store</span>.<span class="at">subscribe</span>(<span class="st">&#39;mutation&#39;</span><span class="op">,</span> (mutation<span class="op">,</span> state) <span class="op">=&gt;</span> <span class="op">{</span>
    <span class="co">// Do something...</span>
  <span class="op">}</span>)
<span class="op">}</span></code></pre></div>
<p>For more details, see <a href="https://github.com/vuejs/vuex/blob/1.0/docs/en/plugins.md">the plugins docs</a>.</p>
<h1 id="comparison-with-other-frameworks"><a name=#guide/comparison.md></a>Comparison with Other Frameworks</h1>
<p>This is definitely the most difficult page in the guide to write, but we do feel it's important. Odds are, you've had problems you tried to solve and you've used another library to solve them. You're here because you want to know if Vue can solve your specific problems better. That's what we hope to answer for you.</p>
<p>We also try very hard to avoid bias. As the core team, we obviously like Vue a lot. There are some problems we think it solves better than anything else out there. If we didn't believe that, we wouldn't be working on it. We do want to be fair and accurate though. Where other libraries offer significant advantages, such as React's vast ecosystem of alternative renderers or Knockout's browser support back to IE6, we try to list these as well.</p>
<p>We'd also like <strong>your</strong> help keeping this document up-to-date because the JavaScript world moves fast! If you notice an inaccuracy or something that doesn't seem quite right, please let us know by <a href="https://github.com/vuejs/vuejs.org/issues/new?title=Inaccuracy+in+comparisons+guide">opening an issue</a>.</p>
<h2 id="react">React</h2>
<p>React and Vue share many similarities. They both:</p>
<ul>
<li>utilize a virtual DOM</li>
<li>provide reactive and composable view components</li>
<li>maintain focus in the core library, with concerns such as routing and global state management handled by companion libraries</li>
</ul>
<p>Being so similar in scope, we've put more time into fine-tuning this comparison than any other. We want to ensure not only technical accuracy, but also balance. We point out where React outshines Vue, for example in the richness of their ecosystem and abundance of their custom renderers.</p>
<p>With that said, it's inevitable that the comparison would appear biased towards Vue to some React users, as many of the subjects explored are to some extent subjective. We acknowledge the existence of varying technical taste, and this comparison primarily aims to outline the reasons why Vue could potentially be a better fit if your preferences happen to coincide with ours.</p>
<p>Some of the sections below may also be slightly outdated due to recent updates in React 16+, and we are planning to work with the React community to revamp this section in the near future.</p>
<h3 id="runtime-performance">Runtime Performance</h3>
<p>Both React and Vue are exceptionally and similarly fast, so speed is unlikely to be a deciding factor in choosing between them. For specific metrics though, check out this <a href="https://stefankrause.net/js-frameworks-benchmark8/table.html">3rd party benchmark</a>, which focuses on raw render/update performance with very simple component trees.</p>
<h4 id="optimization-efforts">Optimization Efforts</h4>
<p>In React, when a component's state changes, it triggers the re-render of the entire component sub-tree, starting at that component as root. To avoid unnecessary re-renders of child components, you need to either use <code>PureComponent</code> or implement <code>shouldComponentUpdate</code> whenever you can. You may also need to use immutable data structures to make your state changes more optimization-friendly. However, in certain cases you may not be able to rely on such optimizations because <code>PureComponent/shouldComponentUpdate</code> assumes the entire sub tree's render output is determined by the props of the current component. If that is not the case, then such optimizations may lead to inconsistent DOM state.</p>
<p>In Vue, a component's dependencies are automatically tracked during its render, so the system knows precisely which components actually need to re-render when state changes. Each component can be considered to have <code>shouldComponentUpdate</code> automatically implemented for you, without the nested component caveats.</p>
<p>Overall this removes the need for a whole class of performance optimizations from the developer's plate, and allows them to focus more on building the app itself as it scales.</p>
<h3 id="html-css">HTML &amp; CSS</h3>
<p>In React, everything is just JavaScript. Not only are HTML structures expressed via JSX, the recent trends also tend to put CSS management inside JavaScript as well. This approach has its own benefits, but also comes with various trade-offs that may not seem worthwhile for every developer.</p>
<p>Vue embraces classic web technologies and builds on top of them. To show you what that means, we'll dive into some examples.</p>
<h4 id="jsx-vs-templates">JSX vs Templates</h4>
<p>In React, all components express their UI within render functions using JSX, a declarative XML-like syntax that works within JavaScript.</p>
<p>Render functions with JSX have a few advantages:</p>
<ul>
<li><p>You can leverage the power of a full programming language (JavaScript) to build your view. This includes temporary variables, flow controls, and directly referencing JavaScript values in scope.</p></li>
<li><p>The tooling support (e.g. linting, type checking, editor autocompletion) for JSX is in some ways more advanced than what's currently available for Vue templates.</p></li>
</ul>
<p>In Vue, we also have <a href="render-function.html">render functions</a> and even <a href="render-function.html#JSX">support JSX</a>, because sometimes you do need that power. However, as the default experience we offer templates as a simpler alternative. Any valid HTML is also a valid Vue template, and this leads to a few advantages of its own:</p>
<ul>
<li><p>For many developers who have been working with HTML, templates feel more natural to read and write. The preference itself can be somewhat subjective, but if it makes the developer more productive then the benefit is objective.</p></li>
<li><p>HTML-based templates make it much easier to progressively migrate existing applications to take advantage of Vue's reactivity features.</p></li>
<li><p>It also makes it much easier for designers and less experienced developers to parse and contribute to the codebase.</p></li>
<li><p>You can even use pre-processors such as Pug (formerly known as Jade) to author your Vue templates.</p></li>
</ul>
<p>Some argue that you'd need to learn an extra DSL (Domain-Specific Language) to be able to write templates - we believe this difference is superficial at best. First, JSX doesn't mean the user doesn't need to learn anything - it's additional syntax on top of plain JavaScript, so it can be easy for someone familiar with JavaScript to learn, but saying it's essentially free is misleading. Similarly, a template is just additional syntax on top of plain HTML and thus has very low learning cost for those who are already familiar with HTML. With the DSL we are also able to help the user get more done with less code (e.g. <code>v-on</code> modifiers). The same task can involve a lot more code when using plain JSX or render functions.</p>
<p>On a higher level, we can divide components into two categories: presentational ones and logical ones. We recommend using templates for presentational components and render function / JSX for logical ones. The percentage of these components depends on the type of app you are building, but in general we find presentational ones to be much more common.</p>
<h4 id="component-scoped-css">Component-Scoped CSS</h4>
<p>Unless you spread components out over multiple files (for example with <a href="https://github.com/gajus/react-css-modules">CSS Modules</a>), scoping CSS in React is often done via CSS-in-JS solutions (e.g. <a href="https://github.com/styled-components/styled-components">styled-components</a> and <a href="https://github.com/emotion-js/emotion">emotion</a>). This introduces a new component-oriented styling paradigm that is different from the normal CSS authoring process. Additionally, although there is support for extracting CSS into a single stylesheet at build time, it is still common that a runtime will need to be included in the bundle for styling to work properly. While you gain access to the dynamism of JavaScript while constructing your styles, the tradeoff is often increased bundle size and runtime cost.</p>
<p>If you are a fan of CSS-in-JS, many of the popular CSS-in-JS libraries support Vue (e.g. <a href="https://github.com/styled-components/vue-styled-components">styled-components-vue</a> and <a href="https://github.com/egoist/vue-emotion">vue-emotion</a>). The main difference between React and Vue here is that the default method of styling in Vue is through more familiar <code>style</code> tags in <a href="single-file-components.html">single-file components</a>.</p>
<p><a href="single-file-components.html">Single-file components</a> give you full access to CSS in the same file as the rest of your component code.</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;style</span><span class="ot"> scoped</span><span class="kw">&gt;</span>
  <span class="im">@media</span> (<span class="kw">min-width</span>: <span class="dv">250px</span>) {
    <span class="fu">.list-container</span><span class="in">:hover</span> {
      <span class="kw">background</span>: orange;
    }
  }
<span class="kw">&lt;/style&gt;</span></code></pre></div>
<p>The optional <code>scoped</code> attribute automatically scopes this CSS to your component by adding a unique attribute (such as <code>data-v-21e5b78</code>) to elements and compiling <code>.list-container:hover</code> to something like <code>.list-container[data-v-21e5b78]:hover</code>.</p>
<p>Lastly, the styling in Vue's single-file components is very flexible. Through <a href="https://github.com/vuejs/vue-loader">vue-loader</a>, you can use any preprocessor, post-processor, and even deep integration with <a href="https://vue-loader.vuejs.org/en/features/css-modules.html">CSS Modules</a> -- all within the <code>&lt;style&gt;</code> element.</p>
<h3 id="scale">Scale</h3>
<h4 id="scaling-up">Scaling Up</h4>
<p>For large applications, both Vue and React offer robust routing solutions. The React community has also been very innovative in terms of state management solutions (e.g. Flux/Redux). These state management patterns and <a href="https://yarnpkg.com/en/packages?q=redux%20vue&amp;p=1">even Redux itself</a> can be easily integrated into Vue applications. In fact, Vue has even taken this model a step further with <a href="https://github.com/vuejs/vuex">Vuex</a>, an Elm-inspired state management solution that integrates deeply into Vue that we think offers a superior development experience.</p>
<p>Another important difference between these offerings is that Vue's companion libraries for state management and routing (among <a href="https://github.com/vuejs">other concerns</a>) are all officially supported and kept up-to-date with the core library. React instead chooses to leave these concerns to the community, creating a more fragmented ecosystem. Being more popular though, React's ecosystem is considerably richer than Vue's.</p>
<p>Finally, Vue offers a <a href="https://github.com/vuejs/vue-cli">CLI project generator</a> that makes it trivially easy to start a new project by featuring an interactive project scaffolding wizard. You can even use it for <a href="https://cli.vuejs.org/guide/prototyping.html#instant-prototyping">instantly prototyping</a> a component. React is also making strides in this area with <a href="https://github.com/facebookincubator/create-react-app">create-react-app</a>, but it currently has a few limitations:</p>
<ul>
<li>It does not allow any configuration during project generation, while Vue CLI runs on top of an upgradeable runtime dependency that can be extended via <a href="https://cli.vuejs.org/guide/plugins-and-presets.html#plugins">plugins</a>.</li>
<li>It only offers a single template that assumes you're building a single-page application, while Vue offers a wide variety of default options for various purposes and build systems.</li>
<li>It cannot generate projects from user-built <a href="https://cli.vuejs.org/guide/plugins-and-presets.html#presets">presets</a>, which can be especially useful for enterprise environments with pre-established conventions.</li>
</ul>
<p>It's important to note that many of these limitations are intentional design decisions made by the create-react-app team and they do have their advantages. For example, as long as your project's needs are very simple and you never need to &quot;eject&quot; to customize your build process, you'll be able to update it as a dependency. You can read more about the <a href="https://github.com/facebookincubator/create-react-app#philosophy">differing philosophy here</a>.</p>
<h4 id="scaling-down">Scaling Down</h4>
<p>React is renowned for its steep learning curve. Before you can really get started, you need to know about JSX and probably ES2015+, since many examples use React's class syntax. You also have to learn about build systems, because although you could technically use Babel Standalone to live-compile your code in the browser, it's absolutely not suitable for production.</p>
<p>While Vue scales up just as well as React, it also scales down just as well as jQuery. That's right - to get started, all you have to do is drop a single script tag into the page:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;https://cdn.jsdelivr.net/npm/vue&quot;</span><span class="kw">&gt;&lt;/script&gt;</span></code></pre></div>
<p>Then you can start writing Vue code and even ship the minified version to production without feeling guilty or having to worry about performance problems.</p>
<p>Since you don't need to know about JSX, ES2015, or build systems to get started with Vue, it also typically takes developers less than a day reading <a href="./">the guide</a> to learn enough to build non-trivial applications.</p>
<h3 id="native-rendering">Native Rendering</h3>
<p>React Native enables you to write native-rendered apps for iOS and Android using the same React component model. This is great in that as a developer, you can apply your knowledge of a framework across multiple platforms. On this front, Vue has an official collaboration with <a href="https://weex.apache.org/">Weex</a>, a cross-platform UI framework created by Alibaba Group and being incubated by the Apache Software Foundation (ASF). Weex allows you to use the same Vue component syntax to author components that can not only be rendered in the browser, but also natively on iOS and Android!</p>
<p>At this moment, Weex is still in active development and is not as mature and battle-tested as React Native, but its development is driven by the production needs of the largest e-commerce business in the world, and the Vue team will also actively collaborate with the Weex team to ensure a smooth experience for Vue developers.</p>
<p>Another option is <a href="https://nativescript-vue.org/">NativeScript-Vue</a>, a <a href="https://www.nativescript.org/">NativeScript</a> plugin for building truly native applications using Vue.js.</p>
<h3 id="with-mobx">With MobX</h3>
<p>MobX has become quite popular in the React community and it actually uses a nearly identical reactivity system to Vue. To a limited extent, the React + MobX workflow can be thought of as a more verbose Vue, so if you're using that combination and are enjoying it, jumping into Vue is probably the next logical step.</p>
<h3 id="preact-and-other-react-like-libraries">Preact and Other React-Like Libraries</h3>
<p>React-like libraries usually try to share as much of their API and ecosystem with React as is feasible. For that reason, the vast majority of comparisons above will also apply to them. The main difference will typically be a reduced ecosystem, often significantly, compared to React. Since these libraries cannot be 100% compatible with everything in the React ecosystem, some tooling and companion libraries may not be usable. Or, even if they appear to work, they could break at any time unless your specific React-like library is officially supported on par with React.</p>
<h2 id="angularjs-angular-1">AngularJS (Angular 1)</h2>
<p>Some of Vue's syntax will look very similar to AngularJS (e.g. <code>v-if</code> vs <code>ng-if</code>). This is because there were a lot of things that AngularJS got right and these were an inspiration for Vue very early in its development. There are also many pains that come with AngularJS however, where Vue has attempted to offer a significant improvement.</p>
<h3 id="complexity">Complexity</h3>
<p>Vue is much simpler than AngularJS, both in terms of API and design. Learning enough to build non-trivial applications typically takes less than a day, which is not true for AngularJS.</p>
<h3 id="flexibility-and-modularity">Flexibility and Modularity</h3>
<p>AngularJS has strong opinions about how your applications should be structured, while Vue is a more flexible, modular solution. While this makes Vue more adaptable to a wide variety of projects, we also recognize that sometimes it's useful to have some decisions made for you, so that you can just start coding.</p>
<p>That's why we offer a full system for rapid Vue.js development. <a href="https://github.com/vuejs/vue-cli">Vue CLI</a> aims to be the standard tooling baseline for the Vue ecosystem. It ensures the various build tools work smoothly together with sensible defaults so you can focus on writing your app instead of spending hours wrangling with configurations. At the same time, it still offers the flexibility to tweak the configuration of each tool to specific needs.</p>
<h3 id="data-binding">Data binding</h3>
<p>AngularJS uses two-way binding between scopes, while Vue enforces a one-way data flow between components. This makes the flow of data easier to reason about in non-trivial applications.</p>
<h3 id="directives-vs-components">Directives vs Components</h3>
<p>Vue has a clearer separation between directives and components. Directives are meant to encapsulate DOM manipulations only, while components are self-contained units that have their own view and data logic. In AngularJS, directives do everything and components are just a specific kind of directive.</p>
<h3 id="runtime-performance-1">Runtime Performance</h3>
<p>Vue has better performance and is much, much easier to optimize because it doesn't use dirty checking. AngularJS becomes slow when there are a lot of watchers, because every time anything in the scope changes, all these watchers need to be re-evaluated again. Also, the digest cycle may have to run multiple times to &quot;stabilize&quot; if some watcher triggers another update. AngularJS users often have to resort to esoteric techniques to get around the digest cycle, and in some situations, there's no way to optimize a scope with many watchers.</p>
<p>Vue doesn't suffer from this at all because it uses a transparent dependency-tracking observation system with async queueing - all changes trigger independently unless they have explicit dependency relationships.</p>
<p>Interestingly, there are quite a few similarities in how Angular and Vue are addressing these AngularJS issues.</p>
<h2 id="angular-formerly-known-as-angular-2">Angular (Formerly known as Angular 2)</h2>
<p>We have a separate section for the new Angular because it really is a completely different framework from AngularJS. For example, it features a first-class component system, many implementation details have been completely rewritten, and the API has also changed quite drastically.</p>
<h3 id="typescript">TypeScript</h3>
<p>Angular essentially requires using TypeScript, given that almost all its documentation and learning resources are TypeScript-based. TypeScript has its benefits - static type checking can be very useful for large-scale applications, and can be a big productivity boost for developers with backgrounds in Java and C#.</p>
<p>However, not everyone wants to use TypeScript. In many smaller-scale use cases, introducing a type system may result in more overhead than productivity gain. In those cases you'd be better off going with Vue instead, since using Angular without TypeScript can be challenging.</p>
<p>Finally, although not as deeply integrated with TypeScript as Angular is, Vue also offers <a href="https://github.com/vuejs/vue/tree/dev/types">official typings</a> and <a href="https://github.com/vuejs/vue-class-component">official decorator</a> for those who wish to use TypeScript with Vue. We are also actively collaborating with the TypeScript and VSCode teams at Microsoft to improve the TS/IDE experience for Vue + TS users.</p>
<h3 id="runtime-performance-2">Runtime Performance</h3>
<p>Both frameworks are exceptionally fast, with very similar metrics on benchmarks. You can <a href="https://stefankrause.net/js-frameworks-benchmark8/table.html">browse specific metrics</a> for a more granular comparison, but speed is unlikely to be a deciding factor.</p>
<h3 id="size">Size</h3>
<p>Recent versions of Angular, with <a href="https://en.wikipedia.org/wiki/Ahead-of-time_compilation">AOT compilation</a> and <a href="https://en.wikipedia.org/wiki/Tree_shaking">tree-shaking</a>, have been able to get its size down considerably. However, a full-featured Vue 2 project with Vuex + Vue Router included (~30KB gzipped) is still significantly lighter than an out-of-the-box, AOT-compiled application generated by <code>angular-cli</code> (~65KB gzipped).</p>
<h3 id="flexibility">Flexibility</h3>
<p>Vue is much less opinionated than Angular, offering official support for a variety of build systems, with no restrictions on how you structure your application. Many developers enjoy this freedom, while some prefer having only one Right Way to build any application.</p>
<h3 id="learning-curve">Learning Curve</h3>
<p>To get started with Vue, all you need is familiarity with HTML and ES5 JavaScript (i.e. plain JavaScript). With these basic skills, you can start building non-trivial applications within less than a day of reading <a href="./">the guide</a>.</p>
<p>Angular's learning curve is much steeper. The API surface of the framework is huge and as a user you will need to familiarize yourself with a lot more concepts before getting productive. The complexity of Angular is largely due to its design goal of targeting only large, complex applications - but that does make the framework a lot more difficult for less-experienced developers to pick up.</p>
<h2 id="ember">Ember</h2>
<p>Ember is a full-featured framework that is designed to be highly opinionated. It provides a lot of established conventions and once you are familiar enough with them, it can make you very productive. However, it also means the learning curve is high and flexibility suffers. It's a trade-off when you try to pick between an opinionated framework and a library with a loosely coupled set of tools that work together. The latter gives you more freedom but also requires you to make more architectural decisions.</p>
<p>That said, it would probably make a better comparison between Vue core and Ember's <a href="https://guides.emberjs.com/v2.10.0/templates/handlebars-basics/">templating</a> and <a href="https://guides.emberjs.com/v2.10.0/object-model/">object model</a> layers:</p>
<ul>
<li><p>Vue provides unobtrusive reactivity on plain JavaScript objects and fully automatic computed properties. In Ember, you need to wrap everything in Ember Objects and manually declare dependencies for computed properties.</p></li>
<li><p>Vue's template syntax harnesses the full power of JavaScript expressions, while Handlebars' expression and helper syntax is intentionally quite limited in comparison.</p></li>
<li><p>Performance-wise, Vue outperforms Ember <a href="https://stefankrause.net/js-frameworks-benchmark8/table.html">by a fair margin</a>, even after the latest Glimmer engine update in Ember 3.x. Vue automatically batches updates, while in Ember you need to manually manage run loops in performance-critical situations.</p></li>
</ul>
<h2 id="knockout">Knockout</h2>
<p>Knockout was a pioneer in the MVVM and dependency tracking spaces and its reactivity system is very similar to Vue's. Its <a href="http://knockoutjs.com/documentation/browser-support.html">browser support</a> is also very impressive considering everything it does, with support back to IE6! Vue on the other hand only supports IE9+.</p>
<p>Over time though, Knockout development has slowed and it's begun to show its age a little. For example, its component system lacks a full set of lifecycle hooks and although it's a very common use case, the interface for passing children to a component feels a little clunky compared to <a href="components.html#Content-Distribution-with-Slots">Vue's</a>.</p>
<p>There also seem to be philosophical differences in the API design which if you're curious, can be demonstrated by how each handles the creation of a <a href="https://gist.github.com/chrisvfritz/9e5f2d6826af00fcbace7be8f6dccb89">simple todo list</a>. It's definitely somewhat subjective, but many consider Vue's API to be less complex and better structured.</p>
<h2 id="polymer">Polymer</h2>
<p>Polymer is another Google-sponsored project and in fact was a source of inspiration for Vue as well. Vue's components can be loosely compared to Polymer's custom elements and both provide a very similar development style. The biggest difference is that Polymer is built upon the latest Web Components features and requires non-trivial polyfills to work (with degraded performance) in browsers that don't support those features natively. In contrast, Vue works without any dependencies or polyfills down to IE9.</p>
<p>In Polymer, the team has also made its data-binding system very limited in order to compensate for the performance. For example, the only expressions supported in Polymer templates are boolean negation and single method calls. Its computed property implementation is also not very flexible.</p>
<h2 id="riot">Riot</h2>
<p>Riot 3.0 provides a similar component-based development model (which is called a &quot;tag&quot; in Riot), with a minimal and beautifully designed API. Riot and Vue probably share a lot in design philosophies. However, despite being a bit heavier than Riot, Vue does offer some significant advantages:</p>
<ul>
<li>Better performance. Riot <a href="https://v3.riotjs.now.sh/compare/#virtual-dom-vs-expressions-binding">traverses a DOM tree</a> rather than using a virtual DOM, so suffers from the same performance issues as AngularJS.</li>
<li>More mature tooling support. Vue provides official support for <a href="https://github.com/vuejs/vue-loader">webpack</a> and <a href="https://github.com/vuejs/vueify">Browserify</a>, while Riot relies on community support for build system integration.</li>
</ul>
<h1 id="join-the-vue.js-community"><a name=#guide/join.md></a>Join the Vue.js Community!</h1>
<p>Vue's community is growing incredibly fast and if you're reading this, there's a good chance you're ready to join it. So... welcome!</p>
<p>Now we'll answer both what the community can do for you and what you can do for the community.</p>
<h2 id="resources">Resources</h2>
<h3 id="code-of-conduct">Code of Conduct</h3>
<p>Our <a href="/coc">Code of Conduct</a> is a guide to make it easier to enrich all of us and the technical communities in which we participate.</p>
<h3 id="get-support">Get Support</h3>
<ul>
<li><a href="https://forum.vuejs.org/">Forum</a>: The best place to ask questions and get answers about Vue and its ecosystem.</li>
<li><a href="https://chat.vuejs.org/">Chat</a>: A place for Vue devs to meet and chat in real time.</li>
<li><a href="https://events.vuejs.org/meetups">Meetups</a>: Want to find local Vue.js enthusiasts like yourself? Interested in becoming a community leader? We have the help and support you need right here!</li>
<li><a href="https://github.com/vuejs">GitHub</a>: If you have a bug to report or feature to request, that's what the GitHub issues are for. We also welcome pull requests!</li>
</ul>
<h3 id="explore-the-ecosystem">Explore the Ecosystem</h3>
<ul>
<li><a href="https://github.com/vuejs/awesome-vue">The Awesome Vue Page</a>: See what other awesome resources have been published by other awesome people.</li>
<li><a href="https://forum.vuejs.org/c/show-and-tell">The &quot;Show and Tell&quot; Subforum</a>: Another great place to check out what others have built with and for the growing Vue ecosystem.</li>
</ul>
<h2 id="what-you-can-do">What You Can Do</h2>
<h3 id="contribute-code">Contribute Code</h3>
<p>As with any project, there are rules to contributing. To ensure that we can help you or accept your pull request as quickly as possible, please read <a href="https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md">the contributing guide</a>.</p>
<p>After that, you'll be ready to contribute to Vue's core repositories:</p>
<ul>
<li><a href="https://github.com/vuejs/vue">vue</a>: the core library</li>
<li><a href="https://github.com/vuejs/vuex">vuex</a>: Flux-inspired state management</li>
<li><a href="https://github.com/vuejs/vue-router">vue-router</a>: a routing system for SPAs</li>
</ul>
<p>...as well as many smaller official <a href="https://github.com/vuejs">companion libraries</a>.</p>
<h3 id="share-and-build-your-experience">Share (and Build) Your Experience</h3>
<p>Apart from answering questions and sharing resources in the forum and chat, there are a few other less obvious ways to share and expand what you know:</p>
<ul>
<li><strong>Develop learning materials.</strong> It's often said that the best way to learn is to teach. If there's something interesting you're doing with Vue, strengthen your expertise by writing a blog post, developing a workshop, or even publishing a gist that you share on social media.</li>
<li><strong>Watch a repo you care about.</strong> This will send you notifications whenever there's activity in that repository, giving you insider knowledge about ongoing discussions and upcoming features. It's a fantastic way to build expertise so that you're eventually able to help address issues and pull requests.</li>
</ul>
<h3 id="translate-docs">Translate Docs</h3>
<p>Vue has already spread across the globe, with even the core team in at least half a dozen timezones. <a href="https://forum.vuejs.org/">The forum</a> includes 7 languages and counting and many of our docs have <a href="https://github.com/vuejs?utf8=%E2%9C%93&amp;q=vuejs.org">actively-maintained translations</a>. We're very proud of Vue's international reach, but we can do even better.</p>
<p>I hope that right now, you're reading this sentence in your preferred language. If not, would you like to help us get there?</p>
<p>If so, please feel free to fork the repo for <a href="https://github.com/vuejs/vuejs.org/">these docs</a> or for any other officially maintained documentation, then start translating. Once you've made some progress, open an issue or pull request in the main repo and we'll put out a call for more contributors to help you out.</p>
<h3 id="become-a-community-leader">Become a Community Leader</h3>
<p>There's a lot you can do to help Vue grow in your community:</p>
<ul>
<li><strong>Present at your local meetup.</strong> Whether it's giving a talk or running a workshop, you can bring a lot of value to your community by helping both new and experienced Vue developers continue to grow.</li>
<li><strong>Start your own meetup.</strong> If there's not already a Vue meetup in your area, you can start your own! Use the <a href="https://events.vuejs.org/resources/#getting-started">resources at events.vuejs.org</a> to help you succeed!</li>
<li><strong>Help meetup organizers.</strong> There can never be too much help when it comes to running an event, so offer a hand to help out local organizers to help make every event a success.</li>
</ul>
<p>If you have any questions on how you can get more involved with your local Vue community, reach out at <span class="citation">[@Vuejs_Events]</span>(https://www.twitter.com/vuejs_events)!</p>
<h1 id="meet-the-team"><a name=#guide/team.md></a>Meet the Team</h1>
